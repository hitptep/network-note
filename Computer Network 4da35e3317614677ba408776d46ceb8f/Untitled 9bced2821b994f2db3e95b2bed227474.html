<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>第五章 链路层</title><style>
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.highlight-default {
}
.highlight-gray {
	color: rgb(155,154,151);
}
.highlight-brown {
	color: rgb(100,71,58);
}
.highlight-orange {
	color: rgb(217,115,13);
}
.highlight-yellow {
	color: rgb(223,171,1);
}
.highlight-teal {
	color: rgb(15,123,108);
}
.highlight-blue {
	color: rgb(11,110,153);
}
.highlight-purple {
	color: rgb(105,64,165);
}
.highlight-pink {
	color: rgb(173,26,114);
}
.highlight-red {
	color: rgb(224,62,62);
}
.highlight-gray_background {
	background: rgb(235,236,237);
}
.highlight-brown_background {
	background: rgb(233,229,227);
}
.highlight-orange_background {
	background: rgb(250,235,221);
}
.highlight-yellow_background {
	background: rgb(251,243,219);
}
.highlight-teal_background {
	background: rgb(221,237,234);
}
.highlight-blue_background {
	background: rgb(221,235,241);
}
.highlight-purple_background {
	background: rgb(234,228,242);
}
.highlight-pink_background {
	background: rgb(244,223,235);
}
.highlight-red_background {
	background: rgb(251,228,228);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(55, 53, 47, 0.6);
	fill: rgba(55, 53, 47, 0.6);
}
.block-color-brown {
	color: rgb(100,71,58);
	fill: rgb(100,71,58);
}
.block-color-orange {
	color: rgb(217,115,13);
	fill: rgb(217,115,13);
}
.block-color-yellow {
	color: rgb(223,171,1);
	fill: rgb(223,171,1);
}
.block-color-teal {
	color: rgb(15,123,108);
	fill: rgb(15,123,108);
}
.block-color-blue {
	color: rgb(11,110,153);
	fill: rgb(11,110,153);
}
.block-color-purple {
	color: rgb(105,64,165);
	fill: rgb(105,64,165);
}
.block-color-pink {
	color: rgb(173,26,114);
	fill: rgb(173,26,114);
}
.block-color-red {
	color: rgb(224,62,62);
	fill: rgb(224,62,62);
}
.block-color-gray_background {
	background: rgb(235,236,237);
}
.block-color-brown_background {
	background: rgb(233,229,227);
}
.block-color-orange_background {
	background: rgb(250,235,221);
}
.block-color-yellow_background {
	background: rgb(251,243,219);
}
.block-color-teal_background {
	background: rgb(221,237,234);
}
.block-color-blue_background {
	background: rgb(221,235,241);
}
.block-color-purple_background {
	background: rgb(234,228,242);
}
.block-color-pink_background {
	background: rgb(244,223,235);
}
.block-color-red_background {
	background: rgb(251,228,228);
}
.select-value-color-default { background-color: rgba(206,205,202,0.5); }
.select-value-color-gray { background-color: rgba(155,154,151, 0.4); }
.select-value-color-brown { background-color: rgba(140,46,0,0.2); }
.select-value-color-orange { background-color: rgba(245,93,0,0.2); }
.select-value-color-yellow { background-color: rgba(233,168,0,0.2); }
.select-value-color-green { background-color: rgba(0,135,107,0.2); }
.select-value-color-blue { background-color: rgba(0,120,223,0.2); }
.select-value-color-purple { background-color: rgba(103,36,222,0.2); }
.select-value-color-pink { background-color: rgba(221,0,129,0.2); }
.select-value-color-red { background-color: rgba(255,0,26,0.2); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="9bced282-1b99-4f2d-b3e9-5b2bed227474" class="page sans"><header><img class="page-cover-image" src="https://www.notion.so/images/page-cover/woodcuts_sekka_2.jpg" style="object-position:center 80%"/><div class="page-header-icon page-header-icon-with-cover"><span class="icon">📌</span></div><h1 class="page-title">第五章 链路层</h1></header><div class="page-body"><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="35819dd4-85fb-48fc-b903-8363484873e5"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><mark class="highlight-red">重点：多路访问协议和差错控制</mark></div></figure><h1 id="57bdc9ed-12d3-44e0-9502-34dd8349c87b" class="">一、链路层概述</h1><ul id="e6e90600-b572-49ae-bbb0-b6b76eb17380" class="toggle"><li><details open=""><summary>术语和链路层服务</summary><ul id="c2420e4f-7654-4290-9b70-94ea2f509d45" class="toggle"><li><details open=""><summary>术语</summary><ul id="5cdfaa81-73cc-41a8-a045-a306bfe2c9c0" class="bulleted-list"><li>节点<p id="86989f04-d0d7-4e0c-927c-6655b56ae0ae" class="">将运行链路层协议的任何设备均称为结点。结点包括主机、路由器、交换机和 Wi-Fi 接入点；</p></li></ul><ul id="aa265f8f-3c03-4309-af9a-68c9af522c17" class="bulleted-list"><li>链路<p id="57ac4266-c7bf-42fb-a663-a0a140862a34" class="">沿着通信路径连接相邻结点的通信信道称为链路（link）。为了将一个数据报从源主机传输到目的主机，数据报必须通过沿端到端路径上的各段链路传输。包括：有线链路、无线链路和 LANs；</p></li></ul><ul id="7963cf71-2f27-4436-96db-9e952dbd1e41" class="bulleted-list"><li>链路层帧<p id="beb17916-4228-4be3-bead-9af9dbd50e8e" class="">在通过特定的链路时，传输结点将上层递交的网络层数据报封装在链路层帧（frame）中，并将该帧传送到链路中；</p></li></ul></details></li></ul><ul id="0c9850f4-a99f-46f8-a739-b4c9eceb228e" class="toggle"><li><details open=""><summary>链路层能够提供的服务</summary><p id="fc7d2aee-80fa-4c15-aefb-93943c5b61c3" class="">任一链路层的基本服务都是将数据报通过单一通信链路从一个结点移动到相邻结点，但所提供的服务细节能够随着链路层协议的不同而变化。链路层协议能够提供的可能服务包括：</p><ul id="7038bc2e-0c1e-4931-b571-c859f6f5d83d" class="toggle"><li><details open=""><summary>成帧（framing）</summary><p id="4c73da3e-8cb1-41aa-9d71-2405bbbc09a1" class="">一个帧由一个尾部字段和若干首部字段组成，帧的结构由链路层协议规定。</p></details></li></ul><ul id="66765507-57a4-4e66-ae6c-c993e450484b" class="toggle"><li><details open=""><summary>链路接入</summary><p id="0f20977f-3c0a-47c1-933b-95117de879ed" class="">媒体访问控制（Medium Access Control，MAC）协议规定了帧在链路上传输的规则。MAC 协议用于协调多个结点的帧传输，即所谓多路访问问题。使用不同于 IP 地址的 MAC 地址标记源/目的。</p></details></li></ul><ul id="1ac48b3e-d561-48e6-bfae-1d4e744ae670" class="toggle"><li><details open=""><summary>可靠交付</summary><p id="7c787fe0-8d36-4725-a2db-ac8f80340e8f" class="">当链路层协议提供可靠交付服务时，它保证无差错地经链路层移动每个网络层数据报（节点到节点），TCP 是保证端系统到端系统的可靠传输。与运输层可靠交付服务类似，链路层的可靠交付服务通常是通过确认和重传取 得的。<mark class="highlight-red">链路层可靠交付服务通常用于易于产生高差错率的链路，例如无线链路</mark>，其目的是本地（也就是在差错发生的链路上）纠正一个差错，而不是通过运输层或应用层协议迫使进行端到端的数据重传。然而，对于低比特差错的链路，包括光纤、同轴电缆和许多双绞铜线链路，链路层可靠交付可能会被认为是一种不必要的开销。由于这个原因，许多有线的链路层协议不提供可靠交付服务。</p></details></li></ul><ul id="6ca83799-692e-494e-9e50-59937a8b3716" class="toggle"><li><details open=""><summary>差错检测和纠正</summary><p id="5c509fc1-3a27-41d8-ad1a-5870a1470bc8" class="">链路层的差错检测通常复杂，并且用硬件实现， 接收方不仅能检测帧中出现的比特差错，而且能够准确地确定帧中的差错出现的位置（并因此纠正这些差错）。</p></details></li></ul></details></li></ul></details></li></ul><ul id="63eba1ef-07c9-41c0-a520-56e6f71dfeef" class="toggle"><li><details open=""><summary>链路层的实现</summary><figure id="59db896d-99e9-45ab-942e-9f4a08b73b29" class="image"><a href="Untitled%209bced2821b994f2db3e95b2bed227474/image70.jpeg"><img style="width:406px" src="Untitled%209bced2821b994f2db3e95b2bed227474/image70.jpeg"/></a></figure><p id="57f22b8f-d265-4793-b60a-62243216344b" class="">链路层的主体部分是在 网络适配器（ networkadapter）中实现的，网络适配器有时也称为网络接口卡（Network Interface Card，NIC）。位于网络适配器核心的是链路层控制器，该控制器通常是一个实现了许多链路层服务（成帧、链路接入、差错检测等）的专用芯片。</p></details></li></ul><h1 id="96060a93-7f47-4669-ba1b-d33209b91bc1" class="">二、差错校验（同计算机组成原理）</h1><p id="b7f54643-5dc0-48a3-a851-c2b16f091d4c" class="">现今的计算机网络中广泛应用的差错检测技术基于循环冗余检测（Cyclic Redundancy Check，CRC）编码。CRC 编码也称为多项式编码（polynomial code），因为该编码能够将要发送的比特串看作为系数是 0 和 1 一个多项式，对比特串的操作被解释为多项式算术。</p><ul id="bd654d96-2093-4de5-8b15-d7dcdaf3e1e5" class="toggle"><li><details open=""><summary>组成</summary><ul id="d2981d31-f166-4d21-af8b-c062900e82f7" class="bulleted-list"><li>待<strong>发送数据 D</strong>，长度为 d 比特；</li></ul><ul id="75f32f7c-2a4a-4358-b577-a074d7e438e4" class="bulleted-list"><li>发送方和接收方约定<strong>生成多项式 G</strong>，长度为𝑟 + 1比特，要求 G 的最高有效位的比特（最左边）是 1；<figure id="7dfc5168-6afa-45aa-94c6-0595e97a1e0e" class="image"><a href="Untitled%209bced2821b994f2db3e95b2bed227474/image71.jpeg"><img style="width:421px" src="Untitled%209bced2821b994f2db3e95b2bed227474/image71.jpeg"/></a></figure></li></ul><ul id="ddfb5530-ad4f-4135-980d-d5eda799ceb5" class="bulleted-list"><li><strong>CRC 比特 R</strong>，长度为 r 比特；</li></ul></details></li></ul><ul id="576f6f6c-cfa2-40aa-bfc5-ffae7c9bc426" class="toggle"><li><details open=""><summary>计算</summary><p id="cb00b635-c022-4520-895c-11349cbf38d6" class="">根据长度为𝑟 + 1比特的生成多项式 G，转化成𝑟 + 1位的二进制数。将待发数据 D 左移 r 位后得到 D’（即𝐷’ = 𝐷 × <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>𝑟</mi></msup></mrow><annotation encoding="application/x-tex">2^𝑟</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span>），用生成多项式 G 去除以 D’，得到的余数为 R。最终的结果为𝐷 + 𝑅。<div class="indented"><figure id="433ba345-d79e-44dc-b609-baf8f3fc5cc2" class="image"><a href="Untitled%209bced2821b994f2db3e95b2bed227474/image72.png"><img style="width:192px" src="Untitled%209bced2821b994f2db3e95b2bed227474/image72.png"/></a></figure></div></p><p id="fce600e5-bc0d-495e-afa8-77e975c7cd84" class=""><style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo>=</mo><mn>101110</mn><mtext>，</mtext></mrow><annotation encoding="application/x-tex">D= 101110，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mord cjk_fallback">，</span></span></span></span></span><span>﻿</span></span><style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐺</mi><mo stretchy="false">(</mo><mi>𝑋</mi><mo stretchy="false">)</mo><mo>=</mo></mrow><annotation encoding="application/x-tex">𝐺(𝑋) = </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">G</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span></span></span></span><span>﻿</span></span><style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>𝑋</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">𝑋^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span><style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex"> + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mord">1</span></span></span></span></span><span>﻿</span></span>， 求 CRC则最终结果为，<mark class="highlight-yellow">101110</mark> <mark class="highlight-teal">1000</mark>，把源数据 D 的尾部封装链路层尾帧 R 1000，进行数据校验和纠错。<div class="indented"><figure id="016ebf55-7b7a-42d5-9f14-4db639ff17ca" class="image"><a href="Untitled%209bced2821b994f2db3e95b2bed227474/image73.jpeg"><img style="width:432px" src="Untitled%209bced2821b994f2db3e95b2bed227474/image73.jpeg"/></a></figure></div></p></details></li></ul><h1 id="e3cd3a29-bd29-49f5-90df-0a4b2572ffb7" class="">三、多路访问链路和协议</h1><ul id="b2e01403-2a66-45be-9ccb-7949f8344872" class="toggle"><li><details open=""><summary>概述</summary><ul id="c04b9687-c6ba-4b47-8391-c49037dce6ab" class="toggle"><li><details open=""><summary>网络链路类型</summary><ul id="63698f92-ecb1-4f58-b284-48efd8296172" class="bulleted-list"><li>点对点链路<p id="e8a6852c-a0b8-4757-b1fa-9faf84ff3531" class="">点对点链路（point-to-point link）由链路一端的单个发送方和链路另一端的单个接收方组成。</p></li></ul><ul id="7fb41ccb-ab46-4c88-8e1e-da0f49846810" class="bulleted-list"><li>广播链路<p id="4284a09f-b53d-4135-b56d-a174d04c83ae" class="">广播链路（broadcast link），它能够让多个发送和接收结点都连接到相同的、单一的、共享的广播信道上。当任何一个结点传输一个帧时，信道广播该帧，每个其他结点都收到一个副本。</p></li></ul></details></li></ul><ul id="d543d578-17e3-47eb-908f-4e7c639d491d" class="toggle"><li><details open=""><summary>多路访问协议（multiple access protocol）</summary><p id="6a0fb837-dd8a-44d7-bd82-d59e0e975846" class="">在广播链路中的节点，通过多路访问协议来规范它们在共享的广播信道上的传输行为。在实践中，数以千计个结点能够通过一个广播信道直接通信。</p><ul id="a8c5384a-06d9-4aee-8880-247803096cca" class="toggle"><li><details open=""><summary>碰撞/冲突</summary><p id="be054b06-5ac8-4596-8824-d8fab6ed4544" class="">因为所有的结点都能够传输帧，所以多个结点可能会同时传输帧。此时，每个接收方收到了两个及以上的帧，即碰撞（collide）。通常，当碰撞发生时，没有一个接收结点能够有效地获得任何传输的帧。因此，涉及此次碰撞的所有帧都丢失了，在碰撞时间间隔中的广播信道被浪费了。显然，如果许多结点要频繁地传输帧，许多传输将导致碰撞，广播信道的大量带宽将被浪费掉。</p></details></li></ul><ul id="449ee94f-96ed-4fda-844c-e8987271877e" class="toggle"><li><details open=""><summary>职责</summary><p id="80c5ead9-7701-4346-a7bd-61521726ac85" class="">因此，多路访问协议是一个分布式的算法，计算得出每个节点应该何时发送数据可以有效避免冲突。另外，通过多路复用的信道进行多路数据传输时，必须由信道本身进行控制，没有在外控制的节点进行统一协调。</p></details></li></ul><ul id="6fc7af6c-af07-44fc-b228-1ba6bb56f8e4" class="toggle"><li><details open=""><summary>理想的多路访问协议</summary><p id="bcb8ce84-ac66-4331-ab12-3072f0520e1f" class="">在理想情况下，对于速率为 R bps 的广播信道，多路访问协议应该具有以下所希望的特性：</p><ol id="a0b5da4c-b03a-45fd-a651-43168892660b" class="numbered-list" start="1"><li>当仅有一个结点有数据发送时，该结点具有 R bps 的吞吐量；</li></ol><ol id="a219aedc-c7ab-4072-88a4-7b670763eeea" class="numbered-list" start="2"><li>当有 M 个结点要发送数据时，每个结点吞吐量为 R/M bps。这不必要求 M 结点中的每一个结点总是有 R/M 的瞬间速率，而是每个结点在一些适当定义的时间间隔内应该有 R/M 的平均传输速率。</li></ol><ol id="9dca3699-722a-4a88-926b-592af295a5a7" class="numbered-list" start="3"><li>协议是分散的；这就是说不会因某主结点故障而使整个系统崩溃。</li></ol><ol id="f30c1196-a8b4-490e-bc8c-428f6343cbeb" class="numbered-list" start="4"><li>协议是简单的，使实现不昂贵。</li></ol></details></li></ul></details></li></ul></details></li></ul><ul id="ab55bbb1-ffcb-476a-a9d6-715bc970ba6c" class="toggle"><li><details open=""><summary>信道划分协议：高负载效率高</summary><ul id="d65af6a5-59a2-4dc9-97c1-01a4d38690c5" class="toggle"><li><details open=""><summary>时分多路复用 TDM</summary><p id="06aa89e2-126e-45df-bfad-31f89169a2e6" class="">TDM 将时间划分为时间帧（time frame），并进一步划分每个时间帧为 N 个时隙（slot）。然后把每个时隙分配给 N 个结点中的一个。无论何时某个结点在有分组要发送的时候，它在循环的 TDM 帧中指派给它的时隙内传输分组比特。通常，选择的时隙长度应使一个时隙内能够传输单个分组。</p><figure id="9a9f7d4f-9a8a-4c20-8e09-26e36d4296e5" class="image"><a href="Untitled%209bced2821b994f2db3e95b2bed227474/image74.jpeg"><img style="width:700px" src="Untitled%209bced2821b994f2db3e95b2bed227474/image74.jpeg"/></a></figure><p id="89161223-9231-4dfa-9aff-6e4a557ef148" class="">根据 TDM 协议，先确定时间帧 frame，然后根据线路中要通信的节点数量 N将时间帧 frame 均分为 N 份，每个节点在固定时刻可以得到一个时隙的时间独占带宽发送分组。如果该节点的时隙内没有分组要发送，则时间被浪费。</p></details></li></ul><ul id="7c99588a-b84f-46ba-b976-cd1121ce4132" class="toggle"><li><details open=""><summary>频分多路复用 FDM</summary><p id="451f351c-9edc-413f-a4ca-9e3fdfc7b6f0" class="">FDM 将 R bps 信道划分为不同的频段（每个频段具有 R/N 带宽），并把每个频率分配给 N 个结点中的一个。因此 FDM 在单个较大的 R bps 信道中创建了 N个较小的 R/N bps 信道。FDM 在 N 个结点之间公平地划分了带宽，但是，限制一个结点只能使用 R/N的带宽，即使当它是唯一一个有分组要发送的结点时。</p><figure id="e93a782c-a54a-4449-9612-1382508ea7fb" class="image"><a href="Untitled%209bced2821b994f2db3e95b2bed227474/image75.jpeg"><img style="width:700px" src="Untitled%209bced2821b994f2db3e95b2bed227474/image75.jpeg"/></a></figure></details></li></ul><ul id="b4d8cf1d-2801-40e8-b871-8e0c4c368665" class="toggle"><li><details open=""><summary>码分多址（Code Division Multiple Access，CDMA）</summary><p id="25469ca4-f652-4b90-8e40-625b2ddf379e" class="">TDM 和 FDM 分别为结点分配时隙和频率，而 CDMA 对每个结点<mark class="highlight-teal">分配一种不同的编码</mark>。然后每个结点用它唯一的编码来对它发送的数据进行编码。如果精心选择这些编码，不同的结点能够同时传输，并且它们各自相应的接收方仍能正确接收发送方编码的数据比特（假设接收方知道发送方的编码），而不在乎其他结点的干扰传输。广泛地用于民用，尤其是蜂窝电话中。</p></details></li></ul></details></li></ul><ul id="3d22b8e0-9e02-437c-9134-0963194740a5" class="toggle"><li><details open=""><summary>随机接入协议：轻负载效率高</summary><ul id="1b668bcd-b112-4185-a10c-db986e1317c5" class="toggle"><li><details open=""><summary>基本定义</summary><p id="d89c7fb1-a2c7-41c4-9ee2-eeca6f95323b" class="">在随机接入协议中，一个传输结点总是以信道的全部速率（即 R bps）进行发送。当有碰撞时，涉及碰撞的每个结点反复地重发它的帧（也就是分组），到该帧无碰撞地通过为止。但是当一个结点经历一次碰撞时，它不必立刻重发该帧。</p><p id="93fd0621-9fd3-4a46-9570-c7115623c8b2" class="">相反，它在重发该帧之前等待一个随机时延。涉及碰撞的每个结点独立地选择随机时延。因为该随机时延是独立地选择的，这些结点之一所选择的时延充分小于其他碰撞结点的时延，并因此能够无碰撞地将它的帧在信道中发出，即因为每个节点时延选择的随机性，使重发的帧在时间上错开。</p></details></li></ul><ul id="a95f2e54-f350-4589-90bd-b04ea4e20f16" class="toggle"><li><details open=""><summary>纯 ALOHA</summary><ul id="45556ac3-e874-4600-9bf2-40865a32c23c" class="toggle"><li><details open=""><summary>定义</summary><p id="4a06f387-1ba6-45c8-ab1f-9eb9b0585728" class="">在纯 ALOHA 中，当一帧首次到达（即一个网络层数据报在发送结点从网络层传递下来），结点立刻将该帧完整地传输进广播信道：</p><ul id="6978ebfc-5860-4ceb-8ed1-883ae92c230e" class="bulleted-list"><li>如果一个传输的帧与一个或多个传输帧经历了碰撞，这个结点将在完全传输完被碰撞帧之后，以概率 p 立即重传该帧；</li></ul><ul id="70f71372-74ac-4242-b416-5981358c4413" class="bulleted-list"><li>否则，该结点等待一个帧传输时间。在此等待之后，它则以概率 p 传输该帧，或者以概率 1-p 等待。</li></ul></details></li></ul><ul id="62315441-19df-44d4-9a95-ee777b7b634c" class="toggle"><li><details open=""><summary>传输效率推演</summary><figure id="99001bd0-ff0a-4ac6-81a2-443807045f68" class="image"><a href="Untitled%209bced2821b994f2db3e95b2bed227474/image76.jpeg"><img style="width:700px" src="Untitled%209bced2821b994f2db3e95b2bed227474/image76.jpeg"/></a></figure><p id="b16e8dbf-829b-41f9-bf2a-89c7be34fabe" class="">假设该帧在时刻 t0 开始传输。如上图所示，为了使这帧能成功地传输，在时间间隔[t0-1，t0]中不能有其他结点开始传输。这种传输将与结点𝑖的帧传输起始部分相重叠。所有其他结点在这个时间间隔不开始传输的概率是<style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mtext>−</mtext><mi>p</mi><msup><mo stretchy="false">)</mo><mrow><mi>𝑁</mi><mtext>−</mtext><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">(1 − p)^{𝑁−1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">−</span><span class="mord mathdefault">p</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span>。类似地，当结点𝑖在传输时，其他结点不能开始传输，因为这种传输将与结点𝑖传输的后面部分相重叠。所有其他结点在这个时间间隔不开始传输的概率也是<style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mtext>−</mtext><mi>p</mi><msup><mo stretchy="false">)</mo><mrow><mi>𝑁</mi><mtext>−</mtext><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">(1 − p)^{𝑁−1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">−</span><span class="mord mathdefault">p</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span>。因此，一个给定的结点成功传输一次的概率是<style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑝</mi><mo>×</mo><mo stretchy="false">(</mo><mn>1</mn><mtext>−</mtext><mi>p</mi><msup><mo stretchy="false">)</mo><mrow><mi>𝑁</mi><mtext>−</mtext><mn>1</mn></mrow></msup><mo>×</mo><mo stretchy="false">(</mo><mn>1</mn><mtext>−</mtext><mi>p</mi><msup><mo stretchy="false">)</mo><mrow><mi>𝑁</mi><mtext>−</mtext><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">𝑝 × (1 − p)^{𝑁−1} × (1 − p)^{𝑁−1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">−</span><span class="mord mathdefault">p</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">−</span><span class="mord mathdefault">p</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span>。对𝑁 → ∞取极限，求得纯 ALOHA 协议的最大效率仅为1/2𝑒，即 18%。</p></details></li></ul></details></li></ul><ul id="9925aa1e-cb29-4169-a4e4-12c2ec6c2380" class="toggle"><li><details open=""><summary>时隙 ALOHA</summary><ul id="aebdda0f-a395-4cbb-a247-3605f034bfe5" class="toggle"><li><details open=""><summary>假设</summary><ul id="16797246-96c7-45fc-af73-00882d2da169" class="bulleted-list"><li>所有帧由 L 比特组成；</li></ul><ul id="9e3b8e5e-9188-43eb-a58c-913b23144d20" class="bulleted-list"><li>时间被划分成长度为 L/R 秒的时隙（这就是说，一个时隙等于传输一帧的时间）；</li></ul><ul id="dc821d42-c479-489a-9d0f-f5579958a5f2" class="bulleted-list"><li><strong>结点只在时隙起点开始传输帧；</strong></li></ul><ul id="3e916d53-4f71-4ecc-ba7e-c7b599801ebc" class="bulleted-list"><li>结点是同步的，每个结点都知道时隙何时开始；</li></ul><ul id="5cb92de1-bd75-4855-acb9-b345948764d8" class="bulleted-list"><li>如果在一个时隙中有两个或者更多个帧碰撞，则所有结点在该时隙结束之前检测到该碰撞事件；</li></ul></details></li></ul><ul id="71abcb97-0265-4280-b1f4-d8fcbed66f3f" class="toggle"><li><details open=""><summary>流程</summary><ul id="42f7432e-6024-4d1d-9a8f-fd991f03ccba" class="bulleted-list"><li>当结点有一个新帧要发送时，它等到下一个时隙开始并在该时隙传输整个帧。</li></ul><ul id="d404a410-fdc3-4cf9-a2fc-a9164fe37629" class="bulleted-list"><li>如果没有碰撞，该结点成功地传输它的帧，从而不需要考虑重传该帧。</li></ul><ul id="eaf8aa60-9571-477b-a9bc-611e18470974" class="bulleted-list"><li>如果有碰撞，该结点在时隙结束之前检测到这次碰撞。该结点以概率𝑝在后续的每个时隙中重传它的帧，直到该帧被无碰撞地传输出去。</li></ul><figure id="b3a834b2-c3f1-426b-9c33-b468405e2618" class="image"><a href="Untitled%209bced2821b994f2db3e95b2bed227474/image77.jpeg"><img style="width:700px" src="Untitled%209bced2821b994f2db3e95b2bed227474/image77.jpeg"/></a></figure><p id="8316186a-1dea-4af4-997e-9677d162e7ac" class="">如上图中，结点 1、2 和 3 在第一个时隙碰撞。结点 2 最终在第 4 个时隙成功，结点 1 在第 8 个时隙成功，结点 3 在第 9 个时隙成功。</p><ul id="92ca334e-eaf9-454e-a554-6597da39b34a" class="bulleted-list"><li>C=碰撞时隙</li></ul><ul id="3d2a9953-1911-43fe-bf09-478c79885803" class="bulleted-list"><li>E=空闲时隙</li></ul><ul id="24e3426a-1ba4-435a-be3d-7acc18938bf4" class="bulleted-list"><li>S=成功时隙</li></ul></details></li></ul><ul id="e9fe992e-02eb-4b62-b6df-71254dbab3c4" class="toggle"><li><details open=""><summary>传输效率推演</summary><p id="a26d72b2-25a0-40cd-959c-8f76c62c5b49" class="">因此，一个给定结点成功传送的概率是<style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑝</mi><mo>×</mo><mo stretchy="false">(</mo><mn>1</mn><mtext>−</mtext><mi>p</mi><msup><mo stretchy="false">)</mo><mrow><mi>𝑁</mi><mtext>−</mtext><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">𝑝 × (1 − p)^{𝑁−1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">−</span><span class="mord mathdefault">p</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span>，因为有 N 个结点， 任意一个结点成功传送的概率是<style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑁</mi><mo>×</mo><mi>𝑝</mi><mo>×</mo><mo stretchy="false">(</mo><mn>1</mn><mtext>−</mtext><mi>p</mi><msup><mo stretchy="false">)</mo><mrow><mi>𝑁</mi><mtext>−</mtext><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">𝑁 × 𝑝 × (1 − p)^{𝑁−1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">−</span><span class="mord mathdefault">p</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span>。对𝑁 → ∞取极限，求得时隙ALOHA 协议的最大效率为<style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mi>𝑒</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac1𝑒</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">e</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span><span>﻿</span></span>，即 37%。</p></details></li></ul></details></li></ul><ul id="00778800-575d-4288-aaee-97cf22a8ac3c" class="toggle"><li><details open=""><summary>载波侦听多路访问（CSMA）</summary><ul id="4bb81e87-5cb6-4dbe-906d-81cede8b5dd2" class="bulleted-list"><li><strong>工作原理</strong><ul id="351c97bf-1b26-4f43-a423-7fcf51d6ff3a" class="bulleted-list"><li><strong>说话之前先听——载波监听多路访问 CSMA</strong><p id="6ef6ca79-4ace-437f-9a3e-40611e25fd9b" class="">如果其他人正在说话，等到他们说完话为止。在网络领域中，这被称为<strong>载波侦听（carrier sensing）</strong>，即一个结点在传输前先听信道。如果来自另一个结点的帧正向信道上发送，结点则等待直到检测到一小段时间没有传输，然后开始传输。</p></li></ul><ul id="2946be65-a0ac-4bc2-b925-f6f9baffe46d" class="bulleted-list"><li>如果与他人同时开始说话，停止说话——具有碰撞检测的 CSMA<p id="2819d9ed-14df-4854-9918-de295c80734b" class="">在网络领域中，这被称为碰撞检测（collision detection），即当一个传输结点在传输时一直在侦听此信道。如果它检测到另一个结点正在传输干扰帧，它就停止传输，在重复“侦听-当空闲时传输”循环之前等待一段随机时间。</p></li></ul></li></ul></details></li></ul><ul id="e29745ba-1d88-4d78-9e19-66cc222c9c2b" class="toggle"><li><details open=""><summary>CSMA 为什么不完善</summary><ul id="277b801d-a53e-4cbe-8e45-d464d8250a63" class="toggle"><li><details open=""><summary><strong>引出</strong></summary><p id="2ad286ef-8f1e-4866-ac69-eddd23f2c787" class="">每个节点在开始传输之前都会监听信道，只有信道空闲才会进行传输，为什么 CSMA 还会发生碰撞。</p></details></li></ul><ul id="95ec7b34-3510-4f60-8da3-21bfc847c682" class="toggle"><li><details open=""><summary>原因</summary><figure id="34a096cd-c05c-4972-bb42-680f9d906916" class="image"><a href="Untitled%209bced2821b994f2db3e95b2bed227474/image79.png"><img style="width:384px" src="Untitled%209bced2821b994f2db3e95b2bed227474/image79.png"/></a></figure><p id="9a25a790-c996-4bbd-9398-93d16c37fb99" class="">右图显示连接到一个线状广播总线的 4 个结点（A、B、C、D）的时空图。横轴表示每个结点在空间的位置；纵轴表示时间。</p><p id="fc982659-6dcf-4778-a89e-fd55d3602eb3" class="">在时刻 t0，结点 B 侦听到信道是空闲的，因为当前没有其他结点在传输。因此结点 B 开始传输， 沿着广播媒体在两个方向上传播它的比特。右图中 B 的比特随着时间的增加向下传播，这表明 B 的比特沿着传输介质传输所实际需要的时间趋近于零但不是零。在时刻 t1（ t1&gt; t0），结点 D 有一个帧要发送。<mark class="highlight-teal">尽管结点 B 在时刻 t1，正在传输，但 B 传输的比特还没有到达 D，因此 D 在 t1 侦听到信道空闲。</mark>根据 CSMA 协议，从而 D 开始传输它的帧。一个短暂的时间之后，B 的传输开始和 D 冲突，干扰 D 的传输。</p></details></li></ul><ul id="d98b73dd-13df-4a88-83d2-dcf808dca182" class="toggle"><li><details open=""><summary>总结</summary><p id="62d64ad1-ffc5-4ab7-a60e-0bc2226080b5" class="">传输介质的传输时延导致了载波监听节点监听网络传输的延迟。</p></details></li></ul></details></li></ul><ul id="776aefcf-cf20-411f-a4c3-debe2ca16e78" class="toggle"><li><details open=""><summary>具有碰撞检测的载波侦听多路访问（CSMA/CD）</summary><ul id="50bfd660-5e5e-4c38-a29d-91a2fca2a299" class="toggle"><li><details open=""><summary>工作原理</summary><figure id="09efeadf-d00d-4601-8f26-6cebe145bd6c" class="image"><a href="Untitled%209bced2821b994f2db3e95b2bed227474/image80.png"><img style="width:384px" src="Untitled%209bced2821b994f2db3e95b2bed227474/image80.png"/></a></figure><p id="c8fd7fd0-b57e-437e-9bdd-ea68c1150799" class="">当某结点执行碰撞检测时，一旦它检测到碰撞将立即停止传输。如图所示，结点 B、D 在检测到碰撞后很短的时间内都放弃了它门的传输。注意，只有当其他结点的帧在空间上传输到本结点，才是发挥碰撞检测的时候，因此还是有通信介质传输时延的问题。在多路访问协议中加入碰撞检测，通过不传输一个无用的、已经损坏的帧，改善协议的性能。</p></details></li></ul><ul id="36ed6bf9-95f1-4561-8a3d-17b8f955b28d" class="toggle"><li><details open=""><summary>应用</summary><p id="1d568f7a-9639-452b-b7f9-c830f61c0508" class="">在有线局域网中很容易实现，通过监听信道中的信号强度即可，但是在无线局域网中是困难的，因此 CSMA/CD 多应用于有线网，无线网中是具有碰撞避免的载波侦听多路访问 CSMA/CA</p></details></li></ul></details></li></ul><ul id="020e7832-f162-4012-9407-5e903fc6d42a" class="toggle"><li><details open=""><summary>以太网中 CSMA/CD 算法的实现过程</summary><ul id="e3710c29-1a04-4a8d-9b2b-72c0020ddf8d" class="toggle"><li><details open=""><summary>具体过程</summary><ol id="5cdd6daf-e898-46a6-9d60-c1928c0e8444" class="numbered-list" start="1"><li>适配器从网络层一条获得数据报，准备链路层帧，并将其放入帧适配器缓存中；</li></ol><ol id="f16348b2-d76a-4836-900d-49ae23e78ed5" class="numbered-list" start="2"><li>如果适配器侦听到信道空闲（即无信号能量从信道进入适配器），它开始传输帧。在另一方面，如果适配器侦听到信道正在忙，它将等待，直到侦听到没有信号能量时才开始传输帧；</li></ol><ol id="fab51f62-8a19-44a1-9b76-42156e535e3d" class="numbered-list" start="3"><li>在传输过程中，适配器监视来自其他使用该广播信道的适配器的信号能量是否存在；</li></ol><ol id="3d47d9c6-d491-412a-9ce0-15c6d0a5e1fe" class="numbered-list" start="4"><li>如果适配器传输整个帧而未检测到来自其他适配器的信号能量，该适配器就完成了该帧。在另一方面，如果适配器在传输时检测到来自其他适配器的信号能量，它中止传输（即它停止了传输帧）。</li></ol><ol id="402d5a6e-460c-4168-bb4b-b017bc0385aa" class="numbered-list" start="5"><li>中止传输后，适配器等待一个<strong>随机时间量</strong>，然后返回步骤 2。<p id="191c0466-a92c-44a7-adb0-436be5900cff" class=""><strong>随机时间量的选择——二进制指数后退（binary exponential back off） 算法</strong><div class="indented"><ul id="db1f5008-ba26-46d3-a156-821607f72bec" class="bulleted-list"><li>总体思路：<p id="961f7d32-ee2e-4939-954b-49d603cb7750" class="">当碰撞结点数量较少（发生碰撞次数少）时，时间间隔较短；当碰撞结点数量较大（发生碰撞次数多）时，时间间隔较长。</p></li></ul><ul id="0004615b-8248-4956-b7e0-f72ba449bdd3" class="bulleted-list"><li>具体算法：<p id="3a3b1701-609b-4c86-ac98-377a6b717280" class="">当传输一个给定帧时，在该帧经历了一连串的 n 次（n&lt;10）碰撞后，结点随机地从{<style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msup><mn>2</mn><mi>n</mi></msup><mtext>−</mtext><mn>1</mn></mrow><annotation encoding="application/x-tex">{0,1,2,…,2^n−1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.858832em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mord">−</span><span class="mord">1</span></span></span></span></span></span><span>﻿</span></span>}中选择一个 K 值。因此，一个帧经历的碰撞越多，K 可能选择的值就越大。对于以太网，一个结点等待的实际时间量是𝐾 · 512比特时间（即发送 512 比特进入以太网所需时间量的 K 倍）。因为每个节点时延选择的随机性，使重发的帧在时间上错开。</p></li></ul></div></p></li></ol></details></li></ul></details></li></ul></details></li></ul><ul id="17370706-9bf7-4d59-ae70-5845262651db" class="toggle"><li><details open=""><summary>轮流协议</summary><ul id="ae9e9dd1-7d0d-418a-87a0-e7ae453a5be6" class="toggle"><li><details open=""><summary><strong>轮询协议（polling protocol）</strong></summary><ul id="3ceb4fa6-490c-4e12-825f-547a1076f0b8" class="toggle"><li><details open=""><summary><strong>协议内容</strong></summary><p id="ee5a8ce9-a429-4745-a1ca-70414aea88e9" class="">轮询协议要求这些结点之一要被指定为主结点。主结点以循环的方式轮询（poll）每个结点。主结点首先向结点 1 发送一个报文，告诉它（结点 1） 能够传输的帧的最多数量。在结点 1 传输了某些帧后，主结点告诉结点 2 它（结点 2）能够传输的帧的最多数量。结点能够通过观察在信道上是否缺乏信号，来决定一个结点何时完成了帧的发送。上述过程以这种方式循环运行， 主结点以循环的方式轮询了每个结点。</p></details></li></ul><ul id="5e79be52-bc73-4536-9319-91caa32358b7" class="toggle"><li><details open=""><summary>协议优点</summary><p id="ecec2ead-ef52-4fee-b9af-acf63e22da6a" class="">轮询协议消除了困扰随机接入协议的碰撞和空时隙，这使得轮询取得高得多的效率。</p></details></li></ul><ul id="56ceb24d-618b-4969-b19f-de5d2b4ea68c" class="toggle"><li><details open=""><summary>协议缺点</summary><ol id="91387d6d-77d2-4821-84c5-5deb14c21406" class="numbered-list" start="1"><li>该协议引入了轮询时延，即通知一个结点“它可以传输”所需的时间。例如，如果只有一个结点是活跃的，那么这个结点将以小于 R bps 的速率传输，因为每次活跃结点发送了它最多数量的帧时，主结点必须依次轮询每一个非活跃的结点；</li></ol><ol id="ec130d9e-90d5-4df8-9306-6dc6f04cde54" class="numbered-list" start="2"><li>如果主结点有故障，整个信道都变得不可操作。</li></ol></details></li></ul></details></li></ul><ul id="8bccf6c3-3c46-4fa3-b938-abbd005caf8b" class="toggle"><li><details open=""><summary>令牌传递协议（token-passing protocol）</summary><ul id="75a370fe-e71a-4330-9fec-630c0a29366f" class="bulleted-list"><li><strong>协议内容</strong><p id="aa3ed435-1903-4ad0-98e2-4c612a944c75" class="">在这种协议中没有主结点。一个称为令牌（token）的小的特殊帧在结点之间以某种固定的次序进行交换。例如，结点 1 可能总是把令牌发送给结点 2，结点 2 可能总是把令牌发送给结点 3，而结点 N 可能总是把令牌发送给结点 1。当一个结点收到令牌时，仅当它有一些帧要发送时，它才持有这个令牌；否则，它立即向下一个结点转发该令牌。当一个结点收到令牌时，如果它确实有帧要传输，它发送最大数目的帧数， 然后把令牌转发给下一个结点。</p></li></ul><ul id="011521b0-675b-4dd1-97f0-ebe02e22b37c" class="bulleted-list"><li>协议缺点<p id="30e2349e-c2bb-4574-88fd-8db2f83c5fda" class="">例如，一个结点的故障可能会使整个信道崩溃。或者如果一个结点偶然忘记了释放令牌，则必须调用某些恢复步骤使令牌返回到循环中来。</p></li></ul></details></li></ul></details></li></ul><h1 id="ca9af906-b5c1-40b1-9cd2-6d08bd4994c2" class="">四、交换局域网 LAs</h1><ul id="39ae63f3-ee94-489c-ad6c-8c6fcd8ec9b6" class="toggle"><li><details open=""><summary>MAC 和 ARP</summary><p id="953696ad-1e39-4da7-8adf-1c6d80628a57" class="">4.4.4 使用子网掩码的分组路由转发过程（重点 有原题）</p></details></li></ul><ul id="e7ae4c7b-92c7-46b7-9f51-bcc5ab0d86bb" class="toggle"><li><details open=""><summary>以太网的帧结构</summary><figure id="4f646b75-97c3-4544-8547-910c97cc1e7e" class="image"><a href="Untitled%209bced2821b994f2db3e95b2bed227474/image81.jpeg"><img style="width:543px" src="Untitled%209bced2821b994f2db3e95b2bed227474/image81.jpeg"/></a></figure><ul id="5017f9c4-9714-4f0c-a3d2-ab9d1e2731d3" class="toggle"><li><details open=""><summary><strong>前同步码（8 字节）</strong></summary><p id="267435b3-d6b6-48c5-9453-39b5e35af44d" class="">以太网帧以一个 8 字节的前同步码（Preamble）字段开始，且。该前同步码的前 7 字节的值都是 10101010；最后一个字节是 10101011。</p><p id="34fd1765-c992-4b83-9862-20ae732173a5" class="">前同步码字段的前 7 字节用于“唤醒”接收适配器，并且将它们的时钟和发送方的时钟同步。第 8 个字节的最后两个比特（第一个出现的两个连续的1）警告适配器 B，“重要的内容”就要到来了。</p></details></li></ul><ul id="d98f56b1-9c3e-438f-84e9-30457252fba1" class="toggle"><li><details open=""><summary>类型字段（2 字节）</summary><p id="4c355750-111a-429f-9d75-62b1f403722a" class="">明确应该将该帧递交给哪个网络层协议。</p><p id="99fb8454-e930-4ceb-aa5d-a81e03ca7f7b" class="">该类型字段和网络层数据报中的协议字段、运输层报文段的端口号字段相类似，所有这些字段都是为了把一层中的某协议与上一层的某协议结合起来。</p></details></li></ul><ul id="4c609bc7-fada-449a-ae9f-ab4cc8b4c6d2" class="toggle"><li><details open=""><summary>数据字段（46~1500 字节）</summary><p id="2203723c-c393-4ec2-a423-31a505a12006" class="">这个字段承载了 IP 数据报。以太网的最大传输单元（MTU）是 1500 字节。这意味着：</p><p id="fb369ad8-0812-4839-9d14-87898a024c71" class="">如果 IP 数据报超过了 1500 字节，则主机必须将该数据报分片；</p><p id="fce70a84-e564-468f-a68d-a48708ef10ad" class="">数据字段的最小长度是 46 字节。这意味着如果 IP 数据报小于 46 字节， 数据报必须被填充到 46 字节。</p></details></li></ul><ul id="07a60376-9c4a-447e-b0fe-dcaf6942cc7c" class="toggle"><li><details open=""><summary>目的地址（6 字节）</summary><p id="e9e3e16b-6704-44dc-9921-81e5b6795458" class="">这个字段包含目的适配器的 MAC 地址。适配器只将目的 MAC 为本机MAC 或者为广播 MAC 的数据报递交给网络层，其余的全部丢弃。</p></details></li></ul><ul id="fd5748b8-95c4-44f4-bd92-0314dbaa6852" class="toggle"><li><details open=""><summary>源地址（6 字节）</summary><p id="d4ba6867-c55a-4cf2-bae3-fb68d793a37f" class="">这个字段包含了传输该帧到局域网上的适配器的 MAC 地址。</p></details></li></ul></details></li></ul><ul id="f01812f1-5fe0-4d17-9b51-5e7f1f486f82" class="toggle"><li><details open=""><summary>链路层 交换机</summary><ul id="0478b80e-71de-482f-b90c-05b2cc467cb9" class="toggle"><li><details open=""><summary>功能</summary><ul id="5ca67809-a6b5-48d1-9573-7d8306752d6e" class="bulleted-list"><li>缓存<p id="8d810ac5-1a5a-48d4-92ef-8a470f96e921" class="">这些帧到达该交换机的任何输出接口之一的速率可能暂时会超过该接口的链路容量。为了解决这个问题，交换机输出接口设有缓存；</p></li></ul><ul id="f0f04456-7841-4e15-bd88-1731bab5a524" class="bulleted-list"><li>转发<p id="64223e20-9574-46bd-ac24-3bdbcc8ee141" class="">检查传入帧的 MAC 地址，在要在段上转发帧时选择性地将帧转发到一个或多个出站链接。当发出的目标网段是多路复用的，则使用 CSMA / CD 访问协议应对冲突。</p></li></ul><ul id="ce799760-f17c-49fb-94b8-c95233aea958" class="bulleted-list"><li>透明<p id="ee39ec57-fa08-48be-9046-7a972489b60a" class="">交换机对于路由器或者主机的寻址是透明的，它只连接同网段内的多台设备， 不能进行跨网段的转发。</p></li></ul><ul id="8001327c-9818-4f3c-b4e3-1d674377dcc5" class="bulleted-list"><li>即插即用/自学习</li></ul></details></li></ul><ul id="6731bb64-4ccb-4b5e-b057-c376ab730487" class="toggle"><li><details open=""><summary>自学习</summary><p id="de8f6734-7d0b-4b2d-9637-d3b9ee3cc9df" class="">交换机的表是自动、动态和自治地建立的，即没有来自网络管理员或来自配置协议的任何干预。换句话说，交换机是自学习（self-learning）的。这种能力是以如下方式实现的：</p><ol id="36b844b5-b68d-4771-b159-f64b6e1f371b" class="numbered-list" start="1"><li>交换机表初始为空。</li></ol><ol id="97f9d03a-ba6b-4c5f-a26d-143797e97a11" class="numbered-list" start="2"><li>对于在每个接口接收到的每个入帧，该交换机在其表中存储：<p id="d0afc244-5947-4637-873b-5471fab09da2" class="">①在该帧源地址字段中的 MAC 地址；</p><p id="9caa8ad2-0fe5-4f94-8990-1ed80449905b" class="">②该帧到达的接口；</p><p id="1ee3f5e7-857c-4f2c-9845-d7c21ec2ab71" class="">③当前时间。交换机以这种方式在它的表中记录了发送结点所在的局域网网段。如果在局域网上的每个结点最终都发送了一个帧，则每个结点最终将在这张表中留有记录。</p></li></ol><ol id="84052f1d-7158-480b-9c15-5a1b8cc94ac5" class="numbered-list" start="3"><li>如果在一段时间（称为老化期（aging time））后，交换机没有接收到以该地址作为源地址的帧，就在表中删除这个地址。因此，如果一台 PC 被移除，该 PC 的 MAC 地址将最终从该交换机表中被清除掉。</li></ol><p id="2227ced9-7b24-4f61-8c76-706018aaf477" class="">示例</p><p id="61fb7c17-49f7-46ef-a6e3-5700fb97a777" class="">假设在时刻 9:39，源地址为 01-12-23-34-45-56 的一个帧从接口 2 到达， 并且这个地址不在交换机表中，于是交换机在其表中增加一个新的表项。</p><figure id="01a9c26a-3d4b-4edd-9898-dce623e4bd88" class="image"><a href="Untitled%209bced2821b994f2db3e95b2bed227474/image82.jpeg"><img style="width:597px" src="Untitled%209bced2821b994f2db3e95b2bed227474/image82.jpeg"/></a></figure><p id="b40e15b2-7b42-4810-ba20-fb80caa6ade5" class="">假设该交换机的老化期是 60 分钟，在 9：32~10：32 期间源地址是 62-FE- F7-11-89-A3 的帧没有到达该交换机。那么在时刻 10：32，这台交换机将从它的表中删除该地址。</p></details></li></ul></details></li></ul></div></article></body></html>