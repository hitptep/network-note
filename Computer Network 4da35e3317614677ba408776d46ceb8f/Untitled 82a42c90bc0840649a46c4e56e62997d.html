<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>第四章 网络层</title><style>
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.highlight-default {
}
.highlight-gray {
	color: rgb(155,154,151);
}
.highlight-brown {
	color: rgb(100,71,58);
}
.highlight-orange {
	color: rgb(217,115,13);
}
.highlight-yellow {
	color: rgb(223,171,1);
}
.highlight-teal {
	color: rgb(15,123,108);
}
.highlight-blue {
	color: rgb(11,110,153);
}
.highlight-purple {
	color: rgb(105,64,165);
}
.highlight-pink {
	color: rgb(173,26,114);
}
.highlight-red {
	color: rgb(224,62,62);
}
.highlight-gray_background {
	background: rgb(235,236,237);
}
.highlight-brown_background {
	background: rgb(233,229,227);
}
.highlight-orange_background {
	background: rgb(250,235,221);
}
.highlight-yellow_background {
	background: rgb(251,243,219);
}
.highlight-teal_background {
	background: rgb(221,237,234);
}
.highlight-blue_background {
	background: rgb(221,235,241);
}
.highlight-purple_background {
	background: rgb(234,228,242);
}
.highlight-pink_background {
	background: rgb(244,223,235);
}
.highlight-red_background {
	background: rgb(251,228,228);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(55, 53, 47, 0.6);
	fill: rgba(55, 53, 47, 0.6);
}
.block-color-brown {
	color: rgb(100,71,58);
	fill: rgb(100,71,58);
}
.block-color-orange {
	color: rgb(217,115,13);
	fill: rgb(217,115,13);
}
.block-color-yellow {
	color: rgb(223,171,1);
	fill: rgb(223,171,1);
}
.block-color-teal {
	color: rgb(15,123,108);
	fill: rgb(15,123,108);
}
.block-color-blue {
	color: rgb(11,110,153);
	fill: rgb(11,110,153);
}
.block-color-purple {
	color: rgb(105,64,165);
	fill: rgb(105,64,165);
}
.block-color-pink {
	color: rgb(173,26,114);
	fill: rgb(173,26,114);
}
.block-color-red {
	color: rgb(224,62,62);
	fill: rgb(224,62,62);
}
.block-color-gray_background {
	background: rgb(235,236,237);
}
.block-color-brown_background {
	background: rgb(233,229,227);
}
.block-color-orange_background {
	background: rgb(250,235,221);
}
.block-color-yellow_background {
	background: rgb(251,243,219);
}
.block-color-teal_background {
	background: rgb(221,237,234);
}
.block-color-blue_background {
	background: rgb(221,235,241);
}
.block-color-purple_background {
	background: rgb(234,228,242);
}
.block-color-pink_background {
	background: rgb(244,223,235);
}
.block-color-red_background {
	background: rgb(251,228,228);
}
.select-value-color-default { background-color: rgba(206,205,202,0.5); }
.select-value-color-gray { background-color: rgba(155,154,151, 0.4); }
.select-value-color-brown { background-color: rgba(140,46,0,0.2); }
.select-value-color-orange { background-color: rgba(245,93,0,0.2); }
.select-value-color-yellow { background-color: rgba(233,168,0,0.2); }
.select-value-color-green { background-color: rgba(0,135,107,0.2); }
.select-value-color-blue { background-color: rgba(0,120,223,0.2); }
.select-value-color-purple { background-color: rgba(103,36,222,0.2); }
.select-value-color-pink { background-color: rgba(221,0,129,0.2); }
.select-value-color-red { background-color: rgba(255,0,26,0.2); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="82a42c90-bc08-4064-9a46-c4e56e62997d" class="page sans"><header><img class="page-cover-image" src="https://www.notion.so/images/page-cover/rijksmuseum_mignons_1660.jpg" style="object-position:center 50%"/><div class="page-header-icon page-header-icon-with-cover"><span class="icon">📌</span></div><h1 class="page-title">第四章 网络层</h1></header><div class="page-body"><h1 id="b6a9ed45-cc2a-4681-90e9-c06dae24496f" class="">一、概述</h1><ul id="f0cc5b47-ed9f-498b-94db-732e3f196b85" class="toggle"><li><details open=""><summary>网络层的功能</summary><ul id="f4292434-e5a5-46f8-ae35-e8ba7f6df92d" class="bulleted-list"><li>从发送方主机传输报文段到接收方主机；</li></ul><ul id="75d459df-5207-4c5b-988b-b4bfe85edc77" class="bulleted-list"><li>在发送方网络层，取得传输层报文段，将每个报文段封装成一个网络层数据报；</li></ul><ul id="4bf3d77e-f5b3-469a-bbf9-87a766a45461" class="bulleted-list"><li>在接收方网络层，提取出传输层报文段，向上递交给传输层；</li></ul><ul id="200d5658-4aa3-44ac-a45e-591d7dd2b7bb" class="bulleted-list"><li>网络层的协议存在于每个端系统主机和路由器；</li></ul><ul id="8766931e-d24a-4c00-821d-8311f6bff013" class="bulleted-list"><li>路由器对所有经过它的数据包<strong>都要检查头部信息而不检查数据信息</strong>，如果头部信息错误，则直接丢弃错误数据包；</li></ul></details></li></ul><ul id="f8664956-d713-49da-ac8d-18602eb160d8" class="toggle"><li><details open=""><summary>网络层的两个重要功能：转发和路由选择</summary><ul id="c69fcb39-39c6-481c-ba68-38f0dbed4622" class="toggle"><li><details open=""><summary>转发</summary><p id="dd837453-ceec-44ea-b7d2-f71a9397ef03" class="">当一个分组到达路由器的一条输入链路时，路由器必须将该分组移动到适当的输出链路。</p></details></li></ul><ul id="26907918-96c3-4800-b9a2-bcfa656c15a7" class="toggle"><li><details open=""><summary>路由选择</summary><p id="5819d5a4-258d-4612-83e4-60e571f9c9dd" class="">当分组从发送方流向接收方时，网络层必须决定这些分组所采用的路由或路径。计算这些路径的算法被称为路由选择算法（routing algorithm）。路由选择是指网络范围的过程，以决定分组从源到目的地所采取的端到端路径。</p></details></li></ul><ul id="6e65526c-a924-4555-984a-c9b1b5d5197e" class="toggle"><li><details open=""><summary>转发表</summary><p id="81db8592-1437-4863-8f4a-8c0dea665055" class="">每台路由器具有一张转发表（forwarding table）。路由器通过检查到达分组首部字段的值来转发分组，然后使用该值在该路由器的转发表中索引查询。存储在转发表项中的该首部的值指出了该分组将被转发的路由器的输出链路接口。分组首部中的该值可能是该分组的目的地址或该分组所属连接的指示，这取决于网络层协议。</p><figure id="fd9a386c-b63f-4417-97a5-6b88762f7c1a" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image1.png"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image1.png"/></a></figure></details></li></ul><ul id="4868bd33-3e19-444f-a4cb-9e90383f6d25" class="toggle"><li><details open=""><summary>连接建立</summary><ul id="e0a752c2-d828-45ff-8684-187e566a2268" class="bulleted-list"><li><strong>引入</strong><p id="adc865f2-a8e1-4717-bdd4-81ee6ef1ebd3" class="">在 TCP 通信建立时，当数据能从发送方流向接收方之前，需要三次握手。这允许发送方和接收方建立所需的状态信息（例如，序号和初始流控制窗口长度）。</p></li></ul><ul id="c0a44a6e-d860-4e2e-bef4-4ee4eaee71df" class="bulleted-list"><li>连接建立<p id="17c1f59b-41f5-4128-a73b-a5ba368f3229" class="">以类似对应的方式，某些网络层体系结构如 ATM、帧中继、MPLS，要求从源到目的地沿着所选择的路径彼此握手，以便在给定源到目的地连接中的网络层 数据分组能够开始流动之前建立起状态。在网络层，该过程被称为连接建立。</p></li></ul><ul id="9a70e18b-8684-4e00-889d-d5e282e1c541" class="bulleted-list"><li>对比<ul id="1deb8ecc-50aa-4dd9-8794-f86d5746b0f3" class="bulleted-list"><li>网络层的连接建立，是在两个端系统之间建立通信（在虚电路网络中，还包括中间路由器）；</li></ul><ul id="57197202-fd5d-4503-a773-37f6684d9429" class="bulleted-list"><li>传输层的连接建立，是运行在两个端系统上的进程之间进行连接建立；</li></ul></li></ul></details></li></ul></details></li></ul><ul id="71274580-382a-4d88-bc8c-6e30dd825ec8" class="toggle"><li><details open=""><summary>网络服务模型</summary><ul id="39132e47-96a2-4710-8fac-98307a6b57a2" class="toggle"><li><details open=""><summary>定义</summary><p id="a41d9dac-867c-4609-a5c4-016a0a0f829b" class="">网络服务模型（network service model）定义了分组在发送与接收端系统之间的端到端运输特性。</p></details></li></ul><ul id="86fb368c-fa71-4644-8a2e-05c4c80a9a24" class="toggle"><li><details open=""><summary>期望内容<strong>(也许事与愿违)</strong></summary><p id="d2066e8b-94bb-437f-ab05-cbd73e1b8ab4" class="">针对于传输层向应用层提供的服务内容，传输层向底层的网络层提出了如下需求：</p><ul id="513eb111-1a40-4726-a08f-ffe26d3f7257" class="bulleted-list"><li>在发送主机中，当运输层向网络层传递一个分组时，能由网络层提供的特定服务包括：<ul id="1a343a94-a0ff-413b-87f4-81fb0902e22e" class="bulleted-list"><li>确保交付：<p id="56126c54-b6c4-4050-9fd9-5f63b014b50b" class="">该服务确保分组将最终到达其目的地；</p></li></ul><ul id="7154bd0d-0112-4eff-b222-0204ba01b8ac" class="bulleted-list"><li>具有时延上界的确保交付：<p id="cb482158-1d5d-4cae-a126-1c8a41778305" class="">该服务不仅确保分组的交付，而且在特定的主机到主机时延上界内（例如在 100ms 内）交付；</p></li></ul></li></ul><ul id="568b9e32-7d09-4a91-b114-fffff874c247" class="bulleted-list"><li>能够为给定的源和目的地之间的分组流提供下列服务：<ul id="d8dd1ed3-8b02-4292-9c2f-e67f2756d70b" class="bulleted-list"><li>有序分组交付：<p id="f32cddff-2d1b-4bd1-8a62-b74cc80ac148" class="">该服务确保分组以它们发送的顺序到达目的地；</p></li></ul><ul id="b3a31d95-9954-434b-bb0b-c686274970e7" class="bulleted-list"><li>确保最小带宽：<p id="85bcd22c-3082-4eb1-9e57-de2c3028c7b3" class="">只要发送主机以低于特定比特率的速率传输比特（作为分组的组成部分），则分组不会丢失，且每个分组会在预定的主机到主机时延内到达（例如在 40ms 内）。</p></li></ul><ul id="f582503d-a982-4873-bc89-edb6145f2484" class="bulleted-list"><li>确保最大时延抖动：<p id="716c6c5e-11b3-497e-a45e-a285d93b2b26" class="">该服务确保位于发送方的两个相继分组之间的时间量等于在目的地接收到它们之间的时间量（或这种间隔的变化不超过某些特定的值）。</p></li></ul><ul id="972e1d24-4288-4cb4-ab0c-0d77dcf09e4f" class="bulleted-list"><li>安全性服务：<p id="4602be8f-e943-4af8-892e-c63ee042962d" class="">使用仅由源和目的主机所知晓的一个秘密会话密钥，在源主机中的网络层能够加密向目的主机发送的所有数据报负载。在目的主机中的网络层则能够负责解密该负载。</p></li></ul><p id="1e9363dc-0291-4786-8295-3dfae66f91ed" class="">
</p></li></ul></details></li></ul><ul id="af244fba-fc68-4a29-8fc0-97bd122903af" class="toggle"><li><details open=""><summary><strong>实际提供内容</strong></summary><p id="2c31e82f-d00a-4ca1-8c2a-1f0ae4132bc9" class="">因特网的网络层提供了单一的服务，称为<strong>尽力而为服务</strong>（best-effort service）。使用尽力而为服务，分组间的定时是不能确保被保证的，分组接收的顺序也不能 保证与发送的顺序一致，传送的分组也不能保证最终交付。</p><figure id="4c3cb350-9cc3-4a82-a7e2-025be7e7fc29" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image2.jpeg"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image2.jpeg"/></a></figure><h3 id="506513a0-8c4b-4618-91a9-2d7fd6323c11" class="">注：</h3><ul id="ec1bf9d6-95ac-4de9-baed-4e19993fd680" class="bulleted-list"><li>恒定比特率（Constant Bit Rate，CBR）ATM 网络服务；</li></ul><ul id="9005e69e-5821-42af-9cec-20d509981fe6" class="bulleted-list"><li>可用比特率（Available Bit Rate，ABR）ATM 网络服务；</li></ul></details></li></ul></details></li></ul><h1 id="597eb6d8-33da-47c8-8278-b0a708bf4c88" class="">二、虚电路网络和数据报网络</h1><ul id="8064d9c7-108d-41f7-bf36-bfb17677ce0a" class="toggle"><li><details open=""><summary>定义</summary><p id="b46a905c-0bf1-4e8c-8fe5-546649f22fc0" class="">为了应对运输层要求的应用程序提供无连接服务或面向连接服务，网络层的连接和无连接服务在许多方面与运输层的面向连接和无连接服务类似，但是也有一些不同：</p><ul id="2701ec66-a76b-421f-9a5a-8a2ee51f2fb2" class="bulleted-list"><li>在网络层中，这些服务是<strong>由网络层向运输层提供的主机到主机的服务</strong>。在运输层中，这些服务则是<strong>运输层向应用层提供的进程到进程的服务</strong>。</li></ul><ul id="5fbabd09-7c94-420a-913b-baa8764b3aac" class="bulleted-list"><li>网络层或者提供了主机到主机的无连接服务，或者提供了主机到主机的连接服务，而不同时提供这两种服务：<ul id="e22286c8-e4cf-4f6e-9e6b-28b98c44c45a" class="bulleted-list"><li>仅在网络层<strong>提供连接服务</strong>的计算机网络称为<strong>虚电路（Virtual-Circuit，</strong>VC）网络；</li></ul><ul id="19bebb66-67d2-45fc-bda3-3f5fe5a6df0d" class="bulleted-list"><li>仅在网络层 <strong>提供无连接服务</strong> 的计算机网络称为 <strong>数据报网络</strong></li></ul></li></ul><ul id="51de019f-f564-4782-8630-f1323bf373bd" class="bulleted-list"><li>网络层连接服务除了在端系统中，也在位于网络核心的路由器中实现。</li></ul></details></li></ul><ul id="084b9218-4e84-414c-90e4-dd533d2ec239" class="toggle"><li><details open=""><summary>虚电路网络</summary><ul id="142bd5aa-458b-454a-a8c1-73a88a3375ed" class="toggle"><li><details open=""><summary>引出</summary><p id="9b5b0fe2-0cac-455d-b9d0-f6582480d019" class="">虽然因特网是一个数据报网络，但许多其他网络体系结构（包括 ATM、帧中继的体系结构）却是虚电路网络。因此在虚电路网络的网络层中应该实现面向连接的服务。</p></details></li></ul><ul id="4a4cfabd-a90d-411c-9a31-ce3e03e273de" class="toggle"><li><details open=""><summary>组成</summary><ul id="085cb95f-7ba9-4ede-9da5-c200f3c4584b" class="bulleted-list"><li>源和目的主机之间的路径，类似于电话电路，有电路级的性能；</li></ul><ul id="5e85fc5f-d404-4344-811c-f9cf32f52ad1" class="bulleted-list"><li>VC 号，沿着该路径的每段链路的一个号码；</li></ul><ul id="059e4b04-9602-430c-ac7b-d98a8b9070de" class="bulleted-list"><li>沿着该路径的每台路由器中的转发表，为每一个连接维持一个状态。</li></ul><p id="c4aa2bd6-c4ab-422c-a894-6600b57c3564" class="">属于某一条确定的虚电路的分组将在它的首部携带一个 VC 号（不是目的IP）。因为一条虚电路在每条链路上可能具有不同的 VC 号，因此每台中间路由器必须用一个新的VC 号替代经过它的每个传输分组的 VC 号。而该新的 VC 号从转发表获取。</p></details></li></ul><ul id="0ab8d286-f883-4a3b-94fe-ee87b722453b" class="toggle"><li><details open=""><summary><strong>示例</strong></summary><figure id="4eb82422-2055-43d7-b2fd-7ff2555df5b0" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image3.jpeg"><img style="width:400px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image3.jpeg"/></a></figure><p id="0d4caeaf-cd72-4a16-b69f-115ed6b4da7b" class="">假定主机 A 请求该网络在它自己与主机 B 之间创建一条虚电路。同时假定该网络为该虚电路选择路径 A-R1-R2-B 并为这条路径上的这 3 条链路分配 VC 号 12、22 和 32。</p><ul id="9951d96d-4f72-43cd-9f12-da745f44bd24" class="bulleted-list"><li>VC 值的变化过程<p id="85c76ef2-2fc3-4003-8d87-128523255a71" class="">当在这条虚电路中的分组离开主机 A 时，在该分组首部中的 VC 字段的值是 12；当它离开 R1 时，该值是 22，而当它离开 R2 时，该值是 32。</p></li></ul><ul id="be50c32b-dc20-4d1f-b999-eba21ec80d5f" class="bulleted-list"><li>可能的 R1 转发表<figure id="9ace2f04-5510-471d-ae0b-4bc264fdde3f" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image4.png"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image4.png"/></a></figure></li></ul></details></li></ul><ul id="734f4379-c21e-44c2-bacc-da822ec86725" class="toggle"><li><details open=""><summary>VC 分组的 VC 号不保持的原因</summary><ul id="4879906a-0b57-496a-b76a-7133ca9a04c9" class="bulleted-list"><li>逐链路代替该号码减少了在分组首部中 VC 字段的长度：<p id="c32fe416-af36-41d0-94df-3c4d0a04179c" class="">如果要求 VC 数据包从源主机到目的主机的 VC 保持，则要对互联网世界中所有的连接进行编号，这个编号值将是巨大的，因此 VC 字段长度将大幅提升；</p></li></ul><ul id="f686e4aa-b618-4403-860d-9b39f5fa8416" class="bulleted-list"><li>大大简化了虚电路的建立：<p id="7a157253-40fe-4a8e-a5c2-ceeb949a047a" class="">在具有多个 VC 号的一段物理通路，其上的每条链路能够独立于沿着该路径的其他链路所选的号码选择一个 VC 号。如果沿着某路径的所有链路要求一个共同的 VC 号的话，路由器将不得不交换并处理相当大量的报文；将路由器 R1 到 R2 的物理链路进行充分复用，并且以互异的 VC 号的方法构建同线路上的多个链接体系；</p></li></ul></details></li></ul><ul id="ba83c09c-29a0-41fb-804a-c1fcb01e26f1" class="toggle"><li><details open=""><summary>VC 网络中的路由器维护连接状态</summary><p id="d36073cc-3a7a-4760-bad3-28eb37f97190" class="">在虚电路网络中，该网络的路由器必须为进行中的连接维持连接状态信息。特别是：</p><ul id="f749f60a-0af2-4f55-8834-39778bdfb547" class="bulleted-list"><li>每当跨越一台路由器创建一个新连接，必须在该路由器的转发表中增加一个新的连接项；</li></ul><ul id="63d79350-ff19-4a96-90de-49e38cf171b7" class="bulleted-list"><li>每当释放一个连接，必须从该表中删除该项；<p id="96a349e5-11a4-42d1-9a71-a73b97a9c330" class="">值得注意的是，即使没有 VC 号转换，仍有必要维持连接状态信息，该信息将 VC 号与输出接口号联系起来。</p></li></ul></details></li></ul><ul id="e50c18f6-0f77-4049-85dc-cb8e83b7c5b8" class="toggle"><li><details open=""><summary>虚电路网络中的三个明显状态</summary><figure id="85806fd1-1f8f-4521-8971-b350f06cd661" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image5.jpeg"><img style="width:696px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image5.jpeg"/></a></figure><ul id="829edde5-95f5-4d72-87ef-64ab661d5c9e" class="toggle"><li><details open=""><summary><strong>虚电路建立</strong></summary><ol id="53e94f73-6e79-42f8-80a1-1066ddc86945" class="numbered-list" start="1"><li>在建立阶段，发送方运输层与网络层联系，指定接收方地址，等待网络层建立虚电路，即由网络层决定发送方与接收方之间的路径，即该虚电路的所有分组要通过的一系列链路与路由器；</li></ol><ol id="8c3d78dd-e3ed-48e2-ab3a-b261046283d5" class="numbered-list" start="2"><li>网络层也为沿着该路径的每条链路决定一个 VC 号；</li></ol><ol id="244cb95d-a974-4330-9882-b4913674d8c9" class="numbered-list" start="3"><li>最后，网络层在沿着路径的每台路由器的转发表中增加一个表项。在虚电路建立期间，网络层还可以预留该虚电路路径上的资源（如带宽）；</li></ol></details></li></ul><ul id="21d46b03-632f-4702-b437-a4dd4e03d196" class="toggle"><li><details open=""><summary>数据传递</summary><p id="2d54f645-ea86-49f5-be59-a5c15993baaf" class="">虚电路一旦成功创建，分组就可以开始沿着该虚电路流动。</p></details></li></ul><ul id="32707328-0f48-45cc-96ce-1aa5993ab7ea" class="toggle"><li><details open=""><summary>虚电路拆除</summary><ol id="83eae7c2-7fbc-406c-bcc4-7cfcc1411123" class="numbered-list" start="1"><li>当发送方（或接收方）通知网络层它希望终止该虚电路时，就启动这个阶段。</li></ol><ol id="25e5f809-54a0-4e91-af01-c609c0725db0" class="numbered-list" start="2"><li>然后网络层通常将通知网络另一侧的端系统结束呼叫，并更新路径上每台分组路由器中的转发表以表明该虚电路已不存在了。</li></ol></details></li></ul></details></li></ul></details></li></ul><ul id="a199966f-d759-47d7-b864-d98c42f5da06" class="toggle"><li><details open=""><summary>数据报网络</summary><ul id="d05e553d-d0a5-4738-b37d-91901c81cefc" class="toggle"><li><details open=""><summary>数据报网络的特点</summary><p id="1ca9cd5d-e81d-4447-a48e-0eb0eef9c0eb" class="">在数据报网络中，每当一个端系统要发送分组，它就为该分组加上目的端系统的地址，然后将分组推进网络中。无需建立任何虚电路，路由器不维护任何虚电路的状态信息。</p></details></li></ul><ul id="5d9fe223-1fee-474d-a0a9-8ab78ae7125b" class="toggle"><li><details open=""><summary>数据报网络的转发方法</summary><figure id="a6bac8b7-7926-4665-9779-f98ed48592a9" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image6.jpeg"><img style="width:684px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image6.jpeg"/></a></figure><p id="34be594d-b2b4-4096-9ad6-9ab5124b8648" class="">转发分组的路由器中的每台都使用分组的目的地址来转发该分组（而不是VC 号）。特别是：</p><ol id="6f9b80d1-3cb4-433f-a5a1-e69e55d5c68f" class="numbered-list" start="1"><li>每台路由器有一个将目的地址映射到链路接口的<strong>转发表</strong>；</li></ol><ol id="4efec081-5295-4254-8040-64749b8921c6" class="numbered-list" start="2"><li>当分组到达路由器时，路由器使用该分组的目的地址在转发表中查找适当的输出链路接口；</li></ol><ol id="be7664d0-a48d-4af7-a675-44cb4ce7dafa" class="numbered-list" start="3"><li>然后路由器有意将分组向该输出链路接口转发；</li></ol></details></li></ul><ul id="528d2748-46a8-438d-bf9f-fd30db45e0c2" class="toggle"><li><details open=""><summary>示例</summary><p id="d4a4239f-6491-415d-8b88-24310ed33845" class="">假定所有的目的地地址均是 32 比特（这恰好就是在 IP 数据报中目的地址的长度）。转发表若蛮力实现将对每个可能的目的地址对应一个表项，则每个路由器将存储超过 40 亿个可能的地址。然而，对于以下情况的路由表，可以简化存储：对路由表中的 IP 地址进行总结归纳后，充分利用其前缀大量重复的特点，实际路由表中仅存储四条记录即可，如下所示：</p><figure id="63818351-b818-47de-a193-92e762de2aa1" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image7.png"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image7.png"/></a></figure><figure id="7f0dbdb9-4262-4240-b2a9-e876dd92d51f" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image8.png"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image8.png"/></a></figure><h3 id="3d68063d-dd45-4870-8cb9-ad1452a6a246" class="">注意：</h3><p id="6dd30d4c-85d5-4ebd-9692-0f99870d9fac" class="">一个目的地址可能与不止一个表项相匹配。当有多个匹配时，该路由器使用最长前缀匹配规则（longest prefix matching rule）：即在该表中寻找最长的匹配项，并向与最长前缀匹配相关联的链路接口转发分组；实际上，在数据报网络中的转发表是通过路由选择算法进行修改的，这通常每 1~5 分钟左右更新一次转发表。因为在数据报网络中的转发表能够在任何时刻修改，从一个端系统到另一个端系统发送一系列分组可能在通过网络时走不同的路径，并可能无序到达。</p></details></li></ul></details></li></ul><ul id="0bb1e1da-d262-41b5-b3cf-a6e9faf85296" class="toggle"><li><details open=""><summary>数据报网络和虚电路网络的对比</summary><figure id="6051d020-118c-4acf-8b00-d7ae53bf462e" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image9.png"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image9.png"/></a></figure></details></li></ul><p id="2e25ac78-8141-42f1-a0e3-dbbabad54125" class="">
</p><h1 id="2a756620-1cf3-4b8b-a20f-32f1f1720102" class="">三、路由器工作原理——地址解析协议 ARP</h1><ul id="cb72efd3-ee07-48ad-89c1-52edf9a32f89" class="toggle"><li><details open=""><summary>ARP 定义</summary><ul id="ac007bb3-159e-42a2-91f7-31a1824937b2" class="bulleted-list"><li>不管网络层使用的是什么协议，在实际网络的链路上传送数据帧时，最终还是必须使用硬件地址。</li></ul><ul id="912ad532-7a8a-49c5-a8ac-25f73caaa059" class="bulleted-list"><li>每一个主机都设有一个 ARP 高速缓存(ARP cache)，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。</li></ul><ul id="8599597f-442e-4a09-bc1e-1f0c599dbbfe" class="bulleted-list"><li>当主机 A 欲向本局域网上的某个主机 B 发送 IP 数据报时，就先在其ARP 高速缓存中查看有无主机 B 的 IP 地址。如有，就可查出其对应的硬件地址，再将此硬件地址写入 MAC 帧，然后通过局域网将该 MAC 帧发往此硬件地址。</li></ul></details></li></ul><ul id="8d811d4e-3298-4196-a0b1-5ba50e13d92d" class="toggle"><li><details open=""><summary>ARP 查询过程</summary><figure id="30a8e456-15cd-45bf-b3af-d57db9df96d3" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image10.png"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image10.png"/></a></figure><p id="5ec25fe2-872b-4baf-8cba-7a8f7048772a" class="">注意：ARP 查询是广播请求，ARP 回应是点对点回应。</p></details></li></ul><ul id="3d8d5ccb-9fb4-441a-aacf-3ba3cacf0fbc" class="toggle"><li><details open=""><summary>使用 ARP 的四种典型情况</summary><ul id="4385dfea-b5e2-40a9-9697-621cd3a58b65" class="bulleted-list"><li>发送方是主机，要把 IP 数据报发送到本网络上的另一个主机。这时用ARP 找到目的主机的硬件地址；</li></ul><ul id="e2b19bed-4678-4785-b074-cf97ace5c756" class="bulleted-list"><li>发送方是主机，要把 IP 数据报发送到另一个网络上的一个主机。这时用ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成；</li></ul><ul id="81a3a75d-09c2-4c30-9cf7-3c9d486ea6d4" class="bulleted-list"><li>发送方是路由器，要把 IP 数据报转发到本网络上的一个主机。这时用ARP 找到目的主机的硬件地址；</li></ul><ul id="a59f7413-d0f7-45bf-9f0c-3d5327908fa2" class="bulleted-list"><li>发送方是路由器，要把 IP 数据报转发到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成；</li></ul></details></li></ul><ul id="968cc7d2-3df4-4189-84a1-10a148de66b7" class="toggle"><li><details open=""><summary>为什么不直接使用硬件地址进行通信？</summary><p id="ea40be1a-b7d2-47c5-98e9-8379180032ad" class="">IP 地址 32 位，MAC 地址 48 位</p><ul id="e1e19f31-5f50-431e-9b2a-4f8c27e6a4fe" class="bulleted-list"><li>MAC 地址数量过于庞大，将其全部记载在路由器的“MAC 地址转发表” 中，非常不现实；</li></ul><ul id="a7371ae1-5e12-4abe-8504-011abdfd1141" class="bulleted-list"><li>使用 IP 地址和 MAC 地址结合的方式，进行分级的主机寻址是最合理的方案，<strong>因此需要一个负责本网段的路由转发的路由表是合理的</strong>；</li></ul></details></li></ul><h1 id="cb798144-be32-4171-884c-3140c6b57701" class="">四、IP 协议（重点）</h1><figure id="d12f4eea-123d-486c-a46f-fc0565dbd3aa" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image11.jpeg"><img style="width:525px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image11.jpeg"/></a></figure><ul id="d86225e6-6dd5-4569-a77f-412af9dbe91c" class="toggle"><li><details open=""><summary>数据报格式</summary><figure id="cc1068de-5dbd-499f-8a13-a690a3fe3e92" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image12.jpeg"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image12.jpeg"/></a></figure><figure id="b9a2810d-63ae-448c-95c9-86c293b0d79d" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image13.jpeg"><img style="width:469px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image13.jpeg"/></a></figure><ul id="eb0d5bed-4523-4bfd-b91d-3c5f525684c3" class="toggle"><li><details open=""><summary>IPv4 网络层数据报组成：</summary><ul id="efd8d589-0653-4ef3-bdef-2a5ae335270d" class="bulleted-list"><li><strong>版本（号）</strong><p id="519f7cda-c7f9-4620-861a-765f4e76d8b2" class="">这 4 比特规定了数据报的 IP 协议版本。通过查看版本号，路由器能够确定如何解释 IP 数据报的剩余部分。不同的 IP 版本使用不同的数据报格式。</p></li></ul><ul id="e5bee6a6-c91a-417c-ae2a-46552af80bea" class="bulleted-list"><li>首部长度<p id="48ce6335-28d9-421f-9fbb-8ef4d9b9d940" class="">因为一个 IPv4 数据报可包含一些可变数量的选项，故需要用这 4 比特来确定 IP 数据报中数据部分实际从哪里开始。大多数 IP 数据报不包含选项，所以一般的 IP 数据报具有 20 字节的首部。</p></li></ul><ul id="13129723-4ba6-43e2-b05a-8be8f8054431" class="bulleted-list"><li>服务类型<p id="5ed07392-dc4a-418e-bd4b-6379c74e90e3" class="">服务类型（TOS）比特包含在 IPv4 首部中，以便使不同类型的 IP 数据报能相互区别开来。例如，将实时数据报（如用于 IP 电话应用）与非实时流量（如FTP）区分开。提供特定等级的服务是一个由路由器管理员决定的策略问题。</p></li></ul><ul id="d6cfed22-e86c-40e3-9425-1770faf8da4d" class="bulleted-list"><li>数据报长度<p id="fbc12941-5616-48aa-9dab-03ecfee24df9" class="">这是 IP 数据报的总长度（首部加上数据），以字节计。因为该字段长为 16 比特，所以 IP 数据报的理论最大长度为 65535 字节。然而，数据报很少有超过 1500 字节的。</p></li></ul><ul id="517a1852-ace5-4131-85a9-56bb31528a09" class="bulleted-list"><li>标识、标志和片偏移字段<p id="184929ca-1304-4c3e-bded-169e32795ee8" class="">这三个字段与所谓 IP 分片有关</p></li></ul><ul id="12d981d3-c182-4a2c-a607-f556980de646" class="bulleted-list"><li>寿命（TTL）<p id="678b989a-5715-4be1-8419-a1405ab20f80" class="">寿命（Time-To-Live，TTL）字段用来确保数据报不会永远在网络中循环。每当数据报由一台路由器处理时，该字段的值减 1。若 TTL 字段减为 0，则该数据报必须丢弃。</p></li></ul><ul id="fff42ef9-3cc1-4377-ad15-6183b81b995a" class="bulleted-list"><li>上层协议<p id="e3764a39-606e-4881-9fd2-7d2ec8f71c76" class="">该字段值指示了 IP 数据报在到达目的端系统后，其数据部分应交给哪个特定的运输层协议。例如，值为 6 表明数据部分要交给 TCP，而值为 17 表明数据要交给 UDP。</p><p id="a0c896b9-65e3-49fe-b51d-a6cb550b4d5a" class="">注意在 IP 数据报中的协议号所起的作用，类似于运输层报文段中端口号字段所起的作用。协议号是将网络层与运输层绑定到一起的粘合剂，而端口号是将运输层和应用层绑定到一起的粘合剂。</p></li></ul><ul id="f5daf18a-2ed0-49b4-966e-900965ede74d" class="bulleted-list"><li>首部校验和<p id="98d71448-843b-47e8-ae64-f44f2202becc" class="">首部检验和用于帮助路由器检测收到的 IP 数据报中的比特错误。注意，该校验和仅对 IP 数据报的首部进行校验和计算。</p></li></ul><ul id="17c8dafc-dfd7-4432-88db-3847cc0dc3cb" class="bulleted-list"><li>源和目的 IP 地址<p id="b99902ed-3aaa-4c2d-8c57-1a3f709cac1d" class="">当某源生成一个数据报时，它在源 IP 字段中插入它的 IP 地址，在目的 IP 地址字段中插入其最终目的地的地址，通常源主机通过 DNS 查找来决定目的地址。</p></li></ul><ul id="fc01283d-5932-45b0-a3bc-4d05143c88e0" class="bulleted-list"><li>选项<p id="3add9fa6-5759-4b65-963f-ed26ad393a98" class="">选项字段允许 IP 首部被扩展，但是其很少使用，包括时间戳等。</p></li></ul><ul id="59571209-ff3e-4730-a119-5c2cc18de25d" class="bulleted-list"><li>数据（有效载荷） <p id="9c1ff72b-32f6-4898-92d7-19fc340b705f" class="">注意：</p><p id="033aa6d2-5217-483d-ba1d-6f74a0773332" class="">一个 IP 数据报有总长为 20 字节的首部（假设无选项）。如果数据报承载一个TCP 报文段，则每个（无分片的）数据报共承载了总长 40 字节的首部（20 字节的 IP 首部+20 字节的 TCP 首部）以及应用层报文。</p></li></ul></details></li></ul></details></li></ul><ul id="6da2690a-af4b-49b7-a236-f1d58a97cdf4" class="toggle"><li><details open=""><summary>IPV4地址域间划分</summary><ul id="7c1399df-33c8-40e8-b275-168429b708dd" class="toggle"><li><details open=""><summary>概述</summary><ul id="df197ab1-d40e-4408-aa4a-749cc0697279" class="toggle"><li><details open=""><summary><strong>接口</strong></summary><p id="080fd919-da00-45a8-9ca2-b37b5e4b3171" class="">主机与物理链路之间的边界叫做接口（interface）。路由器与它的任意一条链路之间的边界也叫做接口。而IP 要求每台主机和路由器接口拥有自己的IP 地址。</p><p id="a159d893-c0d8-4224-9fac-e0cb1d38d60b" class="">因此，一个 IP 地址技术上是与一个接口相关联的，而不是与包括该接口的主机或路由器相关联的。</p></details></li></ul><ul id="1a43fbac-0c5b-45d5-a4f0-6186c3e2873c" class="toggle"><li><details open=""><summary><strong>IP 地址</strong></summary><figure id="6a4e292b-fcfc-4c4d-a3b0-2727f26130e6" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image16.jpeg"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image16.jpeg"/></a></figure><p id="21335b88-5693-42fe-9036-e6cd9104d5d7" class="">每个 IP 地址长度为 32 比特（等价为 4 字节），因此总共有 <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span>个可能的 IP 地址。由于 <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span> 近似地表示 <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">10^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span>， 故容易看出约有 40 亿个可能的 IPv4 地址。</p></details></li></ul></details></li></ul><ul id="ac590231-3cda-4059-9fee-96ccb949dde1" class="toggle"><li><details open=""><summary>IP 数据报分片</summary><ul id="67ac3496-ccf0-4c9e-b659-92abb74eaf12" class="toggle"><li><details open=""><summary><strong>问题的引出</strong></summary><p id="d04dbd86-566b-493c-9d19-6950affaf5b5" class="">并不是所有链路层协议都能承载相同长度的网络层分组。有的协议能承载大数据报，而有的协议只能承载小分组。一个链路层帧能承载的最大数据量叫做 最大传送单元（ Maximum Transmission Unit，MTU）。因为每个 IP 数据报封装在链路层帧中从一台路由器传输到下一台路由器，故链路层协议的 MTU 严格地限制着 IP 数据报的长度。在发送方与目的地路径上的每段链路可能使用不同的链路层协议，且每种协议可能具有不同的 MTU。</p></details></li></ul><ul id="23877ced-7b5d-442f-8aad-7ff9630e4cad" class="toggle"><li><details open=""><summary>问题的处理措施</summary><p id="b998f5fc-13d8-46dc-a142-1e78be2a573c" class="">假定从某条链路收到一个 IP 数据报，通过检查转发表确定出链路，并且该出链路的 MTU 比该 IP 数据报的长度要小：</p><ul id="cbab1e1e-1edf-498b-807f-7f4b997c46bd" class="bulleted-list"><li>将 IP 数据报中的数据分片成两个或更多个较小的 IP 数据报，用单独的链路层帧封装这些较小的 IP 数据报；</li></ul><ul id="e0132940-d074-41db-aa92-9d547a212301" class="bulleted-list"><li>然后向输出链路上发送这些帧。每个这些较小的数据报都称为<strong>片</strong></li></ul></details></li></ul><ul id="c3feb864-3c3f-4e36-9930-3604da43b870" class="toggle"><li><details open=""><summary><strong>注意</strong></summary><ul id="424264a0-808e-4d13-98b2-bf347a96e7ba" class="bulleted-list"><li><mark class="highlight-red"><strong>片的重组仅发生在目的端系统中</strong></mark><mark class="highlight-red">，即若经过路由器 A 时因 MTU 限制报文段被切分，而在路由器 B 中 MTU 足够，此时重组也不会发生；节省了分组重组的时间。</mark></li></ul><ul id="a1f54695-0be7-4fc5-8f9d-8f31b243a0af" class="bulleted-list"><li>使用 IP 数据报首部的标识、标志和片偏移字段，指示该数据报是否是原报文段的一片，其后是否还有片；</li></ul></details></li></ul><ul id="72806a18-0c4e-4a91-b10c-64a8605e3388" class="toggle"><li><details open=""><summary>实现原理</summary><ul id="861f4b2e-c15c-42eb-9ae9-2bea5f0033cd" class="bulleted-list"><li>发送主机通常将为它发送的每个数据报的标识号加 1，而<strong>从一个数据报分出的所有片具有和原数据报相同的标识号；</strong></li></ul><ul id="b3764a01-41fd-4b34-aff5-baccb3ffc0bf" class="bulleted-list"><li>在同一数据报的分片中，<strong>除最后一个分片的标志位为 1，其余分片标志位均为 0</strong>。表明了一个完整数据报分组的接收完成；</li></ul><ul id="a3d74c31-a411-4eb9-ad83-73c0a9fcae67" class="bulleted-list"><li>为了让目的主机确定是否丢失了一个片，且能按正确的顺序重新组装片，<strong>使用偏移字段指定该片应放在初始 IP 数据报的哪个位置</strong>；<mark class="highlight-red">偏移字段÷8，得到offset</mark></li></ul></details></li></ul><ul id="4a044828-c327-4d72-9fe8-9f943c04837c" class="toggle"><li><details open=""><summary>示例</summary><figure id="8971c019-5be3-49e6-8ea2-7720ed1c5b60" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image14.jpeg"><img style="width:520px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image14.jpeg"/></a></figure><p id="9543f595-a74b-40ef-a471-0574c8b932e3" class="">一个 4000 字节的数据报（20 字节 IP 首部加上 3980 字节IP 有效载荷）到达一台路由器，且必须被转发到一条 MTU 为 1500 字节的链路上。这就意味着初始数据报中 3980 字节数据必须被分配为 3 个独立的片（其中的每个片也是一个 IP 数据报）。假定初始数据报贴上的标识号为 777，并且偏移值应当被规定以 8 字节块为单位，即偏移量 offset 应该除以8。</p><figure id="35c87fcd-9367-4c5d-8147-0b0e5edf4b0a" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image15.jpeg"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image15.jpeg"/></a></figure></details></li></ul></details></li></ul><ul id="01bfdc56-1733-4a6b-9edd-c11d908c13f2" class="toggle"><li><details open=""><summary>IP 编址—分类编址</summary><p id="c18c3c2e-762d-41e8-b360-1768f802f852" class="">IP 地址的网络部分被限制为长度为 8、16 或 24 比特，这是一种称为分类编址（classful addressing） 的编址方案，这是因为具有 8、16 和24 比特子网地址的子网分别被称为A、B 和 C 类网络。</p><figure id="c23db445-a99a-477f-8280-5fdb9d930e29" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image17.png"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image17.png"/></a></figure><figure id="b7444697-71ee-441b-a07c-e96453f636a1" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/Untitled.png"><img style="width:853px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/Untitled.png"/></a></figure><ul id="6ec3ae64-b08d-465c-8542-250bdf0b5808" class="bulleted-list"><li>问题<p id="df97cad3-1df3-4914-97f9-fa64f6b69594" class="">一个 C 类（/24）子网仅能容纳多达<style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>8</mn></msup><mo>−</mo><mn>2</mn><mo>=</mo><mn>254</mn></mrow><annotation encoding="application/x-tex"> 2^8-2=254</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">4</span></span></span></span></span><span>﻿</span></span> 台主机（<style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>8</mn></msup><mo>=</mo><mn>256</mn></mrow><annotation encoding="application/x-tex">2^8=256</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">6</span></span></span></span></span><span>﻿</span></span>，其中的两个地址全 0 和全 1 预留用于特殊用途），这对于许多组织来说太小了。然而一个B 类（/16）子网可支持多达 65534 台主机，又太大了。在分类编址方法下，比方说一个有 2000 台主机的组织通常被分给一个 B 类（/16）地址。这就导致了 B 类地址空间的迅速损耗以及所分配的地址空间的利用率低。例如，为具有 2000 台主机的组织分配了一个 B 类地址，就具有足以支持多达 65534 个接口的地址空间，剩下的超过 63000 个地址却不能被其他组织使用。</p></li></ul><ul id="e31899ff-297a-46fd-a226-fa8f7c461047" class="bulleted-list"><li>特殊用途的 IP<figure id="507d978a-571b-4eb7-815f-88a2a74a5f53" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image18.png"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image18.png"/></a></figure></li></ul><ul id="a6908465-8999-446c-817a-2e1ea8208214" class="bulleted-list"><li>私有 IP 地址块<figure id="5e922026-a5db-4dba-8237-9d6f0f5e9d1d" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image19.png"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image19.png"/></a></figure><ul id="281dee61-1034-4000-b80f-6eeb3f7a5ce7" class="bulleted-list"><li>A 类私有IP 有一个网络地址块，该网络地址块下有一千六百多万主机 IP；</li></ul><ul id="e8ce2509-49ff-4da6-8ebb-48e44e353ed3" class="bulleted-list"><li>B 类私有 IP 有 16 个网络地址块，该网络地址块下有六万多个主机 IP；</li></ul><ul id="9d4ea795-6bbc-4029-828c-72e40f83db68" class="bulleted-list"><li>C 类私有 IP 有 256 个网络地址块，该网络地址块下有 254 个主机 IP； 这些 IP 是不能作为公网 IP 对外使用的。</li></ul></li></ul></details></li></ul></details></li></ul><ul id="6f54370a-7e75-40bf-ba25-8d40410577e7" class="toggle"><li><details open=""><summary>内网中的 IP 地址管理——内网划分</summary><ul id="e1a0e47d-7085-4751-93ae-11f3416e172e" class="toggle"><li><details open=""><summary>子网概念的引出</summary><figure id="740da8a2-3f03-4695-a7ff-c629d16d6614" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image20.png"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image20.png"/></a></figure><p id="5d05da81-e5f0-400a-b450-fa2f84504e38" class="">分类划分中将 IP 地址分为网络部分和主机部分，这种方法下的路由器需要管理与其相关联的下级主机的所有点对点转发映射关系，对于内网管理这是极其繁杂和不现实的。如上图所示，若在该大学的内网中使用这种方式，main router 需要存储该大学所有的路由转发关系，转发的效率低下，并且这种分配方式会很容易造成 IP 地址的浪费。因此，采取分级化的 IP 地址管理是合理的：将每个院系作为一个小的网段， 该网段内的所有 IP 有相同的网络部分 IP，仅仅是主机 IP 部分不一样。这样，院系级路由器仅需管理院系内部所有的转发关系，学校的 main router 只需要管理几个院系级的路由器 IP 即可，查询效率提升，并且还可以根据院系的实际使用IP 数量进行合理的 IP 分配，减少 IP 浪费。</p><p id="da308b75-7ac0-45f3-82ba-ea39d7bb4629" class="">
</p></details></li></ul><ul id="f41904e1-de6d-42c4-88a1-523cb5f9fd91" class="toggle"><li><details open=""><summary>划分子网的基本思路</summary><ul id="91d5ea55-cdeb-43fc-a07b-1946f4ff99a2" class="bulleted-list"><li>划分子网<strong>纯属一个单位内部的事情</strong>，单位<strong>对外仍然表现为没有划分子网的网络</strong>。</li></ul><ul id="8dc38d8d-58fa-416b-9e9f-52ace74ae95f" class="bulleted-list"><li><strong>从主机号借用若干个位作为子网号 subnet-id</strong>，而主机号 host-id 也就相应减少了若干个位。<figure id="00e38cf7-26ef-46e3-8992-8433358af20f" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image21.png"><img style="width:432px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image21.png"/></a></figure></li></ul><ul id="75ba1a93-de73-41f0-a9cb-850a3cbafaec" class="bulleted-list"><li>工作思路：<ul id="6f74879c-c2dc-4d53-b4b1-3d19b6c28d05" class="bulleted-list"><li>凡是从其他网络发送给本单位某个主机的 IP 数据报，仍然是根据IP 数据报的目的网络号 net-id，先找到连接在本单位网络上的路由器。</li></ul><ul id="aac764f7-45ea-4e71-937f-a08f6e4cc085" class="bulleted-list"><li>然后此路由器在收到 IP 数据报后，再按目的网络号 net-id 和子网号 subnet-id 找到目的子网。</li></ul><ul id="5d29eb1d-ede6-42eb-89f9-41e692e088ea" class="bulleted-list"><li>最后就将 IP 数据报直接交付目的主机。</li></ul></li></ul></details></li></ul><ul id="0c330577-3037-4434-80ba-52adb393ceff" class="toggle"><li><details open=""><summary>划分子网的示例</summary><ul id="5aad0e42-499b-461f-9f02-060e0fdae2e6" class="toggle"><li><details open=""><summary>一个未划分子网的 B 类网络 145.13.0.0</summary><figure id="64211ab3-0322-415e-8165-aafd3f384ec3" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image22.png"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image22.png"/></a></figure></details></li></ul><ul id="c1bad5f1-c9f5-4aae-a8be-a19ade1c06ac" class="toggle"><li><details open=""><summary>划分为三个子网后对外仍是一个网络</summary><ul id="6bcda50b-919d-425b-9f7b-1450fe9e9217" class="bulleted-list"><li>当没有划分子网时，IP 地址是两级结构；<strong>划分子网后 IP 地址就变成了三级结构。</strong><figure id="a4a90497-ce64-4ebb-81b9-d2d65c4bfba9" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image23.png"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image23.png"/></a></figure></li></ul><ul id="a4af70c5-82db-4a58-bd49-be7bbaec5500" class="bulleted-list"><li>划分子网只是把 IP 地址的主机号 host-id 这部分进行再划分，而不改变 IP 地址原来的网络号net-id。</li></ul><ul id="ab7287e1-322b-42cf-ab1a-f94bfd4d4457" class="bulleted-list"><li>三个子网中均各有一个子网路由器，其管理每个子网的路由转发， 而 R1 只需要管理这个三个子网路由器的路由转发即可<strong>（分级转发）</strong>。</li></ul></details></li></ul><ul id="95b971ea-fd37-4f93-b226-540fa03831d9" class="toggle"><li><details open=""><summary>对所有子网主机的访问对外仍然表现为对 R1 的访问（对外隐藏）。</summary><p id="453efbc2-7615-4ae4-ab26-86b2328d8359" class="">
</p></details></li></ul></details></li></ul><ul id="a1a726dc-9fec-4883-a228-f4e35dccdb78" class="toggle"><li><details open=""><summary>C 类 IP 地址的子网划分示例</summary><p id="5d352f47-36f0-409b-9687-efbb69684c62" class="">将一个 C 类的 IPv4（前三个字节为网络部分）划分成 8 个子网，则需要从最后一个字节的主机部分划出前三位作为子网号</p><figure id="2b04cbd3-54fb-4019-b189-2638d1141560" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image24.png"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image24.png"/></a></figure></details></li></ul><ul id="899b4f57-198f-4bc4-a868-cbb6dc6e81c5" class="toggle"><li><details open=""><summary>注意——IP 流失问题：</summary><p id="dff44b19-4a73-4366-9398-a8117a7f27ff" class="">每个子网网段中的边界主机号均不能使用，即主机号为全 0 全 1 的均不能使用。这就导致，一个 IPv4 原本可以使用 <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>8</mn></msup><mo>−</mo><mn>2</mn><mo>=</mo><mn>254</mn></mrow><annotation encoding="application/x-tex">2^8-2=254</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">4</span></span></span></span></span><span>﻿</span></span> 个，划分 8 个子网后，仅能使用 <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>8</mn></msup><mo>−</mo><mn>16</mn><mo>=</mo><mn>240</mn></mrow><annotation encoding="application/x-tex">2^8-16=240</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">4</span><span class="mord">0</span></span></span></span></span><span>﻿</span></span> 个。子网的划分导致了 14 个 IP 的凭空流失。</p></details></li></ul><ul id="47b73dbe-e6dc-4ac5-a75f-7f118d390370" class="toggle"><li><details open=""><summary>子网掩码</summary><ul id="a7540715-eeb7-4f23-a830-da0641cda94c" class="toggle"><li><details open=""><summary><strong>引出</strong></summary><p id="ac103a80-ede7-4410-9013-9dbf3cb2c8c7" class="">从一个 IP 数据报的首部并无法判断源主机或目的主机所连接的网络是否进行了子网划分。使用子网掩码(subnet mask)可以找出 IP 地址中的子网部分。</p></details></li></ul><ul id="193dbb3b-f1ce-486d-bfa8-ef83a5669680" class="toggle"><li><details open=""><summary>原理</summary><p id="74bead26-4378-4faa-824b-8637831e1059" class="">(IP 地址) AND (子网掩码) =网络地址将一个 IP 和其对应的子网掩码进行按位与操作，得出的结果就是该 IP 对应的子网的网络地址，路由器就可以知道该 IP 在本网段还是仍需继续转发。</p><figure id="05318918-a936-4c3d-a2bf-3bb0eb869c6b" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image25.png"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image25.png"/></a></figure></details></li></ul><ul id="86d8910f-bd27-42d0-9139-95880dc22b5e" class="toggle"><li><details open=""><summary>示例</summary><figure id="dc8f0722-2884-4d1e-962d-7d3a9439714e" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image26.png"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image26.png"/></a></figure><p id="ae7417db-21f0-4e79-9973-c6e75d34c27a" class="">IP 为 145.13.3.10 的数据报， 查询路由器转发表后得知子网掩码为：255.255.255.0。两者按位与后，结果为 145.13.3.0，则该 IP 数据报应该递交给管理“145.13.3.0”网络地址的路由器进行分发（有可能就是本路由器或者仍需继续转发）。</p><p id="ff5ec15c-a3d8-43f7-a237-091c14f0b7fb" class="">实际应用中，将 host—id 中分出一部分作为子网地址，则实际上的子网掩码是在默认子网掩码的基础上加上添加的子网地址的掩码。</p><figure id="b56e2de3-39f3-4bdf-a51b-9803e0ed3aba" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image27.png"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image27.png"/></a></figure></details></li></ul><ul id="c26069c0-1ca4-4d29-bfa3-4319fbc968c7" class="toggle"><li><details open=""><summary>子网掩码的重要属性</summary><ul id="5746abcb-b8a6-4924-bdc6-918ab16958ef" class="bulleted-list"><li>子网掩码是一个网络或一个子网的重要属性。</li></ul><ul id="673900cc-c914-4d75-98b6-96f21d2b999d" class="bulleted-list"><li>路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。</li></ul><ul id="4bfc6d34-f26e-4fc7-aebf-4b1e51bd6d08" class="bulleted-list"><li>路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。</li></ul><ul id="780687ea-4364-4953-b005-b4c92b74297a" class="bulleted-list"><li><strong>若一个路由器连接在两个子网上就拥有两个网络地址和两个子网掩码。</strong></li></ul></details></li></ul><ul id="e8b938cc-cfe4-4e89-ab65-de0f0761db71" class="toggle"><li><details open=""><summary><strong>子网掩码的示例</strong></summary><p id="eab365ae-6a03-4786-b82a-9aa0e680c1f4" class="">已知 IP 地址是 141.14.72.24，子网掩码是 255.255.192.0。试求网络地址。</p><figure id="cda2d514-775d-49d8-a6b8-1b56f2d1a76c" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image28.png"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image28.png"/></a></figure><p id="fd19d22b-75b2-4db4-bb25-6eb65246fdd4" class="">经过计算分析可知，该 IP 肯定是 B 类地址，该网段的 IP 为 141.14.64.0/18， 该网段下共有可用主机 IP 有 <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>14</mn></msup><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2^{14}-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></span><span>﻿</span></span> 个；在上例中，若子网掩码改为 255.255.224.0。试求网络地址，讨论所得结果。不同的子网掩码得出相同的网络地址。但不同的掩码的效果是不同的。该网段下共有可用主机 IP 有 <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>13</mn></msup><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2^{13}-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></span><span>﻿</span></span> 个。</p><p id="15d32f88-805f-4f61-84f6-f10f712bec7a" class="">（因为子网掩码全0全1都无效，因此看全0的位数得到结果）</p><figure id="5a07a53b-864e-4f15-9efe-d1d9f391e23a" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image29.png"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image29.png"/></a></figure></details></li></ul></details></li></ul></details></li></ul><ul id="7e7d536b-4a00-4db0-b76d-cff0b7c02b3c" class="toggle"><li><details open=""><summary>使用子网掩码的分组路由转发过程<mark class="highlight-red">（重点 有原题）</mark></summary><ul id="d41fbcf8-f212-4e6b-b441-24c5803f7044" class="toggle"><li><details open=""><summary>引出</summary><p id="687e5111-2cb0-4958-9702-ef6766d18aff" class="">在不划分子网的两级 IP 地址下，从 IP 地址得出网络地址是个很简单的事。但在划分子网的情况下，从 IP 地址却不能唯一地得出网络地址来，这是因为网络地址取决于那个网络所采用的子网掩码，但数据报的首部并没有提供子网掩码的信息。因此分组转发的算法也必须做相应的改动。</p></details></li></ul><ul id="029d8752-5ff6-432b-b517-02590ac7d53f" class="toggle"><li><details open=""><summary>IP 层转发分组的流程</summary><p id="447e61ea-d09f-48a8-8928-d738a7ace206" class="">假设有四个 A 类网络通过三个路由器连接在一起。每一个网络上都可能有成千上万个主机：</p><ul id="c0df0d8c-3912-418e-9438-34b729ebdeb7" class="bulleted-list"><li>若按目的主机号来制作路由表，则所得出的路由表就会过于庞大；</li></ul><ul id="bbaccf34-3aca-453a-82af-fcc8332d3f0f" class="bulleted-list"><li>若<strong>按主机所在的网络地址来制作路由表</strong>，那么每一个路由器中的路由表就只包含 4 个项目。这样就可使路由表大大简化；<figure id="1cc697df-d4e8-42a9-8035-4afabb7a0fe0" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image30.png"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image30.png"/></a></figure></li></ul><p id="bd80870c-705d-432c-bfc0-c4dc34428531" class="">由上图可知，根据目的网络地址就能确定下一跳路由器，这样做的结果是：</p><ul id="f6489938-6054-48ab-b1aa-dfeecb8cb366" class="bulleted-list"><li>IP 数据报最终一定可以找到目的主机所在目的网络上的路由器（可能要通过多次的间接交付）。</li></ul><ul id="58993e8c-4c26-4573-bc7c-0e6707ac4abd" class="bulleted-list"><li>只有到达最后一个路由器时，才试图向目的主机进行直接交付。</li></ul></details></li></ul><ul id="e4b009de-03f1-4659-95dd-458ce435cf19" class="toggle"><li><details open=""><summary>路由转发的特殊名词</summary><ul id="d1b5c2a1-1561-44d3-b3c5-9cab3eab5bde" class="bulleted-list"><li><strong>特定主机路由</strong><p id="07906c16-4a8a-459d-87f5-efcd54c4f5aa" class="">这种路由是系统管理员为特定的目的主机指明一个路由。处于某种特殊的考虑，针对具有特定目的网络地址的 IP 数据报，指定特定的下一跳路由。这样该数据报使用的转发线路就是管理员自定义的而不是根据路由算法算出的路径转发。</p></li></ul><ul id="2564a9b7-675d-47b6-b5e8-e19c9d06a34b" class="bulleted-list"><li>默认路由<p id="a8115965-73ce-49bf-9a13-dd724d28fa48" class="">路由器还可采用默认路由以减少路由表所占用的空间和搜索路由表所用的时间。这种转发方式在一个网络只有很少的对外连接时是很有用的。默认路由在主机发送 IP 数据报时往往更能显示出它的好处。如果一个主机连接在一个小网络上，而这个网络只用一个路由器和因特网连接，那么在这种情况下使用默认路由是非常合适的。</p><figure id="8e676191-eca2-4aef-94b5-e66493d46ad4" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image31.png"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image31.png"/></a></figure><p id="699a9c55-46ae-4726-b7f8-917af3f69fc5" class=""><mark class="highlight-red">实际上，默认路由是为那些本机路由器 A 的路由算法算不出下一跳的 IP 数据报指定一个路由器 B，让其在路由器 B 上尝试计算。</mark></p></li></ul></details></li></ul><ul id="d754b709-f090-489c-b8b1-4805688efad3" class="toggle"><li><details open=""><summary>路由转发的注意点</summary><ul id="534ec07f-3ce3-483b-9d30-c3a2f4321343" class="bulleted-list"><li>IP 数据报的首部中没有地方可以用来指明“下一跳路由器的 IP 地址”。</li></ul><ul id="416c2ee3-4fa4-4760-a09d-4f161415a413" class="bulleted-list"><li>当路由器收到待转发的数据报，<strong>不是将下一跳路由器的 IP 地址填入 IP数据报</strong>，而是送交下层的数据链路层。</li></ul><ul id="c9b92e13-9808-4cad-8933-9ec5ce69523e" class="bulleted-list"><li>数据链路层使用 ARP 协议负责将下一跳路由器的 IP 地址转换成硬件地址，并<strong>将此硬件地址放在链路层的 MAC 帧的首部，然后根据这个硬件地址找到下一跳路由器</strong>。</li></ul><p id="ef5e5cc5-7b1a-4506-8489-68332c7a78a4" class="">下一跳的目的主机寻址是通过 MAC 寻址的而不是通过修改 IP 数据报中的IP 地址寻址。</p></details></li></ul><ul id="e66e83c6-3377-4082-923d-c3e8fe86799c" class="toggle"><li><details open=""><summary><strong>路由分组转发算法（重点）</strong></summary><ol id="a9a0fbe7-db8e-4bcd-a191-2fe9fc292c85" class="numbered-list" start="1"><li>从数据报的首部<strong>提取目的主机的 IP 地址 D</strong>，根据路由器中存储的 IP 地址对应的<strong>子网掩码和 D 进行按位与</strong>，<strong>得出目的网络地址为 N</strong>。<ul id="4cf8bd06-f46f-448b-85f8-a4016d7ce72e" class="bulleted-list"><li><strong>可以在此做分组过滤</strong>，对一些特定的目的主机 IP 指定路由黑洞或直接销毁该访问不安全 IP 的分组；</li></ul></li></ol><ol id="24643d61-2b72-4bf1-84e5-31bbf830c886" class="numbered-list" start="2"><li>若网络 N 与此路由器直接相连，则把数据报直接交付目的主机 D；否则是间接交付，执行(3)。<ul id="d76a2496-716e-4261-8b99-fc812817856a" class="bulleted-list"><li>查看是否是到达了目的网络 N 的最终的目的路由器；</li></ul></li></ol><ol id="96d5fc6c-a545-499d-8c49-a962d84a797c" class="numbered-list" start="3"><li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行(4)。<ul id="2a262ee0-df17-454e-a2d0-165b58a2d2a6" class="bulleted-list"><li>查看该路由器的系统管理员有没有指定特定主机路由；</li></ul></li></ol><ol id="56080f4b-eac2-4c3d-a3b8-3010f583fc27" class="numbered-list" start="4"><li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表指明的下一跳路由器；否则，执行(5)。<ul id="9f4890c0-d8be-455c-a96f-95cdf12db94d" class="bulleted-list"><li>若没有指定特定的主机路由，则使用路由器转发算法算出的下一跳；</li></ul></li></ol><ol id="4209662c-f29a-49a1-b394-3673f7ee34e7" class="numbered-list" start="5"><li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行(6)。<ul id="c260b276-39b4-4749-afa8-ef5749024077" class="bulleted-list"><li>若算不出来，则使用指定的默认路由器；</li></ul></li></ol><ol id="3b87ea5f-26bb-45db-a449-74f5cc8914fb" class="numbered-list" start="6"><li>报告转发分组出错。<ul id="d142099b-7856-4867-8354-805ae3157f83" class="bulleted-list"><li>若算不出来，且没有指定默认路由，则报错；</li></ul></li></ol></details></li></ul><ul id="47f4f7ab-3873-49d8-b223-b2836add7356" class="toggle"><li><details open=""><summary><strong>路由分组转发算法的示例（重点 原题）</strong></summary><p id="6632b993-8fff-4176-b954-ac6848d731a1" class="">已知互联网和路由器 R1 中的路由表。主机 H1:128.30.33.13 向 H2 ：128.30.33.138 发送分组。试讨论 R1 收到 H1 向 H2 发送的分组后查找路由表的过程。<div class="indented"><figure id="e5d12e12-d0b7-40f5-9ef9-abb46fb86ad4" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image32.png"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image32.png"/></a></figure><ul id="ad4e6d30-8cf1-43d3-99e2-66493ce1c8f9" class="bulleted-list"><li>H1 首先检查目的主机 128.30.33.138 是否连接在本网络上：<ul id="9125ac12-ef4f-4e73-86da-18667bc70356" class="bulleted-list"><li>将本机 IP 128.30.33.13 和目的 IP 128.30.33.138 分别和本网段的子网掩码 255.255.255.128 按位与，得出两个 IP 的网络地址为：128.30.33.0 和 128.30.33.128，说明目的主机不在该网段，需要路由器转发；</li></ul><ul id="7688b810-8e9d-4e99-8bb5-f510d25fe125" class="bulleted-list"><li>若计算后得出的网络地址一致，则可以直接点对点交付；</li></ul></li></ul><ul id="ed083a81-aae1-472d-a5eb-05a617a3eb65" class="bulleted-list"><li>数据报经主机 H1 中 ARP 表中存储的默认网络 MAC 地址，投递到网关路由器 R1：<ul id="a595b8cb-d9de-49d9-86f4-3118a455b25c" class="bulleted-list"><li>若 H1 未知 R1 的 MAC，则应该使用 ARP 广播包的情况进行查询；</li></ul><ul id="36cebc8f-4c1a-4b11-abfc-67b0723ba779" class="bulleted-list"><li>路由器 R1 接收到数据报后，在数据链路层获取目的 IP 后，将其<strong>与</strong>R1 路由表中的所有子网掩码相与，得到的所有网络地址按照最长前缀匹配原则在路由表中进行匹配，查询该数据报对应的路由器出口；</li></ul></li></ul><ul id="3b6a5969-e985-4ad7-b3d0-7b96b2211ba6" class="bulleted-list"><li><strong>数据报经路由器 R1 的接口 1 发出，判读接口 1 所处的子网是否为目的子网：</strong><ul id="3381e70f-7b9c-4da8-a784-a00d79dcff49" class="bulleted-list"><li>将端口 1 的 IP 128.30.33.130 和目的 IP 128.30.33.138 分别和端口1 的子网掩码 255.255.255.128 按位与，得出两个 IP 的网络地址为：128.30.33.128 和 128.30.33.128，说明目的主机在本网段中，可以直接点对点递交；</li></ul><ul id="5bf75543-0013-4e69-9f44-6489313a79f2" class="bulleted-list"><li>若计算后得出的网络地址不一致，则继续发送到下一跳路由器进行转发；</li></ul></li></ul><ul id="3d9dcb8b-1d6b-4acf-ae80-fe52bb559d52" class="bulleted-list"><li>路由器 R1 向主机 H2 点对点递交的时候，需要知道 H2 的 MAC 地址：<ul id="e558614d-b7bc-454d-b472-8f66940d5709" class="bulleted-list"><li>若未知，则应使用 ARP 广播查询；</li></ul><ul id="2044cf44-e17b-4fd3-a512-7dbea82841c3" class="bulleted-list"><li>若已知，封装 IP 数据报的源 MAC 为端口 1 的MAC 地址，目的 MAC为主机 H2 的 MAC 地址；</li></ul></li></ul></div></p></details></li></ul></details></li></ul><ul id="47a6fe4d-a51b-432f-8b34-4c2f4e145363" class="toggle"><li><details open=""><summary>无差别域间路由选择—CIDR（概念了解）</summary><ul id="8cc7e93a-07b0-4e53-8e61-da4ec05d0c3d" class="toggle"><li><details open=""><summary>子网概述</summary><p id="f772cb31-6dbb-4593-94ce-b87d8ebf8f8b" class="">在全球因特网中的每台主机和路由器上的每个接口，必须有一个全球唯一的IP 地址。然而，这些地址不能随意地自由选择。一个接口的 IP 地址的一部分需要由其连接的子网来决定。</p><p id="8344c8fd-2206-4d3c-8362-b37a235e3183" class="">例如：</p><figure id="251e234b-e8f8-406d-84b5-9991c23ab426" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image33.jpeg"><img style="width:502px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image33.jpeg"/></a></figure><p id="d6e36a79-e296-4def-8e07-566e99704cec" class="">最左侧：互联这 3 个主机接口与 1 个路由器接口的网络形成一个子网（sub-net）。IP 编址为这个子网分配一个地址：223.1.1.0/24，其中的/24 记法， 有时称为子网掩码（network mask）， 指示了 32 比特中的最左侧 24 比特定义了子网地址。因此子网223.1.1.0/24 是由 3 台主机接口（223.1.1.1、223.1.1.2和 223.1.1.3）和 1 个路由器接口（223.1.1.4）组成。任何其他要连到 223.1.1.0/24 网络的主机都要求其地址具有 223.1.1.xxx 的形式。同理， 另外两个网络：223.1.2.0/24 网络与 223.1.3.0/24 子网。</p><p id="aa8d4e57-e163-4bc5-b44c-56ee9469b740" class="">再例如：为了确定子网，分开主机和路由器的每个接口，产生几个隔离的网络岛，使用接口端接这些隔离的网络的端点。 这些隔离的网络中的每一个都叫做一个子网（subnet）。如右图中，有六个网络岛：</p><figure id="1165985e-de94-4133-acaa-ae820f8cbced" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image34.jpeg"><img style="width:459px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image34.jpeg"/></a></figure></details></li></ul><ul id="fff3510a-a51e-4553-87c7-3689f39db70c" class="toggle"><li><details open=""><summary>CIDR 的定义</summary><p id="02065b71-5e1e-41b1-afca-a9e19b3771d9" class="">CIDR 将子网寻址的概念一般化。形式为𝑎. 𝑏. 𝑐. 𝑑/𝑥的地址的 x 最高比特构成了 IP 地址的网络部分，并且经常被称为该地址的前缀（prefix）（或网络前缀）。在域间划分时，子网号被固定，子网下可用主机数是固定的。而 CIDR 下的子网 IP 划分是可以根据子网中的主机数量，调整 IP 地址的网络部分的长度，即通过 X 值代表的子网掩码为 1 的位数进行表示。</p></details></li></ul><ul id="e04ae710-af55-45fb-be1e-faa95b61531a" class="toggle"><li><details open=""><summary>示例</summary><figure id="1aae4ac7-2781-4820-97d0-cd3c3a050b3c" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image35.png"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image35.png"/></a></figure><p id="f074ba64-314f-47e1-9f05-aa6e19f21250" class="">某大学从网络运营商购买一个网段 206.0.68.0/22，将该网段划分为拥有不同主机数的四个院系级别的 IP 地址块，院系级别的又进行子网划分。由于采取的 CIDR 的域间划分方法，大学 X 的路由器仅需维护四个院系的网络地址，院系级别的子网网络地址由院系级别的路由器维护，与大学 X 路由器无关。</p></details></li></ul><ul id="1b74d3df-6947-476b-9c5d-9127581ab8aa" class="toggle"><li><details open=""><summary>地址聚合/路由聚合</summary><figure id="981ea821-452d-451f-9689-f652245ef3f0" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image36.jpeg"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image36.jpeg"/></a></figure><p id="5154ef3d-1b2c-4a57-a0e2-5bbc20775eac" class="">外界的其他部分不需要知道在地址块 200.23.16.0/20 内实际上还存在 8 个其他组织，每个组织有自己的子网。这种使用单个网络前缀通告多个网络的能力通常称为地址聚合（address aggregation）。</p><p id="23f52a78-c53c-49eb-a9fd-b802b1904b62" class="">当Fly-By-Night-ISP 下的组织1 要携带 IP 转网，则仅需删除 Fly-By- Night-ISP 路由器转发表中的相关记录，而在 ISPs-R-Us 的路由器中指定相关 IP 的特定路由。</p></details></li></ul></details></li></ul><ul id="d749987d-d48a-4213-9fb0-bb23eec73493" class="toggle"><li><details open=""><summary>动态主机配置协议：DHCP</summary><ul id="e1d13d43-f985-4aa6-8173-0ae38fd653d6" class="toggle"><li><details open=""><summary>引出</summary><p id="bd63919c-5e28-4aac-80fd-09e3636d13a1" class="">某组织一旦获得了一块地址，它就可为本组织内的主机与路由器接口逐个分配 IP 地址。分配方式有：系统管理员手工依次分配、使用动态主机配置协议动态分配。</p></details></li></ul><ul id="84980434-cd29-441a-b9d4-80d397032ec2" class="toggle"><li><details open=""><summary>定义</summary><p id="eb8289c4-3c61-4fe4-bbfe-19792dc874dd" class="">DHCP 允许主机自动获取（被分配）一个 IP 地址：</p><ul id="1476b253-89be-4872-87bf-d582de6a1375" class="bulleted-list"><li>网络管理员能配置 DHCP，以使某给定主机每次与网络连接时能得到一个相同IP地址；</li></ul><ul id="8180565d-f252-4e80-8b5f-e60b290e816b" class="bulleted-list"><li>某主机将被分配一个<strong>临时的 IP 地址（temporary IP address）</strong>， 该地址在每次与网络连接时也许是不同的；</li></ul><p id="cd9f4b7b-910f-453b-a749-4beaca699fc3" class="">除了主机 IP 地址分配外，DHCP 还允许一台主机得知其他信息：它的子网掩码、它的第一跳路由器地址（常称为默认网关）与它的本地 DNS 服务器地址。</p></details></li></ul><ul id="84f14dd7-8525-4f2a-b9be-55b012dac3c7" class="toggle"><li><details open=""><summary>工作原理</summary><figure id="260c1be2-f995-4e00-a5b2-721b9793ce99" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image38.jpeg"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image38.jpeg"/></a></figure><p id="73a04484-d78d-4826-b63b-be0f7e55ffe6" class="">上图中有一台连接到子网 223.1.2.0/24 的DHCP 服务器，为该子网提供 DHCP服务，当一台新的主机接入子网 223.1.2.0/24 中，DHCP 协议有四个步骤：</p><figure id="2f41978f-38c4-4199-955a-3a5f56f42e74" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/Untitled%201.png"><img style="width:576px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/Untitled%201.png"/></a></figure><ul id="ea57bec1-8cbb-40f7-91ff-562fbff91419" class="bulleted-list"><li><strong>DHCP 服务器发现</strong><p id="7fe784bc-9208-4724-b312-a319705bcf78" class="">新加入网络的主机，通过使用一个 DHCP 发现报文（DHCP discover message）来发现可以提供 DHCP 服务的服务器。客户在 UDP 分组中从端口 67 发送该发现报文。由于主机未知它所连接网络的 IP 地址及该子网的 DHCP 服务器地址，则使用广播目的地址<mark class="highlight-red">255.255.255.255</mark> ， 并且使用<mark class="highlight-red">0.0.0.0 </mark>作为“本主机”源地址，同理 <mark class="highlight-red">𝒚𝒊𝒂𝒅𝒅𝒓表示的本机可用 IP </mark><mark class="highlight-teal">（就是提供的ip）</mark>也为DHCP 客户将该IP 数据报传递给链路层，链路层然后将该帧广播到所有与该子网连接的子网.</p></li></ul><ul id="ec3ad8b7-2432-4fb8-9102-9197aa5929fe" class="bulleted-list"><li><strong>DHCP 服务器提供</strong><p id="f9065a06-61c5-4d04-a0d5-51b929b24ef5" class="">DHCP 服务器收到一个 DHCP 发现报文时，用一个 DHCP 提供报文（DHCP offer message）向客户作出响应。<mark class="highlight-red">由于源主机的 IP 是虚拟的，因此“DHCP 提供报文”仍然使用 IP 广播地址 255.255.255.255 作为报文的目的地址。</mark></p><p id="278df33b-63a4-49bb-93cc-c020ba781ff1" class="">因为新主机发送的“DHCP 发现报文”可能会被子网中存在的多个 DHCP 服务器接收，从而会有多个“DHCP 提供报文”相应。因此，每台服务器提供的报文包含有收到的发现报文的事务 ID、向客户推荐的 IP 地址、子网掩码以及 IP 地址租用期，即 IP 地址有效的时间量。</p></li></ul><ul id="d867fd96-7725-4402-aece-b6d9d1b02f43" class="bulleted-list"><li><strong>DHCP 请求</strong><p id="91e631c9-09ec-419b-a0ee-b990f5772ec5" class="">新到达的客户从一个或多个“DHCP 提供”中选择位置最优的一个，并向选中的服务器提供用一个 DHCP 请求报文（DHCP request message）进行响应，回显配置参数。</p></li></ul><ul id="9c47dd85-0498-49b0-8c8b-3948b1e49ab8" class="bulleted-list"><li><strong>DHCP ACK</strong><p id="17965350-a987-44ca-abbd-03bf76530867" class="">服务器用 DHCP ACK 报文（DHCP ACK message）对 DHCP 请求报文进行响应，证实所要求的参数。一旦客户收到 DHCPACK 后，交互便完成了，并且该客户能够在租用期内使用DHCP 分配的IP 地址。因为客户可能在该租用期超时后还希望使用这个地址， 所以 DHCP 还提供了一种机制以允许客户更新它对一个 IP 地址的租用。</p></li></ul></details></li></ul></details></li></ul><ul id="736c8d55-6aa5-416f-9d81-235e21e1487c" class="toggle"><li><details open=""><summary>网络地址转换：NAT</summary><ul id="7f38a393-aea0-4037-b67f-b5c40929ff4a" class="toggle"><li><details open=""><summary>引出</summary><p id="03b27a23-d3e7-4cdc-a065-18d622cbe464" class="">一个子网中有众多用户想要上网，但是分配的 IP 很少，不能满足需求。如下图中，右侧的子网中有多台主机想要上网，但只有一个 IP 地址：138.76.29.7.</p><figure id="090c9772-076d-46b4-ae7c-07c36d357da1" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image40.png"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image40.png"/></a></figure></details></li></ul><ul id="ed4d6a7d-8cba-47f7-87bd-8c3723c1fd0d" class="toggle"><li><details open=""><summary>定义</summary><p id="53d939c1-5998-4778-b4ad-c6dd632c9046" class="">如上图所示，在内网中使用虚拟的 IP 地址作为主机地址，当经过本地路由器对外网进行访问时，需要将 IP 数据报的源 IP 和源端口号替换后发出，并且该替换记录需要在 NAT 表中记载。</p></details></li></ul><ul id="89179999-577d-49ca-a18e-d1268adf12a4" class="toggle"><li><details open=""><summary>优点</summary><ul id="ad67f582-d617-46b7-ace0-01620fba8726" class="bulleted-list"><li>无需从网络运营商 ISP 中获取大量的 IP 地址即可进行网络通信；</li></ul><ul id="fc906818-eb47-4580-a6ca-b36b48af6a4e" class="bulleted-list"><li>内网中的虚拟 IP 的更换无需向外界通知；</li></ul><ul id="896b7e4e-1312-49e0-96e6-7cfadf14666d" class="bulleted-list"><li>路由器连接外层的接口更换（路由器连接的 ISP 更换）不会影响到内网；</li></ul><ul id="97ec1544-cceb-4364-973c-56477b3a8fa9" class="bulleted-list"><li>外侧的网络对于内网的拓扑结构是不可视的，外部视该内子网为使用一个 IP 的主机，安全性高；</li></ul></details></li></ul><ul id="a7b4dda5-8ac8-411b-afe0-564635c52779" class="toggle"><li><details open=""><summary>工作过程</summary><figure id="5e1f094e-73d4-4591-8189-8f0ab36c0071" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image41.png"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image41.png"/></a></figure><ul id="5a6b6753-2064-46cb-bc0e-c7467fa88b3e" class="bulleted-list"><li><strong>更改源端口号的原因：</strong></li></ul><p id="e777ca59-edd2-4070-b420-f7ce59fe1a16" class="">内网中的多个主机递交的数据报的源端口号可能重复，因此为了避免冲突发生，NAT 协议统一管理真实的端口号，统一分配，避免了冲突。</p></details></li></ul><ul id="d285634b-e7de-48e3-bd13-534556c58433" class="toggle"><li><details open=""><summary>性能优化</summary><p id="cb71a6cb-049b-4c5c-a844-f2a67fd85fcd" class="">当内网中的主机数量过多时，NAT 仅使用一个外网 IP 通信效率较低，则使用 DHCP 再动态获取多个 IP，令 NAT 能够均衡的使用多个 IP 进行外网访问。DHCP 做到了 IP 分配的动态平衡，NAT 实现了使用一个 IP 应对多个用户的对外访问。</p></details></li></ul><ul id="38e5b8b8-a29e-4f95-9221-9f7f246171b7" class="toggle"><li><details open=""><summary>问题（了解）</summary><figure id="d606a5d3-6d22-4cf7-ba4c-59bde292b1ad" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image42.png"><img style="width:432px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image42.png"/></a></figure><p id="a8c4315c-c1f1-40e8-8187-b4ed3b8d07df" class="">当位于外网上的一台客户机client 想要访问内网中的一台服务器（10.0.0.1），但是只有 NAT 可视化的外网 IP138.76.29.7 才能被 client 访问，如何解决？</p><ul id="59a46497-d3b6-4276-afaf-a55371667efd" class="bulleted-list"><li>方案 1：静态配置 NAT 以将给定端口上的传入连接请求转发到服务器<p id="25151705-fe1b-4192-b721-11635c28bb16" class="">例如，对 123.76.29.7, port 25000 的访问默认的连接到 10.0.0.1 port 25000</p></li></ul><ul id="13fe1e76-41de-48fd-a9a3-ffa3fdd08c70" class="bulleted-list"><li>方案 2：通用即插即用（UPnP）Internet 网关设备（IGD）协议<figure id="9e5719d8-b34d-4aa5-8240-f2ab6fcf3bb8" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image43.png"><img style="width:410px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image43.png"/></a></figure><p id="00ae501b-2ce3-437e-a857-9e221a7edde2" class="">UPnP 是一种允许主机发现并配置邻近 NAT 的协议。</p><p id="907c7d6f-77ce-46a0-9ae7-d2b57e9a18ce" class="">使用 UPnP，能够为某些请求内网通信的请求一个 NAT 映射，该映射位于其（虚拟 IP 地址，虚拟端口号）和（公共 IP 地址，公共端口号）之间。如果某 NAT 接受该请求并生成映射，则来自外部的结点能够发起到（公共 IP 地址，公共端口号）的 TCP 连接。</p></li></ul><ul id="37a2f16a-8b6f-4526-a04b-e4efe8401bd8" class="bulleted-list"><li>方案 3：中继（在 Skype 中使用）<ul id="5b75804f-4914-4b24-aa0b-a42725472639" class="bulleted-list"><li>NAT 客户端建立连接中继</li></ul><ul id="6fc1bba4-1786-4439-8032-cc36a92199df" class="bulleted-list"><li>外部客户端连接中继</li></ul><ul id="5c5fcbf3-98f5-4a09-93fd-88965f9ab0e3" class="bulleted-list"><li>中继将数据包桥接到连接之间<figure id="278c9fbb-d408-4c3b-9fb8-32eb51a4c25d" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image44.png"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image44.png"/></a></figure></li></ul></li></ul><figure id="0e1d3325-1f33-4e8c-92b9-9bf9cbd9e228" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/Untitled%202.png"><img style="width:1221px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/Untitled%202.png"/></a></figure></details></li></ul></details></li></ul><ul id="aaad0771-27e2-4e51-825c-bec22adad420" class="block-color-teal toggle"><li><details open=""><summary>ICMP（了解）</summary><ul id="401b4138-0b79-41da-8d44-8912ff4046ce" class="toggle"><li><details open=""><summary>概述</summary><ul id="74112507-1f7c-4b04-9e79-7fd6d8b6bbd1" class="bulleted-list"><li>定义<p id="22de32b0-6c3c-48d4-a52a-1b56901cd9b3" class="">被主机和路由器用来彼此沟通网络层的信息</p></li></ul><ul id="368a66b2-88ec-4e41-b6c5-21495ffc8011" class="bulleted-list"><li>典型用途<p id="800d8782-9926-460d-9053-3950ad61ece1" class="">ICMP 最典型的用途是差错报告。例如：</p><ul id="3b3498c1-0424-4ae7-b958-a675c0c41e00" class="bulleted-list"><li>在某个位置，IP 路由器不能找到一条路径，以通往 Telnet、FTP 或HTTP 应用所指定的主机。该路由器就会向你的主机创建和发出一个诸如“目的网络不可达”之类的错误报文；</li></ul><ul id="eb14377f-da90-4704-8aec-389195e7db61" class="bulleted-list"><li>还被用于 Ping 程序发送 ICMP 类型 8 编码 0 的回显（echo）请求</li></ul></li></ul></details></li></ul><ul id="d292a8d7-64e8-494d-8d63-32268c370af9" class="toggle"><li><details open=""><summary>层级定位</summary><p id="639b196b-7ea6-42d0-aba2-480d0746c4ff" class="">ICMP 通常被认为是 IP 的一部分，但从体系结构上讲它是位于 IP 之上的， 因为 ICMP 报文是承载在 IP 分组中的。这就是说，ICMP 报文是作为 IP 有效载荷承载的，就像 TCP 与 UDP 报文段作为IP 有效载荷被承载那样。类似地，当一台主机收到一个指明上层协议为 ICMP 的 IP 数据报时，它分解出该数据报的内容给 ICMP，就像分解出一个数据报的内容给 TCP 或 UDP 一样。</p><figure id="f3eb639d-c153-43d2-8b02-78fae10d668b" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image45.jpeg"><img style="width:513px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image45.jpeg"/></a></figure></details></li></ul><ul id="4ff03a4d-8023-482c-8780-ecc4a2932e57" class="toggle"><li><details open=""><summary>ICMP 报文结构</summary><p id="1eb55c29-5d86-4494-a0c3-a1a4f791152f" class="">ICMP 报文有一个类型字段和一个编码字段，并且包含引起该 ICMP 报文首次生成的IP 数据报的首部和前 8 字节内容（以便发送方能确定引发该差错的数据报）。注意到 ICMP 报文并不仅是用于通知差错情况。</p></details></li></ul><ul id="5403047d-a209-4df8-a4c9-2aa47c8a0f55" class="toggle"><li><details open=""><summary>ICMP 和 Traceroute 命令</summary><ul id="a1a187b0-e3ef-4d4a-8da8-ea9a8096e69e" class="toggle"><li><details open=""><summary>回顾</summary><p id="657530d4-25d4-452e-9261-b3038658d839" class="">在第 1 章中提及的 Traceroute 程序，该程序允许我们跟踪从一台主机到世界上任意一台其他主机之间的路由。其中，Traceroute 是用 ICMP 报文来实现的。</p></details></li></ul><ul id="3a540abd-f321-401e-b163-02573fdd3f90" class="toggle"><li><details open=""><summary>实现原理</summary><ul id="2f53cf07-1367-438e-b6b4-12aecbab5254" class="bulleted-list"><li>为了判断源和目的地之间所有路由器的名字和地址，源主机中的Traceroute 向目的主机发送一系列普通的 IP 数据报：<ol id="abf07715-83d6-48ec-a1a4-6dfff82d2252" class="numbered-list" start="1"><li>这些数据报的每个携带了<strong>具有一个不可达 UDP 端口号的 UDP</strong>报文段；</li></ol><ol id="a5a3ba50-1c32-4515-b6b7-99130e7b6ea0" class="numbered-list" start="2"><li>第一个数据报的 TTL 为 1，第二个的 TTL 为 2，第三个的 TTL 为3，依次类推；</li></ol><ol id="65e81d18-f384-4acc-ab82-9499434b06ed" class="numbered-list" start="3"><li>该源主机也为每个数据报启动定时器；</li></ol></li></ul><ul id="52cbce2e-5d3e-4f18-bcde-4e60e2e8c58c" class="bulleted-list"><li>当第 n 个数据报到达第 n 台路由器时，第 n 台路由器观察到这个数据报的 TTL 正好过期：<ol id="1555bc28-30c1-430b-8658-a1e89ac94203" class="numbered-list" start="1"><li>根据 IP 协议规则，路由器丢弃该数据报并发送一个 ICMP 告警报文给源主机（类型 11 编码 0）；</li></ol><ol id="632c70f6-3c78-4a14-9cca-d1e59003620e" class="numbered-list" start="2"><li>该告警报文包含了路由器的名字与它的 IP 地址；</li></ol></li></ul><ul id="6e9c9434-35b5-4f0f-a144-8c2bc0b3a37e" class="bulleted-list"><li>当该 ICMP 报文返回源主机时，源主机从定时器得到往返时延，从ICMP 报文中得到第 n 台路由器的名字与 IP 地址。</li></ul></details></li></ul><ul id="bdcb393e-bbbd-456d-b84e-29768dcc1be5" class="toggle"><li><details open=""><summary>Traceroute 源主机停止发送 UDP 报文段的机制</summary><p id="a3b981a7-d57c-4862-800d-dc7049cc40cf" class="">Traceroute 源主机发送的数据报之一将最终沿着这条路到达目的主机。因为该数据报包含了一个具有不可达端口号的 UDP 报文端，该目的主机将向源发送一个端口不可达的ICMP 报文。当源主机收到这个特别的 ICMP 报文时， 知道它不需要再发送另外的探测分组。</p></details></li></ul><ul id="0103861a-73b8-4fdf-8bcc-f2c4a6194719" class="toggle"><li><details open=""><summary>实际应用</summary><p id="3f2e323c-28e5-4407-a23e-87303e9bf197" class="">标准的 Traceroute 程序实际上用相同的 TTL 发送 3 个一组的分组；因此Traceroute 输出对每个 TTL 提供了 3 个结果。以这种方式，源主机知道了位于它与目的主机之间的路由器数量和标识，以及两台主机之间的往返时延。</p></details></li></ul></details></li></ul></details></li></ul><ul id="e49684fa-498b-47b4-8178-bc4a1cae45ad" class="block-color-teal toggle"><li><details open=""><summary>IPv6（了解）</summary><ul id="d814da9e-59aa-4320-a51c-744db3a0f719" class="toggle"><li><details open=""><summary>发展动机</summary><ul id="0cc6f402-0b6a-4eea-b086-d9355ba71d9c" class="bulleted-list"><li>最初的动机是，即将完全分配 32 位地址空间，未来将无 IP 地址可用；</li></ul><ul id="877590e3-b58f-4d10-be74-f0b649665795" class="bulleted-list"><li>其他动机：<ul id="064db169-3ee4-4e5a-904c-cfdb7c30d07d" class="bulleted-list"><li>标头格式有助于加快处理/转发速度</li></ul><ul id="e191896e-78e2-48ae-bebe-92ce9baf84dd" class="bulleted-list"><li>标头更改以促进 QoS</li></ul></li></ul></details></li></ul><ul id="64b6b8d3-09d0-4ece-9dcb-2b4f9d68d876" class="toggle"><li><details open=""><summary>IPv6 数据报格式</summary><figure id="300ceffd-4cf3-4f2e-9eef-ac8f81e6d720" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image46.jpeg"><img style="width:573px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image46.jpeg"/></a></figure><ul id="ed43c4f3-6bd2-40e3-9284-f896c3ce4e78" class="toggle"><li><details open=""><summary><strong>显著变化</strong></summary><figure id="e8f4b368-781d-472b-bcd1-46031261f7c8" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image47.jpeg"><img style="width:430px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image47.jpeg"/></a></figure><ul id="c193a8a3-0699-4a13-9891-fad5709951b1" class="toggle"><li><details open=""><summary>扩大的地址容量：</summary><p id="3f036b34-b983-4f0e-afca-df9392c212a0" class="">IPv6 将 IP 地址长度从 32 比特增加到 128 比特。</p></details></li></ul><ul id="7a3aaf6b-f22c-49e4-9ae8-f8d030b79eb8" class="toggle"><li><details open=""><summary>简化高效的 40 字节首部：</summary><p id="baf45303-0af6-4c56-9c9a-462545f6ac8e" class="">所形成的 40 字节定长首部允许更快地处理 IP 数据报。一种新的选项编码允许进行更灵活的选项处理。</p></details></li></ul><ul id="afcf7f05-7324-4f59-bf8b-9ac877e9a8b3" class="toggle"><li><details open=""><summary>禁止分片/重新组装：</summary><p id="59b8ddb5-219f-4241-bc14-90a27af796b1" class="">IPv6 不允许在中间路由器上进行分片与重新组装。这种操作只能在源与目的地上执行。如果路由器收到的 IPv6 数据报因太大而不能转发到出链路上的话， 则路由器只需丢掉该数据报，并向发送方发回一个“分组太大”的 ICMP 差错报文即可（见下文）。于是发送方能够使用较小长度的 IP 数据报重发数据，大大加快了网络中的 IP 转发速度。</p></details></li></ul><ul id="76258bee-74ed-4e80-b94c-c8e15be585ab" class="toggle"><li><details open=""><summary>流标签与优先级：</summary><p id="55cbe90a-def1-4c5f-940f-7db822d69e03" class="">IPv6 有一个难以捉摸的流（flow）定义。该字段可用于“给属于特殊流的分组加上标签，这些特殊流是发送方要求进行特殊处理的流，如一种非默认服务质量或需要实时服务的流”。例如，音频与视频传输就可能被当作一个流。IPv6 首部中还有一个 8 比特的流量类型字段，该字段就像 IPv4 中的 TOS 字段，可用于给出一个流中某些数据报的优先级，以便指明某些应用的数据报（如ICMP 分组）比其他应用的数据报（如网络新闻）有更高的优先权。</p></details></li></ul></details></li></ul><ul id="bbbf33e0-640d-4644-a3ab-2986412f775d" class="toggle"><li><details open=""><summary>数据报内容</summary><ul id="9b779c91-6513-4616-bdf1-ce5ca09af72e" class="bulleted-list"><li>版本𝒗𝒆𝒓<p id="f5354263-25ba-4998-8993-d9fc50b951bd" class="">该 4 比特字段用于标识 IP 版本号，IPv6 将该字段值设为 6。注意到将该字段值置为 4 并不能创建一个合法的 IPv4 数据报。</p></li></ul><ul id="02661c20-2ba4-405f-a27d-6901b50758ae" class="bulleted-list"><li>流量类型𝒑𝒓𝒊该8比特字段与我们在IPv4中看到的TOS字段的含义相似</li></ul><ul id="e26f6e33-78b6-4aa4-8408-a4dc9d6fcd1a" class="bulleted-list"><li>流标签𝒇𝒍𝒐𝒘 𝒍𝒂𝒃𝒆𝒍如上面讨论过的那样，该20比特的字段用于标识一条数据报的流。</li></ul><ul id="bffae701-bf5f-4c3c-959b-3955ab60c05a" class="bulleted-list"><li>有效载荷长度𝒑𝒂𝒚𝒍𝒐𝒂𝒅 𝒍𝒆𝒏该 16 比特值作为一个无符号整数，给出了 IPv6 数据报中跟在定长的 40 字节数据报首部后面的字节数量。</li></ul><ul id="0589bca5-02f4-461b-b2d2-fca6b3cbd802" class="bulleted-list"><li>下一个首部𝒏𝒆𝒙𝒕 𝒉𝒅𝒓该字段标识数据报中的内容（数据字段）需要交付给哪个协议（如 TCP 或UDP）。该字段使用与 IPv4 首部中协议字段𝑢𝑝𝑝𝑒𝑟 𝑙𝑎𝑦𝑒𝑟相同的值。</li></ul><ul id="ffdad33d-3d47-49e7-8515-338c4fa8eea5" class="bulleted-list"><li>跳限制𝒉𝒐𝒑 𝒍𝒊𝒎𝒊𝒕转发数据报的每台路由器将对该字段的内容减 1。如果跳限制计数到达 0 时， 则该数据报将被丢弃。<p id="107326e5-4500-497c-90c2-da6c42b09d74" class=""><strong>–</strong> 源地址和目的地址𝑠𝑜𝑢𝑟𝑐𝑒 𝑎𝑑𝑑𝑟𝑒𝑠𝑠 &amp; 𝑑𝑒𝑠𝑡𝑖𝑛𝑎𝑡𝑖𝑜𝑛 𝑎𝑑𝑑𝑟𝑒𝑠𝑠</p><p id="8b36a16d-87d6-413b-b1a4-8a01ed93a6fa" class=""><strong>–</strong> 数据𝑑𝑎𝑡𝑎</p></li></ul><p id="53fb8323-bee6-45e1-a9a4-595118d4d988" class="">这是 IPv6 数据报的有效载荷部分。当数据报到达目的地时，该有效载荷就从IP 数据报中移出，并交给在下一个首部字段中指定的上层协议处理。</p></details></li></ul><ul id="6a0b11d8-a6fa-466d-ad3c-5272b9c20179" class="toggle"><li><details open=""><summary>相较于 IPv4 的变化</summary><ul id="cd68b581-613b-41be-9b10-74d311a3fab5" class="bulleted-list"><li><strong>不允许分片/重新组装</strong></li></ul><ul id="66448e64-bc01-43b3-b327-8c0bc5bae455" class="bulleted-list"><li><strong>删去首部校验和字段</strong></li></ul><p id="3177ac18-a65b-446c-9a63-b1e1399346de" class="">因为因特网层中的运输层（如 TCP 与 UDP）和数据链路层（如以太网）协议执行了检验操作</p><ul id="67074f0d-3cff-4b59-979e-00a2c4d5b61f" class="bulleted-list"><li>选项字段不再是标准 IP 首部的一部分<figure id="5d2ba662-d7a4-4673-add1-11f98d9e5223" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image48.jpeg"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image48.jpeg"/></a></figure></li></ul></details></li></ul><ul id="3a5a8950-4616-4d20-ae05-4a3fc56176a9" class="toggle"><li><details open=""><summary><strong>从 IPv4 向 IPv6 迁移：tunneling</strong></summary><p id="c0b1b7ca-4726-4596-bf21-520122e27fc4" class="">将两台IPv6 路由器之间的中间IPv4 路由器的集合称为一个隧道（tunnel）。借助于隧道，在隧道发送端的 IPv6 结点（如 B）可将整个 IPv6 数据报放到一个 IPv4 数据报的数据（有效载荷）字段中。隧道中的中间 IPv4 路由器就像对待其他数据报一样，完全不知道该 IPv4 数据报自身就含有一个完整的 IPv6 数据报。</p></details></li></ul></details></li></ul></details></li></ul><h1 id="7e21224f-de21-40fb-8f12-9be5464bac02" class="">五、路由选择算法</h1><ul id="d1b9e314-85e5-400c-8ce9-a1ac6c7146f0" class="toggle"><li><details open=""><summary>概述</summary><ul id="bf610872-2c28-4d23-b710-a9443325be7b" class="toggle"><li><details open=""><summary>概述/一些概念</summary><p id="620b4101-e825-4992-a087-28a418cb82a1" class="">主机通常直接与一台路由器相连接，该路由器即为该主机的默认路由器（default router），又称为该主机的第一跳路由器（first-hop router）。每当主机发送一个分组时，该分组被传送给它的默认路由器。我们将源主机的默认路由器称作源路由器（source router），把目的主机的默认路由器称作目的路由器</p><p id="73e482ef-fb94-47be-bba2-9af1a062d4d2" class="">路由选择算法的目的是简单的：给定一组路由器以及连接路由器的链路，路由选择算法要找到一条从源路由器到目的路由器的“好”路径（具有最低开销：时间、）</p></details></li></ul><ul id="e19e6962-7f49-4017-954f-548459145100" class="toggle"><li><details open=""><summary>抽象网络拓扑结构为图</summary><ul id="518de642-e697-4c05-b6ad-dac395ad5548" class="bulleted-list"><li><strong>图（graph）</strong><figure id="649664d4-4580-4826-a86f-7ec9fc7afe74" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image49.jpeg"><img style="width:553px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image49.jpeg"/></a></figure><p id="7409bcee-4f1c-4c17-8926-6af0df80ac8b" class="">图𝐺 = (𝑁, 𝐸)是一个N 个节点和E 条边的集合；</p></li></ul><ul id="5e6f9563-3be3-4351-a4d9-4cabc432ce63" class="bulleted-list"><li>节点（note）<p id="de659e25-5f1b-485a-805e-d225c2b6e5fb" class="">节点集合𝑁 = {𝑢. 𝑣. 𝑤. 𝑥. 𝑦. 𝑧}，每个元素表示一个路由器，是做出分组转发决定的点；</p></li></ul><ul id="a8834d2c-08f1-427f-94d2-87b46e4b1718" class="bulleted-list"><li>边（edge）<p id="d0a9b817-2004-486a-b02a-256136c4a6a4" class="">边集合𝐸 = {(𝑢, 𝑣), (𝑢, 𝑥), (𝑣, 𝑥), (𝑣, 𝑤), (𝑥, 𝑤), (𝑥, 𝑦), (𝑤, 𝑦), (𝑤, 𝑧), (𝑦, 𝑧)}，是连接节点（路由器）之间的物理链路；</p></li></ul><ul id="1e66c8a9-2996-43f6-850e-653bfae84893" class="bulleted-list"><li>费用（cost）<p id="95cf5341-d2a4-4ddd-a420-6f779dba27eb" class="">一条边还有一个值表示它的费用（通常与链路的物理长度、链路速度和经济开销有关）。例如，𝑐(𝑢, 𝑣) = 2表示边/链路(𝑢, 𝑣)之间的开销是 2，若(𝑢, 𝑣)之间没有链路，则𝑐(𝑢, 𝑣) = ∞。</p><p id="6884602d-89fe-49ba-a92b-4f611334686c" class="">另外，网络拓扑图是无向图，边(𝑥, 𝑦)与边(𝑦, 𝑥)是相同的并且𝑐(𝑥, 𝑦) = 𝑐(𝑦, 𝑥)，x 和 y 互相为对方的邻居(neighbor)。</p></li></ul></details></li></ul><ul id="274632f1-94f9-4b69-8dea-0545c9e16989" class="toggle"><li><details open=""><summary>关键问题/目的</summary><p id="18944b86-f467-46ea-ae1c-d100b11d72f1" class="">𝑐𝑜𝑠𝑡 𝑜𝑓 𝑝𝑎𝑡ℎ (𝑥1, 𝑥2, 𝑥3, … , 𝑥𝑝) = 𝑐(𝑥1, 𝑥2) + 𝑐(𝑥2, 𝑥3) + … + 𝑐(𝑥𝑝 − 1, 𝑥𝑝)给定任何两个结点 x 和 y，通常在这两个结点之间有许多条路径，每条路径都有一个费用。这些路径中的一条或多条是最低费用路径（least-cost path）。</p><p id="d540ccc5-ae6f-47b5-a1b8-f579b319f3ae" class="">因此路由算法的目的：</p><p id="40e55f1f-7213-457a-972e-31e6dd1db574" class="">找出源和目的地之间的具有最低费用的一条路。若在图中的所有边具有相同的费用，则最低费用路径也就是最短路径（shortest path），即在源和目的地之间的具有最少链路数量的路径。</p></details></li></ul><ul id="53663a4a-d5ec-4932-9c08-9ed6e7f6dace" class="toggle"><li><details open=""><summary>路由算法的分类</summary><ul id="67af0ee0-b8aa-4e04-93a8-df030acafda4" class="toggle"><li><details open=""><summary><strong>广义分类方法 1：算法的涉及范围 局部/全局</strong></summary><ul id="63644a37-a64c-4e59-a205-80ed0a682ec1" class="toggle"><li><details open=""><summary><strong>全局式路由选择算法（global routing algorithm）</strong>该算法以网络中所有结点之间的连通性及所有链路的费用为输入。</summary><ul id="1759aefd-e761-478b-ad80-5bd88dd6b0d7" class="bulleted-list"><li>要求该算法下的每个路由器在运算开始之前，要获知该网络的拓扑结构和每条链路的花销。</li></ul><ul id="32013aaa-12fc-48dc-a9c2-37245f8ed8c0" class="bulleted-list"><li>实践中，该种算法常被称作链路状态（Link State，LS）算法，因为该算法必须知道网络中每条链路的费用。</li></ul></details></li></ul><ul id="832f2e14-435b-47c4-9957-7365cd09e3c2" class="toggle"><li><details open=""><summary><strong>分散式路由选择算法（decentralized routing algorithm)</strong></summary><ol id="9cfd5edf-ddfa-4ca6-bd32-3798ab1fba1a" class="numbered-list" start="1"><li>以迭代、分布式的方式计算出最低费用路径。<strong>没有结点拥有关于所有网络链路费用的完整信息，而每个结点拥有与其直接相连链路的费用知识即可开始工作</strong>。</li></ol><ol id="dd85fc55-d8c3-4722-aea8-b00a1890518f" class="numbered-list" start="2"><li>然后，通过迭代计算过程并<strong>与相邻结点</strong>（即与该结点相连链路的另一端的结点）<strong>交换信息</strong>，一个结点逐渐计算出到达某目的结点或一组目的结点的最低费用路径。</li></ol><p id="57648c1c-0f3e-49a8-b3a2-d5d8f7b8d09f" class="">例如，距离向量（Distance-Vector，DV）算法的分散式路由选择算法。之所以叫做 DV 算法，是因为每个结点维护到网络中所有其他结点的费用（距离）估计的向量。</p></details></li></ul></details></li></ul><ul id="78793a4f-f587-47b8-a118-a46c3bc91f37" class="toggle"><li><details open=""><summary><strong>广义分类方法 2：算法的性质 动态/静态</strong></summary><ul id="01f7831c-9977-48d5-a358-d6a1d986b8bd" class="bulleted-list"><li><strong>静态路由选择算法（static routing algorithm）</strong><p id="870ce244-2484-497f-bda4-008a708a3b63" class="">随着时间的流逝，路由的变化是非常缓慢的，通常是人工干预进行调整（如人为手工编辑一台路由器的转发表）。</p></li></ul><ul id="42d6acfa-436f-45ab-9085-8ed0259c65bb" class="bulleted-list"><li><strong>动态路由选择算法（dynamic routing algorithm）</strong><p id="e7736a6b-285f-41c3-a6a1-8c811f53e90e" class="">能够当网络流量负载或拓扑发生变化时改变路由选择路径。一个动态算法可周期性地运行或直接响应拓扑或链路费用的变化而运行。虽然动态算法易于对网络的变化做出反应，但也更容易受诸如路由选择循环、路由振荡之类问题的影响。</p></li></ul></details></li></ul></details></li></ul></details></li></ul><ul id="96362cce-edf5-4a3e-a0e6-57aafb306360" class="toggle"><li><details open=""><summary>链路状态路由选择算法（Link State，LS）</summary><ul id="e8e83c38-dd96-4c87-a498-a55dc82509b5" class="toggle"><li><details open=""><summary>前提</summary><p id="b5742a7b-099a-4190-ac45-73e20e905693" class="">在链路状态算法中，每个节点对于网络拓扑和所有的链路费用已知。</p><ul id="7fc7599a-53de-4663-82dc-9e6d678e154a" class="bulleted-list"><li>实践中这是通过让每个结点向网络中所有其他结点广播<strong>链路状态分组</strong>来完成的，其中每个链路状态分组包含它所连接的链路的特征和费用；</li></ul><ul id="3b652edf-b590-4eb6-82e4-037bf35ae4ff" class="bulleted-list"><li>广播导致网络中所有的节点具有相同的、完整的网络拓扑视图；</li></ul><ul id="9ab43955-b223-40bf-bb72-c507324c6c8a" class="bulleted-list"><li>每个节点可以运行 LS 算法计算本节点到其他每个节点的最低费用路径；</li></ul></details></li></ul><ul id="2b87f39a-db98-4a6c-b62b-c8164bc53046" class="toggle"><li><details open=""><summary>Dijkstra 算法</summary><p id="91ac0aa0-56b4-4153-baab-d5b19e190c76" class="">Dijkstra 算法是迭代算法，其性质是经算法的第 k 次迭代后，可知道到 k 个目的结点的最低费用路径。我们定义下列记号：</p><ul id="89878df1-4559-47c7-8bdc-288e4caccc67" class="bulleted-list"><li>𝑫(𝒗)<strong>：</strong>本次迭代完成时，从源节点到节点 v 的最低花销路径费用；</li></ul><ul id="cdc01c84-5c76-4db7-b78f-29f6a87a81aa" class="bulleted-list"><li>𝒑(𝒗)<strong>：</strong>从源节点到节点 v，沿着当前的最低花销路径的前一节点，即最低花销路径上到 v 的前一跳路由器；</li></ul><ul id="bed8bc96-acc6-4dfe-ad11-e2537d89613b" class="bulleted-list"><li>𝑵′<strong>：</strong>节点子集，若已经找到源节点到节点 v 的最低花销路径，则把 v 并入𝑁′；<figure id="8d554201-c2c2-4bac-811c-70b528ab602f" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image50.jpeg"><img style="width:336px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image50.jpeg"/></a></figure></li></ul></details></li></ul><ul id="dab101e1-4d22-400a-9a3e-65b78502a65b" class="toggle"><li><details open=""><summary>Dijkstra 算法—示例</summary><figure id="4dda2a74-5b2b-4100-9608-36dddda86b39" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image51.png"><img style="width:528px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image51.png"/></a></figure><ul id="2b827949-c147-4089-90e0-5b0953e44fec" class="bulleted-list"><li>用和源节点 u 直接相连的花费路径初始化算法表，没有直接相连的初始化为无穷。</li></ul><ul id="de8cc9b1-58b0-44af-876c-b649f404a811" class="bulleted-list"><li>每次选取当前的最低花费路径去维护整个表，当新发现的路径花费更低时，更新记录，每一步的最低花费路径的目的节点是已经得到最低花费的节点。用向量 p 记录前一跳，用向量 D 记录花销。<p id="ff43a56d-3043-4460-a95a-5be66fed39ed" class="">当算法终止时，对于每个结点，我们都得到从源结点沿着它的最低费用路径的前一结点。对于每个前一结点，我们又有它的前一个结点，以此方式我们可以构建从源结点到所有目的结点的完整路径。</p></li></ul><figure id="b926c718-9ad1-49a4-9831-f8b031c7e75c" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image52.jpeg"><img style="width:344px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image52.jpeg"/></a></figure></details></li></ul><ul id="ab8869de-d4f5-4a6a-8c0a-95b178350c6e" class="toggle"><li><details open=""><summary>Dijkstra 算法下的路由表的生成</summary><p id="88b21c0c-bcae-4878-b6f5-b632e3cf6140" class="">每个路由器不关心分组的转发路线，只关心某个分组的下一跳应该从哪个端口发出。因此，对网络中的每个目的结点，存放从 u 到每个目的节点的最低费用路径上的下一跳结点。</p></details></li></ul></details></li></ul><ul id="ca12e9ac-ebfe-4bb0-9d34-eb018c417126" class="toggle"><li><details open=""><summary>洪泛算法（Flooding）</summary><ul id="31408ec4-8a82-4cdb-8875-8537747b43ea" class="toggle"><li><details open=""><summary>定义</summary><p id="abb5f3a8-a9f9-4852-901f-38d6e69ea01f" class="">属于静态路由算法，基本思想是：把收到的每一个包，向除了该包到来的线路外的所有输出线路发送。</p></details></li></ul><ul id="49cbe019-44b4-4deb-b215-89cdbab60cdf" class="toggle"><li><details open=""><summary>主要问题</summary><figure id="e67f9333-0a9a-4177-b7a0-2d1cb4e460f1" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image53.png"><img style="width:528px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image53.png"/></a></figure><ul id="909fd3b6-ddb7-4f87-8b7a-256154950fe2" class="bulleted-list"><li>洪泛要产生大量重复包；</li></ul><ul id="ad8cb00d-07eb-4287-aff1-0e2592bd1553" class="bulleted-list"><li>如果网络中存在线路循环，可能会发生广播风暴， 例如从A 发出的广播包可能会再次被A 接收后再次发出；</li></ul></details></li></ul><ul id="5a889463-5d60-4133-8092-0cb0b5f6cb9e" class="toggle"><li><details open=""><summary>解决措施</summary><ul id="38b460a8-aa6f-4326-b90e-34deb97a9a49" class="bulleted-list"><li>每个包头包含站点计数器，每经过一站计数器减 1，为 0 时则丢弃该包（仅能保证广播包能走多远，不能保证重复发送）；</li></ul><ul id="bb3929e3-bf8e-4e9d-ab7c-07278e3d09cc" class="bulleted-list"><li>记录包经过的路径<ul id="f13da3d1-acfe-431d-a83e-5a2426cc1fe0" class="bulleted-list"><li>例如 E 接收到 G 发来的 5 号包，则在 E 记录 G5，当该包再次被 E 接收时，E 判定为该包已经接收转发过，则直接丢弃；</li></ul></li></ul><ul id="4d7375be-fd85-4f8d-94b1-33dce9a3d58b" class="bulleted-list"><li>路由器为减少路由规模，记录 K 值，小于 K 值则已经接收<ul id="6ff0839b-79a5-4dc3-941b-111000f83806" class="bulleted-list"><li>类似于 Rdt 的累计应答，若接收过 G5，则 G2 一定被接收；</li></ul></li></ul></details></li></ul><ul id="e49b855e-316b-4a94-a0e4-c57674d36f8f" class="toggle"><li><details open=""><summary>应用情况</summary><ul id="64023304-9d4c-484e-abf4-b549e46920bf" class="bulleted-list"><li>路由器和线路的资源过于浪费，实际很少直接采用；</li></ul><ul id="b155d499-d7d8-489c-bc92-0654ed7fcd0c" class="bulleted-list"><li>具有极好的健壮性，可用于军事应用；<ul id="86ffb111-6ae7-441b-807b-9b89b3c7b766" class="bulleted-list"><li>因为是广泛的洪泛发包，所以当部分节点被攻破宕机，数据包仍然可以被发送到目的地</li></ul></li></ul><ul id="2740afb4-cf94-4628-9ba7-1150363eb125" class="bulleted-list"><li>作为衡量标准评价其它路由算法；</li></ul></details></li></ul><ul id="e5c4c559-6dae-421b-9720-92e0509bd1c6" class="toggle"><li><details open=""><summary>改进—选择性洪泛算法（selective flooding）</summary><ul id="cff34bd0-88e7-4ffd-ae45-8ebefd15e37e" class="bulleted-list"><li>洪泛法的一种改进。将进来的每个包仅发送到与正确方向接近的线路上。</li></ul></details></li></ul></details></li></ul><ul id="fab09b91-dc53-4516-bcd7-56296005dbba" class="toggle"><li><details open=""><summary>洪泛算法在 LS 算法中的应用</summary><ul id="721d3876-4dfe-4de8-bde1-737588976558" class="toggle"><li><details open=""><summary>概述</summary><p id="bd301859-b00e-401f-b0a2-0ab2a155c026" class="">该小节实际叙述的是将链路广播包使用洪泛的方式发送出去，以使每个节点获取到整个网络的拓扑图。</p></details></li></ul><ul id="ebe06c00-ccf3-41b2-a73c-58292daa5719" class="toggle"><li><details open=""><summary>链路状态分组</summary><figure id="7fdbb30d-4b80-4fea-a0ad-f0f78e00b34a" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image54.png"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image54.png"/></a></figure><ul id="bd81d25e-31d9-40c1-afb3-80823cf0de81" class="bulleted-list"><li>包以发送方的标识符开头，后面是序号、年龄和一个邻居结点列表</li></ul><ul id="604ed8e8-c4b8-4cfd-a673-ac65051483a7" class="bulleted-list"><li>列表中对应每个邻居结点，都有发送方到它们的延迟或开销</li></ul><ul id="ec4c6a04-f501-40b8-ac1b-587c69502e96" class="bulleted-list"><li>链路状态包定期创建或发生重大事件时创建。</li></ul></details></li></ul><ul id="e1c849d3-afb5-46ca-a4eb-7166aba86dc6" class="toggle"><li><details open=""><summary>洪泛控制的应用</summary><p id="eee9c84c-2bf1-4044-90b9-826b48d69d58" class="">为控制洪泛，每个包包含一个序号，每次发送新包时加 1。路由器记录信息对（源路由器，序号），当一个链路状态包到达时，若是新的，则分发；若是重复的，则丢弃；若序号比路由器记录中的最大序号小，则认为过时而丢弃。例如“A3”被B 记录，则“A1”包会被 B 丢弃，再次接收到“A3”也会被丢弃</p></details></li></ul><ul id="17d55ada-0427-40f2-bb8c-21234fdd467f" class="toggle"><li><details open=""><summary>注意</summary><p id="12b6de5a-3ad1-497c-8561-e955bf01fdb1" class="">LS 算法在运行之前要使用洪泛算法广播链路状态数据包，让每个点都组装完整的网络拓扑图，此后运行 Dijkstra 算法。</p></details></li></ul></details></li></ul><ul id="e3a77793-4cac-42b3-9e21-3ca9c03334f5" class="toggle"><li><details open=""><summary>距离向量路由选择算法（Distance-Vector, DV）</summary><ul id="b0182753-4dbd-4631-963e-3e12575a2a00" class="toggle"><li><details open=""><summary>Bellman-Ford 方 程</summary><p id="dd9ed3aa-4da1-473b-816f-961711b9f7cc" class="">𝑑𝑥(𝑦) = 𝑚𝑖𝑛𝑣 {𝑐(𝑥, 𝑣) + 𝑑𝑣(𝑦) }其中：</p><ul id="7abb994b-5544-49a6-bfbb-631ae715a8b0" class="bulleted-list"><li>定义𝑑𝑥(𝑦)为从 x 到 y 的最低费用路径的花销；</li></ul><ul id="1103e248-123a-4c4b-b228-d2659253e9d7" class="bulleted-list"><li>是对节点 x 的所有邻居节点进行遍历：运算开始之前，节点 x 知道其所有邻居节点的最低费用路径表，因此节点 x 可以进行求最小值运算，将已知的 x 到邻居节点 v 的花销和从邻居节点v 获知的𝑑𝑣(𝑦)进行求和，最后计算 min对于每个节点 x，已知的是 x 到其所有邻居节点的花销、所有邻居节点交换给节点 x 的最低费用路径表（该邻居节点到达该网络内其他任何节点的最低费用路径花销值）。</li></ul></details></li></ul><ul id="71eb20d0-49bc-44d3-88ac-b0071a5cabbd" class="toggle"><li><details open=""><summary><strong>Bellman-Ford 方程示例</strong></summary><figure id="62d6b2e9-56f4-48e1-b057-8b7bbc754b8c" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image55.png"><img style="width:384px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image55.png"/></a></figure><figure id="91fd4dad-e2cc-4b06-bfff-df06548f82d3" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image49.jpeg"><img style="width:384px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image49.jpeg"/></a></figure><p id="29698905-1d76-4306-81da-1ee57389ec3a" class="">因此，可以获知 u 到 z 的最低费用为 4，且下一跳是节点 x</p></details></li></ul><ul id="7a185a23-52c6-4b87-b421-90f015f9c907" class="toggle"><li><details open=""><summary>特点</summary><figure id="6fb72919-5811-488f-8e93-ef395f81eb48" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image56.png"><img style="width:240px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image56.png"/></a></figure><ul id="0cc7feba-dca6-4ba7-8c7b-931017596f53" class="toggle"><li><details open=""><summary><strong>分布式：</strong></summary><ul id="0ccb0af4-0379-4375-9f7d-94fe2f5fc4ca" class="bulleted-list"><li>每个结点都要从一个或多个直接相连邻居接收某些信息，执行计算；</li></ul><ul id="e43c346a-5609-42d0-ac5b-8c262f5374f7" class="bulleted-list"><li>只有当本地距离向量表（DV 表）的<mark class="highlight-red">具体值（并非路径）</mark>发生变化时， 才会通知其邻居节点；</li></ul><ul id="899ca0b7-800a-45cd-8f78-e1dd635d3e49" class="bulleted-list"><li>注意：<p id="4da6a119-d6d6-43da-8524-69880838a147" class="">当节点的距离向量表（DV 表）未发生变化时， 不会广播通知邻居节点。例如上图所示，u 到 z 选择的线路是𝑢 − 𝑥 − 𝑦 − 𝑧, 𝑐𝑜𝑠𝑡 = 4：</p><p id="cbcb8fa7-18fa-4be9-9ad1-4a33e4fcb9da" class="">若𝑐(𝑥, 𝑦) = 2，𝑐(𝑦, 𝑧) = 1，此时节点 x 会重新计算其距离向量表，<mark class="highlight-red">但因为结果不变，它不会广播通知 u；</mark></p><p id="de9931bd-c8c4-40c1-93b4-d2ae3a7fb278" class="">若节点 x 经过最新距离向量表的计算，更新了到节点 z 的路线，但𝑐𝑜𝑠𝑡 = 4没变，其也不会通知节点 u；</p><p id="5c0876b1-5249-43dc-b33b-65a521251cca" class=""><mark class="highlight-red">一个节点只关心从本地节点的下一跳的选择，其下一跳路由器后续路线的变更该节点并不关心。</mark>因此，只有只要本地距离向量表中的值变大或者变小时才会触发广播通知邻居节点。</p></li></ul></details></li></ul><ul id="e1175229-4adb-490d-859b-076ac08b239c" class="toggle"><li><details open=""><summary><strong>迭代的：</strong></summary><p id="c39753cd-ed7e-4b6a-92e6-259d9f50aa5b" class="">当本地链路代价值（本节点到邻居节点的链路代价值改变）或者接收到邻居节点的 DV 表更新信息时，触发本节点的更新迭代；</p></details></li></ul><ul id="b8f7c042-ff57-428a-a5af-e19bb288fd6d" class="toggle"><li><details open=""><summary><strong>异步的：</strong></summary><p id="0e1c2092-5dda-4dbd-bd91-ecec8908e497" class="">不要求所有结点同时进行最低费用路径表的交换；</p><p id="4753383d-b0a9-4f53-b7f3-f00d98ac1bcc" class="">新算出的表给出了J到每一个节点的链路带价值，以及下一跳节点。</p><figure id="603e5ad5-377d-4cc4-ac3f-a852515f0ebf" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image57.jpeg"><img style="width:480px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image57.jpeg"/></a></figure></details></li></ul></details></li></ul><ul id="3303935a-0f33-482d-8ac4-4592f2b49adf" class="toggle"><li><details open=""><summary>LS 和 DV 的比较</summary><p id="ab3d5344-7637-4d8e-bf6b-5e65e9923538" class="">在 DV 算法中，每个结点仅与它的直接相连的邻居交谈，但它为其邻居提供了从它自己到网络中（它所知道的）所有其他结点的最低费用估计。在 LS 算法中，每个结点（经广播）与所有其他结点交谈，但它仅告诉它们与它直接相连链路的费用。</p><ul id="98a44542-473f-4267-b8ae-4ed2586f2b64" class="bulleted-list"><li>健壮性<p id="bd23353c-fbfe-4864-9267-95841832446f" class="">LS 的健壮性高于 DV 算法，在 DV 算法中一个不正确的节点计算值会扩散到整个网络；</p></li></ul></details></li></ul></details></li></ul><ul id="796665d1-747f-46a6-9730-582079709675" class="toggle"><li><details open=""><summary>层次路由选择算法（Hierarchical routing）</summary><ul id="918d6fee-715c-4f39-beef-2daedb50683f" class="toggle"><li><details open=""><summary>引入</summary><p id="9fab2ab4-802b-4f12-8691-44bd7e515393" class="">在 LS 和 DV 算法的研究中，将网络只看作一个<mark class="highlight-red">平面</mark>的互联路由器的集合。但是这种抽象方法运用在整个全球互联网中是不可行的：</p><ul id="a3b70a71-8f91-4a41-a167-7565422190c3" class="bulleted-list"><li>全球互联网规模极大，不可能通过dijkstra算法得出整个网络的拓扑结构，同理 DV 算法也无法计算得到 DV 表；</li></ul><ul id="545f222e-937e-4208-995f-bf0f6507a033" class="bulleted-list"><li>不符合某组织自治管理网络的构想；</li></ul></details></li></ul><ul id="a8ff109e-02f0-4560-9f07-0216b544bf89" class="toggle"><li><details open=""><summary>简单定义</summary><figure id="d5525053-e052-4c6f-97ad-564144913121" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image58.png"><img style="width:576px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image58.png"/></a></figure><p id="ab9f7e05-633d-4500-b700-9dd2d2444595" class="">将极大的、无法管理的网络进行划分， 形成多个小的子网。如此一来，每个区域只需要计算本区域内的转发表，计算完成后区域之间进行转发表的交互即可。但是这种方法牺牲了最优路线的选择。例如上图中，原路由表中，1A 到 5C 是通过边界路由器 1B 转发，但是做层次路由后，发往 5 的全部由 1C 发出，发送的开销增加了。</p><p id="e512986c-6a67-4f97-943f-a6d4aaa4f2ef" class=""><mark class="highlight-red">增加了效率，损失了最优化的链路代价值。</mark></p></details></li></ul><ul id="4737c46e-ddd9-44cc-9749-ebc3718a708c" class="toggle"><li><details open=""><summary>术语</summary><ul id="4490401d-e120-47d0-a748-a4e17d70d02a" class="bulleted-list"><li>自治系统（Autonomous System，AS）<p id="7fc276fc-dc5f-4403-ab57-b91db29283a1" class="">每个 AS 由一组通常处在相同管理控制下的路由器组成，每个 AS 属于一个ISP，一个 ISP 可能有多个 AS。在相同的 AS 中的路由器都全部运行同样的路由选择算法（如一种 LS 或 DV 算法），且拥有彼此的信息，即自治系统内部即可采用 4.5.2 链路状态路由选择算法（Link State，LS）和 4.5.5 距离向量路由选择算法（Distance-Vector, DV）。</p></li></ul><ul id="15be87c0-7b2c-408e-a95d-235acf6eec5e" class="bulleted-list"><li>自治系统内部路由选择协议（ intra-autonomous system routing protocol）<p id="1df9688d-bb62-4e39-93a3-06a275a93c24" class="">在一个特定的 AS 内部运行的特定的路由选择协议，完成分组在 AS 内部进行的转发递交</p></li></ul><ul id="8a22545e-9b3b-4aa0-9370-79985beac439" class="bulleted-list"><li>网关路由器（gateway router）<p id="b468c344-f30a-4419-a978-13496b5a3482" class="">连接本 AS 和外部 AS 的最外围路由器，作为边界沟通 AS 内部和外界。需要将 AS 内部需要转发出去的包递交出去，外部需要递交给 AS 内部的包， 在 AS 内部使用自治系统内部路由选择协议进行递交</p></li></ul><ul id="04532c34-83d3-426f-a2e5-58ef6af338b7" class="bulleted-list"><li>示例<figure id="2706e7a1-b460-4a9a-8768-7d4683737acb" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image59.jpeg"><img style="width:528px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image59.jpeg"/></a></figure><p id="7452cc26-05e6-40c5-a00d-138daa478c90" class="">在该图中，粗线表示了路由器对之间的直接链路连接。从路由器连出的细线表示直接与路由器连接的子网。</p><p id="30641822-8123-445e-ba3b-8f69bb966210" class="">AS1 具有 4 台路由器，1a、1b、1c 和 1d，它们运行在 AS1 内部，使用了 AS1 内部路由选择协议。因此， 这 4 台路由器的每一台都知道如何沿着优化路径转发到AS1 内任何目的地 的分组。注意到运行在 AS1、AS2 和 AS3 中的 AS 内部路由选择不必是相同的。同时注意到路由器 1b、1c、2a 和 3a 都是网关路由器。</p></li></ul></details></li></ul><ul id="23235bfa-208f-47aa-a786-5630e8af5d83" class="toggle"><li><details open=""><summary>自治系统间路由选择协议（inter-autonomous system routing protocol）</summary><ul id="3be61ff4-f0af-4b96-85d0-76414d62c5da" class="bulleted-list"><li><strong>引出</strong><p id="2a231082-5121-4149-b174-31be2cef5b3d" class="">如上图，假设 AS1 中的路由器 1d 接收到一个需要发往 AS1 外部的分组，此时 AS1 需要进行抉择：从边界路由器 1c 还是 1b 发出？</p></li></ul><ul id="47e9ccf5-03ca-4cfd-828e-d7ea2409b5cb" class="bulleted-list"><li>抉择前提<p id="e678f56a-72b7-474c-8949-8a3621bfbf11" class="">为了解决这个问题，AS1 需要：</p><ul id="5f1606db-fcbb-4de2-b695-f75ea2a6fc78" class="bulleted-list"><li>知道经 AS2（1b）可达哪些目的地，经 AS3（1c）可达哪些目的地；</li></ul><ul id="a60cf540-0f02-472e-b26a-8bf004b62941" class="bulleted-list"><li>向 AS1 中的所有路由器传播这些可达性信息，因此 AS1 中的每台路由器能够配置它的转发表以处理外部 AS 目的地。</li></ul><p id="8bae579f-802e-4da0-8d51-8f2d3d70a0d0" class="">从相邻 AS 获取可达性信息和向该 AS 中所有路由器传播可达性信息（虽然 是在 AS 内部广播但仍是 AS 间路由的内容）是两项由自治系统间路由选择协议 （inter-autonomous system routing protocol）处理的任务。因特网中的所有 AS 中都运行相同的 AS 间路由选择协议，因为多个 AS 之间进行通信必须使用相同的协议。</p></li></ul><ul id="c03cc440-dba6-4ad1-b492-37d315250aa3" class="bulleted-list"><li>示例—假设 1d 有数据包要发往目标系统 X<figure id="44cbbeed-df51-4b7b-8c38-01714272783b" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image60.jpeg"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image60.jpeg"/></a></figure><p id="887caa9d-ea12-4462-b53e-a3b35695b441" class="">AS1 通过 AS 间路由选择协议知道子网 x 从 AS3 可达，而从 AS2 不可达，AS1 则向它的所有路由器传播这个信息（AS 间路由选择协议完成）。当路由器 1d 根据广播，知道从 AS3 并因此从网关 1c 可达子网 x 时，根据AS 内部路由选择协议提供的信息，确认在 AS1 内部从 1d 到 1c 的最低花费路径，并将转发路由信息(𝑥, 发出路由接口, 子网掩码)放入其转发表中。</p></li></ul><ul id="ed73dfc3-5dc5-4fef-8af8-0ed55a8bf582" class="bulleted-list"><li>热土豆路由（hot potato routing）<figure id="d481bdb0-a8f3-4a96-ac6c-a04665d2211c" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image61.jpeg"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image61.jpeg"/></a></figure><p id="780db872-8613-478b-bef7-47ca112907fa" class="">接上例，当目的系统 X 通过 AS3 和 AS2 均可达，即需要抉择通过 1c 还是 1b发出？使用热土豆路由（hot potato routing）：根据 AS 内部路由选择协议获知从1d 到 1c/1b 的最低花费路径，选择两者中较小的最低花费的路径网关发出。即尽快的将分组从 AS1 发出（尽快扔掉烫手的山芋）。</p><figure id="642e806d-1d4e-4ada-8302-e5bb39ab68e3" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image62.jpeg"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image62.jpeg"/></a></figure></li></ul></details></li></ul></details></li></ul><h1 id="024374bd-1084-45bb-b133-336b80c8fc7e" class="">六、实际因特网中的路由选择</h1><p id="5158194e-9a40-4b39-98f2-f78daa084187" class=""><mark class="highlight-red">无穷计数和空闲问题</mark></p><ul id="b5d1d17a-85d0-4658-b7b2-d4c6a8916c93" class="toggle"><li><details open=""><summary>AS 内部的路由选择：路由信息选择协议 RIP（了解）</summary><ul id="4332292c-2cb5-489d-ae71-8bee0bcde1c7" class="toggle"><li><details open=""><summary>定义</summary><p id="c25e65b2-b10c-4e09-bc91-81784ac63048" class="">RIP 是一种因特网中 AS 内部的距离向量协议，其运行方式很像理想化 DV 协议：</p><ul id="0d722afe-58c2-4f58-a977-d305cb957405" class="bulleted-list"><li>使用跳数作为其费用测度，即每条链路的费用为 1；</li></ul><ul id="78bf48eb-d03b-496e-842e-aebe39d77b86" class="bulleted-list"><li>一条路径的最大费用被限制为 15，因此 RIP 的使用限制在网络直径不超过 15 跳的自治系统内；</li></ul><ul id="83811430-8260-4168-90db-82d24cc2b44d" class="bulleted-list"><li>路由选择更新信息在邻居之间通过使用一种 <strong>RIP 响应报文</strong>来交换，大约<strong>每 30 秒必须相互交换一次</strong>，这是周期性的必须完成的操作；</li></ul><ul id="381798bc-b693-4d4c-97c8-2b03591c7f56" class="bulleted-list"><li>响应报文包含了一个该 AS 内的多达 25 个目的子网的列表，以及发送方到其中每个子网的距离；</li></ul><ul id="a4ea90f6-1d9a-4dba-b453-e8424b1aa385" class="bulleted-list"><li>如果某路由器 <strong>180s</strong> 接收不到其邻居的 <strong>RIP 响应报文</strong>，则认为该邻居节点已停止服务，会重新进行计算；<figure id="39160f5b-470f-43c2-a76b-b85be1625890" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image63.jpeg"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image63.jpeg"/></a></figure></li></ul><ul id="66a673c5-c049-4d1a-a256-cdabc28d7806" class="bulleted-list"><li>RIP 是被当作一个应用层进程来实现的，它能在一个标准套接字上发送和接收报文，并且使用一个标准的运输层协议（UDP）。<figure id="81405af4-09f5-411e-b141-919a18127f4a" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image64.png"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image64.png"/></a></figure></li></ul></details></li></ul><ul id="5e696d2d-94dc-431f-8f80-ae8b761a54e4" class="toggle"><li><details open=""><summary>示例</summary><figure id="6de3993d-3c59-43e4-bbf9-10b9f16242c0" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image65.jpeg"><img style="width:389px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image65.jpeg"/></a></figure><figure id="41945e3e-79e2-4c1b-bd43-3e534aed99ed" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image66.jpeg"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image66.jpeg"/></a></figure></details></li></ul></details></li></ul><ul id="b6ddffbe-fc72-4f68-be2a-9f4c5091f512" class="toggle"><li><details open=""><summary><strong>AS 内部的路由选择：开放最短路优先 OSPF</strong></summary><ul id="a3027e61-4b7d-49a7-8d67-9bfa6e17c0d9" class="toggle"><li><details open=""><summary>概述</summary><p id="f76208ff-55c3-44a6-ae9c-f88b26807355" class="">OSPF 的核心就是一个使用洪泛链路状态信息的链路状态协议和一个Dijkstra 最低费用路径算法。使用 OSPF，一台路由器构建了一幅关于整个自治系统的完整拓扑图（即一个图）。于是，路由器在本地运行 Dijkstra 的最短路径算法，以确定一个以自身为根结点的到所有子网的最短路径树。各条链路费用是由网络管理员配置的。使用 OSPF 时，路由器向自治系统内所有其他路由器广播路由选择信息，而不仅仅是向其相邻路由器广播。每当一条链路的状态发生变化时（如费用的变化或连接/中断状态的变化），路由器就会广播链路状态信息。即使链路状态未发生变化，它也要周期性地（至少每隔 30 分钟一次）广播链路状态。OSPF 通告包含在 OSPF 报文中，该 OSPF 报文直接由 IP 承载，因此 OSPF 协议必须自己实现诸如可靠报文传输、链路状态广播等功能。</p></details></li></ul><ul id="216926cb-26a5-43d8-9c9d-4d562b60bc65" class="toggle"><li><details open=""><summary>优点</summary><ul id="444afaf6-42e3-498f-ab95-029260634d21" class="bulleted-list"><li><strong>安全性</strong><p id="637bb821-509c-402a-9587-15dd3ede9b43" class="">所有的 OSPF 信息必须经过合法性认证后才会被注入路由器中，有效防止了恶意 OSPF 攻击。</p></li></ul><ul id="65fba196-e34c-4819-bdff-e64a23e04316" class="bulleted-list"><li>允许存在多条相同费用的路径<p id="06e1b13a-5909-4c59-afa0-a34a93c11a1e" class="">当到达某目的地的多条路径具有相同的费用时，OSPF 允许这些路径同时存在于路由表中。这就是说，当多条相等费用的路径存在时，无需仅选择单一的路径来承载所有的流量，提示健壮性。</p></li></ul><ul id="d929bbc8-c0c8-4960-ba6c-133d8dff2059" class="bulleted-list"><li>对单播、多波路由选择的综合支持</li></ul><ul id="f5220a14-0951-46e8-be55-a4c8a1f94732" class="bulleted-list"><li><strong>支持在单个路由选择域内的层次结构</strong><p id="2401d3b8-a289-4a3e-823a-40be9b5f9e19" class="">具有按层次结构构造一个自治系统的能力。</p></li></ul></details></li></ul><ul id="d7deed85-9a16-493e-b34b-3824ddb2d537" class="toggle"><li><details open=""><summary>层次 OSPF</summary><figure id="fe07ce5d-96b7-4410-bc39-58068a42be2f" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image67.jpeg"><img style="width:528px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image67.jpeg"/></a></figure><ul id="f43e240a-c7c7-4099-8b78-6a6791d2eb8b" class="bulleted-list"><li>实现<p id="21d06dba-81e9-46ee-9b82-96c1a89c10b9" class="">一个 OSPF 自治系统可以配置成多个区域。每个区域都运行自己的 OSPF 链路状态路由选择算法，一个区域内的每台路由器都向该区域内的所有其他路由器广播其链路状态。在一个区域内，一台或多台区域边界路由器负责为流向该区域以外的分组提供路由选择。在 AS 内只有一个 OSPF 区域配置成主干区域。主干区域的主要作用是为 AS 内其他区域之间的流量提供路由选择。该主干总是包含了 AS 内的所有区域边界路由器，并且可能还包含了一些非边界路由器。</p></li></ul><ul id="109fce8a-f0a1-4fce-867b-4257de4ddfe4" class="bulleted-list"><li>域间交流<p id="92f9db56-1fd1-40f3-bae2-788c9641b586" class="">在 AS 内的区域间的路由选择要求分组首先路由到一个区域边界路由器（区域内路由选择），再通过主干路由到位于目的区域的区域边界路由器，然后再路由到最终目的地。</p></li></ul></details></li></ul></details></li></ul><ul id="0f2243ff-8711-4604-8a2b-d39a75313a40" class="toggle"><li><details open=""><summary>AS 间的路由选择：边界网关协议 BGP</summary><ul id="fc10b144-d9b8-44ea-938b-7c05bddefa80" class="bulleted-list"><li>定义<p id="f1da906b-4089-487c-a8d5-ba27e2ca2176" class="">BGP 为每个 AS 提供了进行以下工作的手段：</p></li></ul><ul id="ac753952-9a99-4137-a1f3-5e0bd5b4d24c" class="bulleted-list"><li>从相邻 AS 处获得子网可达性信息<ul id="9338c1a7-cde0-49a3-97b8-4006130d1be7" class="bulleted-list"><li>使用跨越两个 AS 的 TCP 连接（BGP 会话）进行跨 AS 的通信，被称为<strong>外部 BGP 会话（</strong>𝒆𝑩𝑮𝑷<strong>）；</strong></li></ul></li></ul><ul id="fc802c85-2d9a-4ed0-9aa8-de87a72d3f2f" class="bulleted-list"><li>向本 AS 内部的所有路由器传播这些可达性信息<ul id="07b6ccf7-9542-4d3b-adf4-542c07cb2e36" class="bulleted-list"><li>在同一个 AS 内部的两个路由器之间架设的 TCP 连接（BGP 会话） 进行自治系统内部通信，被称为<strong>内部 BGP 会话（</strong>𝒊𝑩𝑮𝑷<strong>）；</strong></li></ul></li></ul><ul id="517eb7f3-ad22-4be6-acd8-666aa86c162b" class="bulleted-list"><li>基于可达性信息和 AS 策略，决定到达子网的“好”路由<p id="ae6da360-912a-4efc-b26b-9aa0d2aea5b3" class="">更为重要的是，BGP 使得每个子网向因特网的其余部分通告它的存在”，并且BGP 确保在因特网中的所有 AS 知道该子网以及如何到达那里。如果没有 BGP 的话，每个子网将是隔离的，即它们孤独并且不为因特网其余部分所知。</p><figure id="0557f219-4a02-4e52-8b1c-d79f3ffb254d" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image68.jpeg"><img style="width:700px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image68.jpeg"/></a></figure></li></ul></details></li></ul><ul id="67711f5f-d321-41b8-9ff5-bd33ee16522c" class="toggle"><li><details open=""><summary>BGP 前缀</summary><p id="67d82e62-1cd4-44bf-9857-e42de3e5d93c" class="">当一台路由器通过 BGP 会话通告一个前缀时，它在前缀中包括一些 BGP 属性（BGP attribute）。用BGP 术语来说，带有属性的前缀被称为一条路由（route）。𝑝𝑟𝑒𝑓𝑖𝑥 + 𝑎𝑡𝑡𝑟𝑖𝑏𝑢𝑡𝑒𝑠 = “𝑟𝑜𝑢𝑡𝑒”因此，BGP 对等方彼此通告路由。两个较为重要的属性是 AS-PATH 和 NEXT- HOP：</p><ul id="6230a0e6-4e26-48ff-88ec-9d71a69302dc" class="bulleted-list"><li>AS-PATH<p id="8562e139-8e9b-4d2b-baf6-901e85a34fde" class="">该属性包含了前缀的通告已经通过的那些 AS。当一个前缀传送到一个AS 时，该 AS 将它的 ASN（自治系统号）增加到 AS-PATH 属性中。路由器使用该 AS-PATH 属性来检测和防止循环通告。例如，上图中，假定前缀 138.16.64/24 首先是由 AS2 向 AS1 通告的；如果 AS1 接下来将该前缀向 AS3 通告，则该 AS-PATH 将是 AS2 AS1。</p></li></ul><ul id="4b28f84f-45a7-4b8c-a411-670518bc7f6b" class="bulleted-list"><li>NEXT-HOP<figure id="c32302b9-9141-4e87-adbf-25010a0ede67" class="image"><a href="Untitled%2082a42c90bc0840649a46c4e56e62997d/image69.jpeg"><img style="width:571px" src="Untitled%2082a42c90bc0840649a46c4e56e62997d/image69.jpeg"/></a></figure><p id="0a30cb0e-ecb2-40de-b5de-8e2d6b1d578a" class="">NEXT-HOP 是一个开始某 AS-PATH 的路由器接口。例如，AS2 所连接的网络要到 X 网段，则 X 通告的前缀中的 NEXT-HOP 为“X，AS3 3b 1，AS1 1c 2， AS2 2a 1”，记录每个AS 开始的路由器接口。</p></li></ul></details></li></ul><ul id="8c880540-4414-451a-ac53-74b55f48338c" class="toggle"><li><details open=""><summary>BGP 路由选择</summary><p id="ad093fa9-8e3c-4e21-9d11-86446478bbf5" class="">路由器根据 AS 内路由选择和 AS 间路由选择协议，可能知道到达任何一条前缀的多条路由，在这种情况下路由器必须在可能的路由中选择一条，BGP 顺序地调用下列消除规则，直到留下一条路由：</p><ul id="9a9ef8be-6a07-49f8-84f9-09c723e9bd00" class="bulleted-list"><li><strong>路由被指派一个本地偏好值作为它们的属性之一。</strong>这是一条由 AS 的网络管理员决定的决策（默认路由、特定主机路由）。具有最高本地偏好值的路由将被选择；</li></ul><ul id="f7c9b34f-7704-4596-a434-5284f4862a62" class="bulleted-list"><li><strong>在余下的路由中（所有都具有相同的本地偏好值），具有最短 AS-PATH的路由将被选择。</strong>BGP 将使用一种距离向量算法来决定路径，其中距离测度使用 <strong>AS 跳的数目</strong>而不是路由器跳的数目；</li></ul><ul id="8fde8d24-5d62-4d87-a8f3-a1c0982ba6c9" class="bulleted-list"><li><strong>在余下的路由中（所有都具有相同的本地偏好和相同的AS-PATH 长度），将选择具有最靠近 NEXT-HOP 路由器的路由。</strong>它由 AS 内部算法来决定。，该进程经常被称为<strong>热土豆路由选择</strong>；</li></ul><ul id="157d36ce-e8b3-4b19-a9a2-3d5ddf696a7e" class="bulleted-list"><li>如果仍留下多条路由，该路由器使用 BGP 标识符来选择路由；</li></ul></details></li></ul><ul id="60bb3c16-56e3-41c0-ad1a-30196ab69870" class="toggle"><li><details open=""><summary>𝒊𝑩𝑮𝑷<strong>和</strong>𝒆𝑩𝑮𝑷<strong>的区别</strong></summary><ul id="bc120eb0-34a7-41c7-8938-cd3e3c38fd61" class="bulleted-list"><li>策略<ul id="81635d06-7d02-417a-88d7-cc7b04d3f089" class="bulleted-list"><li>𝑒𝐴𝑆：跨域 AS 的情况下可能有多种跨域方案，因此需要管理员配置策略，进行路由选择；</li></ul><ul id="af876872-279a-4c02-883d-8722af68d671" class="bulleted-list"><li>𝑖𝐴𝑆：AS 内有单一管理员，运行相同的路由转发算法；</li></ul></li></ul><ul id="9c43c9c8-3428-4764-9e8a-c612e15b5141" class="bulleted-list"><li>规模<ul id="3f34cb61-4484-40bb-ab33-9a44bb2425f4" class="bulleted-list"><li>BGP 的分层路由减小了路由表的规模，减少了更新流量</li></ul></li></ul><ul id="e17ccb62-23b3-42c7-b3cf-85afe0b9d256" class="bulleted-list"><li>性能<ul id="ae0e3772-388d-4248-bdf7-3994de386bfb" class="bulleted-list"><li>𝑒𝐴𝑆：更关心策略；</li></ul><ul id="21deff83-48fb-4cc3-99da-48132061c547" class="bulleted-list"><li>𝑖𝐴𝑆：更注重性能；</li></ul></li></ul></details></li></ul><p id="b6399e8f-27b1-49da-be05-445a52b5e935" class="">
</p></div></article></body></html>