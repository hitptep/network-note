<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>第三章 传输层</title><style>
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.highlight-default {
}
.highlight-gray {
	color: rgb(155,154,151);
}
.highlight-brown {
	color: rgb(100,71,58);
}
.highlight-orange {
	color: rgb(217,115,13);
}
.highlight-yellow {
	color: rgb(223,171,1);
}
.highlight-teal {
	color: rgb(15,123,108);
}
.highlight-blue {
	color: rgb(11,110,153);
}
.highlight-purple {
	color: rgb(105,64,165);
}
.highlight-pink {
	color: rgb(173,26,114);
}
.highlight-red {
	color: rgb(224,62,62);
}
.highlight-gray_background {
	background: rgb(235,236,237);
}
.highlight-brown_background {
	background: rgb(233,229,227);
}
.highlight-orange_background {
	background: rgb(250,235,221);
}
.highlight-yellow_background {
	background: rgb(251,243,219);
}
.highlight-teal_background {
	background: rgb(221,237,234);
}
.highlight-blue_background {
	background: rgb(221,235,241);
}
.highlight-purple_background {
	background: rgb(234,228,242);
}
.highlight-pink_background {
	background: rgb(244,223,235);
}
.highlight-red_background {
	background: rgb(251,228,228);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(55, 53, 47, 0.6);
	fill: rgba(55, 53, 47, 0.6);
}
.block-color-brown {
	color: rgb(100,71,58);
	fill: rgb(100,71,58);
}
.block-color-orange {
	color: rgb(217,115,13);
	fill: rgb(217,115,13);
}
.block-color-yellow {
	color: rgb(223,171,1);
	fill: rgb(223,171,1);
}
.block-color-teal {
	color: rgb(15,123,108);
	fill: rgb(15,123,108);
}
.block-color-blue {
	color: rgb(11,110,153);
	fill: rgb(11,110,153);
}
.block-color-purple {
	color: rgb(105,64,165);
	fill: rgb(105,64,165);
}
.block-color-pink {
	color: rgb(173,26,114);
	fill: rgb(173,26,114);
}
.block-color-red {
	color: rgb(224,62,62);
	fill: rgb(224,62,62);
}
.block-color-gray_background {
	background: rgb(235,236,237);
}
.block-color-brown_background {
	background: rgb(233,229,227);
}
.block-color-orange_background {
	background: rgb(250,235,221);
}
.block-color-yellow_background {
	background: rgb(251,243,219);
}
.block-color-teal_background {
	background: rgb(221,237,234);
}
.block-color-blue_background {
	background: rgb(221,235,241);
}
.block-color-purple_background {
	background: rgb(234,228,242);
}
.block-color-pink_background {
	background: rgb(244,223,235);
}
.block-color-red_background {
	background: rgb(251,228,228);
}
.select-value-color-default { background-color: rgba(206,205,202,0.5); }
.select-value-color-gray { background-color: rgba(155,154,151, 0.4); }
.select-value-color-brown { background-color: rgba(140,46,0,0.2); }
.select-value-color-orange { background-color: rgba(245,93,0,0.2); }
.select-value-color-yellow { background-color: rgba(233,168,0,0.2); }
.select-value-color-green { background-color: rgba(0,135,107,0.2); }
.select-value-color-blue { background-color: rgba(0,120,223,0.2); }
.select-value-color-purple { background-color: rgba(103,36,222,0.2); }
.select-value-color-pink { background-color: rgba(221,0,129,0.2); }
.select-value-color-red { background-color: rgba(255,0,26,0.2); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="4cfc0027-57ed-49dd-99b8-58e3b8ad5251" class="page sans"><header><img class="page-cover-image" src="https://images.unsplash.com/photo-1524995997946-a1c2e315a42f?ixlib=rb-1.2.1&amp;q=85&amp;fm=jpg&amp;crop=entropy&amp;cs=srgb" style="object-position:center 50%"/><div class="page-header-icon page-header-icon-with-cover"><span class="icon">📌</span></div><h1 class="page-title">第三章 传输层</h1></header><div class="page-body"><h1 id="ea3dbf10-3eff-49fd-998d-70ddd20f06b7" class="">一、传输层的服务和协议</h1><ul id="2de573dd-ba05-453d-b3f1-90a2611e971b" class="toggle"><li><details open=""><summary>传输层服务</summary><ul id="dc005e10-a816-4a89-b9eb-58ed1e40f11a" class="bulleted-list"><li>在不同主机上运行的应用程序进程之间提供逻辑通信，应用进程使用运输层提供的逻辑通信功能彼此发送报文，而无需考虑承载这些报文的物理基础设施的细节。</li></ul><ul id="2dab7fdc-3d91-4a08-82aa-920bb07f9ef8" class="bulleted-list"><li>传输层运行在端系统上：<ul id="9b4c4f16-ccc0-4e37-aa08-86a0a5729b99" class="bulleted-list"><li>发送方的传输层要把应用层递交下来的数据拆分成包/段后递交给网络层进行进一步处理；</li></ul><ul id="2288a3e0-b022-4fae-ac84-72ef650b1ee6" class="bulleted-list"><li>接收方的传输层要接受网络层递交的数据包，将被拆分的数据包进行重组，分配给对应的应用进程使用；</li></ul><ul id="4c774525-9af5-4481-9ae2-cf90f783323e" class="bulleted-list"><li>网络路由器只把数据包拆分到网络层，不会提取传输层数据包；</li></ul></li></ul><ul id="dc0ba6b1-d716-4be0-9b54-8ec224ef2ba8" class="bulleted-list"><li>为应用程序提供可以使用的多个传输协议：TCP/UDP</li></ul></details></li></ul><ul id="586e0f34-d40b-4eb3-9ccb-d20106304e2c" class="toggle"><li><details open=""><summary>传输层和网络层的逻辑通信比较</summary><ul id="a2331ecd-44b3-4dbc-8b04-bdf00b167b44" class="bulleted-list"><li>网络层的逻辑通信：更加关注不同的<mark class="highlight-red">主机之间</mark>的逻辑通信；</li></ul><ul id="b89a7ff4-d0d8-4b4f-bcfc-706cc194fc02" class="bulleted-list"><li>传输层的逻辑通信：运输层为<mark class="highlight-red">运行在不同主机上的进程之间</mark>提供了逻辑通信；</li></ul><ul id="9059dc54-f4f0-4cbf-8fa9-86edc67f50c6" class="bulleted-list"><li>示例<p id="50b75173-13cb-4fc1-9375-968bb1eb979a" class="">两个家庭之间进行书信通信，家庭 A 中 Ann 负责收发信件，家庭 B 中是 Bill</p><p id="29e3f126-394c-40fa-894e-5b84e03ae5c0" class="">应用层报文=信封上的字符 </p><p id="826a54ec-5e71-4362-8209-cc89c2dba590" class="">进程=每个家庭中的孩子们 </p><p id="18eb22c4-8417-49a8-8030-ef3abc16d0fe" class="">主机（又称为端系统）=家庭</p><p id="c497bf5c-5ed4-4501-86d2-8769540ba49f" class="">传输层协议=Ann 和 Bill</p><p id="28a04846-5ca3-42c3-92c4-ee8bb9037d56" class="">网络层协议=邮政服务（包括邮车）</p><p id="95434e85-dd3f-4cec-9deb-29f1070e1c41" class="">Ann 和Bill(传输层协议)只负责在家庭内部不同的孩子那里收取信件并且分发给他们回信，邮政服务(网络层协议)只负责将家庭 A 的所有信件运到家庭 B；</p><p id="c4cb5dae-3f18-4b02-9075-93429e8e0af3" class="">Ann 和 Bill(传输层协议)能提供的服务是在邮政服务(网络层协议)的基础之上扩展的，例如给出不同的传输协议，但是邮政服务(网络层协议)对上层的服务有最基本的性能限制；</p><p id="38223b24-ae53-4048-9257-ef8edf6524d1" class="">传输层协议可以对网络层提供的协议进行扩展，比如网络层是不稳定数据传输的情况下仍然能在传输层提供可靠数据传输；</p></li></ul></details></li></ul><ul id="fe2b1044-610e-48ee-bcf1-6b3f7cda6dd1" class="toggle"><li><details open=""><summary>传输层协议</summary><ul id="d8d542e9-6e86-4407-8e7a-9ebce4fb7c49" class="bulleted-list"><li><strong>TCP(传输控制协议)：</strong>可靠的有序的面向连接数据传输，<mark class="highlight-red">流量控制和拥塞控制</mark></li></ul><ul id="f34007be-5a81-4847-a5b7-baca64162aed" class="bulleted-list"><li><strong>UDP(用户数据报协议)：</strong>不可靠的无连接服务，进程到进程的数据交付和差错检查</li></ul><ul id="305a735b-117a-43fe-ae62-baf20898d165" class="bulleted-list"><li>都不能提供的服务：<ul id="9d6f47a7-a475-47e9-aee0-92a967725189" class="bulleted-list"><li>延迟担保</li></ul><ul id="1c60b18a-fe4e-4d24-ba2d-68c43204a339" class="bulleted-list"><li>带宽保证</li></ul></li></ul></details></li></ul><h1 id="964aab7c-db0f-496b-984b-18d6afbcfdaf" class="">二、多路分解和多路复用</h1><ul id="e70c7b48-368a-4c0a-abdf-6e37ede014ad" class="toggle"><li><details open=""><summary>概述</summary><figure id="609e91de-bd1c-425d-9603-d6c01ccf06ed" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image1.jpeg"><img style="width:640px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image1.jpeg"/></a></figure><p id="c39f9fba-893a-499a-9f4f-25951ac934e0" class="">一个进程（作为网络应用的一部分）有一个或多个套接字（socket），它相当于从网络向进程传递数据和从进程向网络传递数据的门户。由于在任一时刻，在接收主机上可能有不止一个套接字，所以每个套接字都有唯一的标识符。标识符的格式取决于它是 UDP 还是 TCP 套接字。</p><ul id="76aa7ff4-e71e-49d3-b830-53d5827ae30e" class="toggle"><li><details open=""><summary>多路分解</summary><p id="2ad06115-d566-4961-8c12-3402e9eae158" class="">在接收端的传输层检查数据包头部的控制信息，将数据包定向到正确的套接字。将传输层报文段中的数据交付到正确的套接字的工作称为多路分解（demultiplexing）。</p></details></li></ul><ul id="702c7c1a-9d86-4590-a6df-976204c215c7" class="toggle"><li><details open=""><summary>多路复用</summary><p id="f787e42e-edaa-44bd-9f34-465d1d829295" class="">在源主机收集不同套接字的数据包，在其头部添加对应的控制信息(便于接收后重组和定向)后，生成传输层报文段，然后将生成的传输层报文段递交给网络层。所有这些工作称为多路复用（multiplexing）。</p></details></li></ul><ul id="0e1b18cd-4f28-442c-9ed9-b97871069e98" class="toggle"><li><details open=""><summary>示例解析</summary><p id="3e19a298-3cee-40bd-b5d4-250ced4a31ed" class="">传输层的服务和协议中的写信的例子中，每一个孩子通过他们的名字来标识。当 Bill 从邮递员处收到一批信件，并通过查看收信人名字而将信件亲手交付给他的兄弟姐妹们时，就是一个多路分解操作。当 Ann 从兄弟姐妹们那里收集信件并将它们交给邮递员时，她执行的就是一个多路复用操作。</p></details></li></ul></details></li></ul><ul id="4472e10c-e5af-4d09-a1a0-248d1836bdfe" class="toggle"><li><details open=""><summary>多路分解实现的基础</summary><ul id="c3786276-4aa0-4e03-8b0b-104893ff3a16" class="toggle"><li><details open=""><summary>要求</summary><ul id="0a19484f-4450-40f9-adc8-9ce529dcba83" class="bulleted-list"><li>套接字有唯一标识符；</li></ul><ul id="e95dab71-5243-4f87-aba6-2c68f6afc03e" class="bulleted-list"><li>每个报文段有特殊字段来指示该报文段所要交付到的套接字；</li></ul></details></li></ul><ul id="63595cd1-88c0-4e3e-8da6-1edf42f3dbbe" class="toggle"><li><details open=""><summary>实现</summary><figure id="2d32b1f1-b9b2-46af-bab7-9cbc782e3a9f" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image2.png"><img style="width:288px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image2.png"/></a></figure><ul id="408dc36d-47db-4a23-9e83-eb1c4460dfc0" class="bulleted-list"><li><strong>源端口号字段（source port number field）</strong></li></ul><ul id="425584ac-bdac-480b-ba63-e02846b4f288" class="bulleted-list"><li><strong>目的端口号字段（destination port number field）</strong></li></ul><ul id="dda1535d-c547-49e3-b6bb-d59f62e1a6a6" class="bulleted-list"><li><strong>UDP 报文段和 TCP 报文段还有其他的一些字段</strong></li></ul><p id="ce27fb73-ead9-4d87-9496-039479d4fb18" class="">端口号是一个 16 比特的数，其大小在 0~65535 之间。0~1023 范围的端口号称为周知端口号（well-known port umber），是受限制的，这是指它们保留给诸如 HTTP（它使用端口号 80）和 FTP（它使用端口号 21）之类的周知应用层协议来使用。</p></details></li></ul></details></li></ul><ul id="9c4821de-f5ca-4b67-b55e-39ee6a6e722a" class="toggle"><li><details open=""><summary>无连接的多路分解和多路复用</summary><ul id="144812a2-3437-4a7e-a256-1c13d02f70c6" class="toggle"><li><details open=""><summary>区分原理</summary><p id="759e1530-36fa-4f05-9a1a-97868bca2cd8" class="">一个 UDP 套接字是由一个二元组（目的 IP，目的端口号）唯一标识。不论是运行在源主机还是目的主机的套接字都可以用该二元组唯一标识，即使在一个主机上面可能同时运行了很多个网络进程。个人理解，因为 UDP 数据报中直接就指定了要投递的目的地，数据报中携带的就是正确的目的套接字。<mark class="highlight-red">因此，如果两个 UDP 报文段有不同的源 IP 地址和/或源端口号，但具有相同的目的 IP 地址和目的端口号，那么这两个报文段将通过相同的目的套接字被定向到相同的目的进程。</mark></p></details></li></ul><ul id="2223cb6b-c270-41c3-b795-73859f4ead4b" class="toggle"><li><details open=""><summary>流程</summary><p id="1c0c3874-5d5b-4e52-97fb-e89126d27983" class="">假定在主机 A 中的一个进程具有 UDP 端口 19157，它要发送一个应用程序数据块给位于主机 B 中的另一进程，该进程具有 UDP 端口 46428。</p><figure id="6c0f9e6d-4699-4838-9030-f00402a0aee2" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image3.jpeg"><img style="width:585px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image3.jpeg"/></a></figure><ul id="27195be2-2150-4364-8838-a0d13f908805" class="toggle"><li><details open=""><summary>发包</summary><ul id="70c93459-3726-4dbf-8ed5-11835aa5cfe4" class="bulleted-list"><li>主机 A 中的传输层创建一个传输层报文段，其中包括应用程序数据、源端口号（19157）、目的端口号（46428）</li></ul><ul id="36a27100-4bcc-4a7c-8fe8-a07566e993c9" class="bulleted-list"><li>传输层将得到的报文段传递到网络层，加上源 IP 和目的 IP信息。网络层将该报文段封装，并尽力而为地将报文段交付给目的主机；</li></ul></details></li></ul><ul id="374b95cf-c8f2-409f-9d7a-18ec3b3ec870" class="toggle"><li><details open=""><summary>收包</summary><ul id="82786fc3-7001-4be6-a91f-0691dee8c717" class="bulleted-list"><li>如果该报文段到达接收主机 B，接收主机运输层提取该报文段中的目的端口号（46428）并将该报文段交付给端口号 46428 所标识的套接字；</li></ul><p id="461a7e8c-789b-48ac-be29-a642c06c224e" class="">注意，接收主机 B 可能运行多个进程，每个进程都具有其自己的 UDP 套接字和相关联的端口号。当从网络层获取数据包后，通过检查传输层报文段中的目的端口号，将每个报文段定向到相应的套接字。</p></details></li></ul><ul id="56d333cc-a38b-430e-b88f-5df9e0c0c88e" class="toggle"><li><details open=""><summary>回发包</summary><p id="7b624cf6-7c76-48e4-bfac-290ffc2cc275" class="">传输层数据报中的源端口号用作“返回地址”的一部分：即当 B 需要回发一个报文段给 A 时，主机 B 便从 A 到 B 的报文段中的源端口号、源 IP 字段中取值，作为新 UDP 传输层数据报的目的地址进行封装。</p></details></li></ul></details></li></ul></details></li></ul><ul id="68d839e3-af10-4342-a1f7-0d705dca02aa" class="toggle"><li><details open=""><summary>面向连接的多路分解和多路复用</summary><ul id="28691b00-ea73-459e-aef7-3ae5026494ed" class="toggle"><li><details open=""><summary>定义</summary><p id="05bb4e43-c056-48e2-8070-20974d8e62ab" class="">TCP 套接字是由一个四元组（源 IP 地址，源端口号，目的 IP 地址，目的端口号）来标识的。当一个 TCP 报文段到达一台主机时，该主机使用全部 4 个值来将报文段定向到相应的套接字。特别与 UDP 不同的是，两个具有不同源 IP 地址或源端口号的到达 TCP 报文段将被定向到两个不同的套接字，除非TCP 报文段携带了初始创建连接的请求。个人理解，若 TCP 数据报要投递到同一个服务器的同一个应用程序，其携带的目的 IP 和目的端口号永远都是一样的即对应的欢迎套接字，而服务器会为该应用程序的不同客户请求创建不同的连接套接字，而这些属于同一个应用程序的套接字需要用四元组才能区分开：套接字 a 是客户 A 请求服务器 A 所建立的会话 1，套接字 b 是客户 B 请求服务器 A 所建立的会话 2……即服务器识别不同客户对同一个服务端程序的请求是通过不同的源 IP 和源端口来区分的；</p></details></li></ul><ul id="d78ec041-b79c-4296-a1fe-015bf72929d0" class="toggle"><li><details open=""><summary>深入理解“欢迎套接字”、“连接套接字”</summary><p id="df1d166f-7690-4806-a19b-00fe1f2a5ae9" class="">一个服务端程序只会监听一个接口/套接字即欢迎套接字，这个欢迎套接字像是一个大邮箱，接收多个客户端程序的请求。欢迎套接字这个大邮箱会检索每个指向自己的请求：</p><ul id="7001973c-036b-4b26-a488-cfacd4f436e5" class="bulleted-list"><li>若是已经建立 TCP 连接的“老连接”则把该数据报直接路由到对应的小信箱；</li></ul><ul id="dd9d7394-e582-45ea-80f8-84dde42c9e2b" class="bulleted-list"><li>若是首次触碰的“新连接”，欢迎套接字会对该连接分配资源，创建新的小信箱，以便于接下来的通信；</li></ul><p id="731727f9-7b02-43ef-99f4-11f19a5ffc2d" class="">TCP 的多路复用机制类比信道的分频复用，在只占用一个端口的情况下，可以应对处理成千上万的请求，将一个端口资源充分利用，使其能够充分发挥性能；</p><p id="93908107-e7a5-4927-b82d-513d9082aa12" class="">在Linux 系统中，将 TCP 链接抽象成文件的读写，一个端口对应一个文件夹， 每新建立一个指向该端口的 TCP 连接，就是新建一个文件；关闭改TCP 连接就是删除对应的文件；TCP 通信就是在系统的引导下，向对应的 TCP 文件进行读写；</p></details></li></ul><ul id="db9f144e-5d85-41ab-8d3c-c9bbe07d0ac1" class="toggle"><li><details open=""><summary>示例</summary><figure id="dffffee9-16e8-49e6-abec-23c6c67a0947" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image4.jpeg"><img style="width:480px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image4.jpeg"/></a></figure><p id="16f02e29-227e-4365-8dc6-b10d3e1df565" class="">如上图，客户端主机 C 向服务器 B 发起了两个 HTTP 连接（分别运行在端口7532 和端口 26145），客户端主机 A 向服务器 B 发起了一个 HTTP 连接（运行在端口 26145）；主机 C 和主机 A 的请求存在源端口相同的情况，但这没有影响，因为服务器B 是通过四元组唯一标识 TCP 连接的，这两个有相同源端口号的连接有不同的源IP，因此仍然可以区分开来；可以看出，所有的向服务器 B 服务端进程的 TCP 请求目的 IP 均为 B、目的端口号均为 80；</p></details></li></ul></details></li></ul><ul id="892f3d35-f9a5-49a4-ae7d-c93fa6dc718e" class="toggle"><li><details open=""><summary>web 服务器与 TCP</summary><p id="f0504100-ac1f-4cf2-88a9-d7d2304abd9d" class="">考虑一台运行 Web 服务器的主机，例如在端口 80 上运行一个 Apache Web 服务器。当客户（如浏览器）向该服务器发送报文段时，所有报文段的目的端口都将为 80。特别是，初始连接建立报文段和承载 HTTP 请求的报文段都有 80 的目的端口。如我们刚才描述的那样，该服务器能够根据源 IP 地址和源端口号来区分来自不同客户的报文段。事实上，当今的高性能 Web 服务器通常只使用一个进程，但是为每个新的客户连接创建一个具有新连接套接字的新线程。（线程可被看作是一个轻量级的子进程。）对于这样一台服务器，在任意给定的时间内都可能有（具有不同标识的）许多连接套接字连接到相同的进程。</p></details></li></ul><h1 id="7f9133bc-066b-45df-849d-b811c242c789" class="">三、无连接传输服务：UDP</h1><ul id="863b9bc8-c6a6-4781-826a-6b10386c6a2f" class="toggle"><li><details open=""><summary>概述</summary><ul id="0d75d617-8788-4f92-934c-16f7808d959e" class="toggle"><li><details open=""><summary>定义</summary><ul id="3f6ffa82-4acf-419b-adfe-5b7af1dd9520" class="bulleted-list"><li>UDP 只是做了运输协议能够做的最少工作。除了复用/分解功能及少量的差错检测外，它几乎没有对 IP 增加别的东西。实际上采用 UDP 的应用程序差不多就是直接与 IP 打交道。</li></ul><ul id="1d899a4e-c8b2-4ed0-a400-a190dd15791c" class="bulleted-list"><li>UDP 从应用进程得到数据，附加上用于多路复用/分解服务的源和目的端口号字段，以及两个其他的小字段，然后将形成的报文段交给网络层。网络层将该运输层报文段封装到一个 IP 数据报中，然后尽力而为地尝试将此报文段交付给接收主机。</li></ul><ul id="f1383a32-7518-4d72-9de3-bdb38b435a51" class="bulleted-list"><li>如果该报文段到达接收主机，UDP 使用目的端口号将报文段中的数据交付给正确的应用进程。</li></ul><ul id="ee25d4c7-b1dc-4ba0-b4d5-50734543f7b6" class="bulleted-list"><li>使用 UDP 时，在发送报文段之前，发送方和接收方的运输层实体之间没有握手。正因为如此，UDP 被称为是无连接的。<figure id="ff7fc61d-9f45-4351-bfff-203ba25a1039" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image5.jpeg"><img style="width:590px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image5.jpeg"/></a></figure></li></ul></details></li></ul><ul id="9a235a97-d756-435b-9367-26fdffbe92bd" class="toggle"><li><details open=""><summary>UDP 的优势</summary><ul id="0838b0c2-df82-460e-a498-1d26e0a4f7e3" class="bulleted-list"><li>无需建立连接，因此 UDP 不会引入建立连接的时延；</li></ul><ul id="6f1c53f7-31cf-4c92-b598-b8ad6004dc29" class="bulleted-list"><li>无连接状态，UDP 不需要像 TCP 一样维护连接状态和跟踪参数，因此UDP 协议的应用程序支持更多的活跃用户；</li></ul><ul id="0a301a17-5cdf-42dd-ba10-210a5b6692df" class="bulleted-list"><li>分组首部开销小，每个 TCP 报文段都有 20 字节的首部开销，而 UDP 仅有 8 字节的开销。</li></ul></details></li></ul></details></li></ul><ul id="e241e02a-56d0-41ef-9893-a79551de13a8" class="toggle"><li><details open=""><summary>UDP 报文段结构</summary><figure id="652fb23b-2b6a-4776-bec1-399b0025d8a5" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image6.jpeg"><img style="width:227px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image6.jpeg"/></a></figure><ul id="addc5ec4-1637-4e80-9d3e-cc258d32b432" class="toggle"><li><details open=""><summary>组成</summary><ul id="bf73a49b-864c-4418-858c-cef76402fe1a" class="bulleted-list"><li>源端口号和目的端口号用于传输层的多路分解和多路复用功能的实现；</li></ul><ul id="6bd1f34a-5ba7-43df-a06e-e04c33e5c9e9" class="bulleted-list"><li>长度字段指示 UDP 报文段中的字节数，指明了包括首部在内的 UDP 报文段长度；</li></ul><ul id="94a87b50-5359-4baf-9bd6-daaca024d4c8" class="bulleted-list"><li>接收方使用检验和来检查在该报文段中是否出现了差错；</li></ul><p id="9df24a95-6f8c-4fe8-b20f-c8d0b3b20194" class="">UDP 报文的首部有四个字段，每个字段为两个字节，首部共计 8 字节 64bit</p><figure id="f3053e14-cede-44d1-9a47-745654e91b4b" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/Untitled.png"><img style="width:611px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/Untitled.png"/></a></figure></details></li></ul></details></li></ul><ul id="f004a924-e4d3-4c9c-8748-a10c8610fc57" class="toggle"><li><details open=""><summary>UDP 检验和</summary><ul id="cf3e955f-7130-4121-8e6d-00e94831c855" class="toggle"><li><details open=""><summary>步骤</summary><ul id="3dfcec73-24a4-4a14-9b6f-22d9a6c3aeca" class="bulleted-list"><li>将 UDP 报文中的应用数据划分为多个 16bit 的字；</li></ul><ul id="25265491-8704-488a-a478-fbfe9077376f" class="bulleted-list"><li>将这多个数据字进行累加；</li></ul><ul id="0a306c11-17f2-4532-a1ab-ba0359cbd5aa" class="bulleted-list"><li>累加溢出的进位要回卷：即溢出的进位回卷到最低位再做一次加和操作；<figure id="9296f595-7d82-4ad4-bd2a-b71c3a813c47" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image7.png"><img style="width:700px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image7.png"/></a></figure></li></ul><ul id="83c96e9d-ab68-414e-bcf9-a819b9ba03ae" class="bulleted-list"><li>将所有字累加后得到的<mark class="highlight-red">和取反码</mark>作为累加和放在UDP 数据报的首部；</li></ul><ul id="b856a7b0-b35d-487d-9805-9a57ad7b5471" class="bulleted-list"><li>接收方接收到 UDP 数据包后，重复相同的操作，<mark class="highlight-red">但是最后的和不取反码， 直接与首部中的累加和做加和操作，若不为“1111111111111111”则该UDP 数据包出错；</mark></li></ul></details></li></ul><ul id="3d4ad6fb-45ca-427d-aa60-5c117c543269" class="toggle"><li><details open=""><summary>特点</summary><p id="9ca4fcbb-95e2-4354-b74f-127c051a2181" class="">UDP 的差错检验是一种最基本的最简单的核验方法，存在漏洞，若相邻两个字的 01 进行了对调，是检测不出来的；</p></details></li></ul></details></li></ul><h1 id="1b1c9055-5441-4dbc-a32a-908c2849bdc9" class="">四、可靠数据传输的原理</h1><figure id="fe8e1ce5-64e6-4c1d-b1b3-5a5f25bcda43" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image8.jpeg"><img style="width:672px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image8.jpeg"/></a></figure><p id="05816a42-4291-49f7-bc86-13639338e6d8" class="">在下层协议是不可靠的传输协议 IP 基础上构建可靠传输协议，通过调用𝒓𝒅𝒕_𝒔𝒆𝒏𝒅()函数，可以调用数据传输协议的发送方。在接收端，当分组从信道的接收端到达时，将调用𝒓𝒅𝒕_𝒓<strong>c</strong>𝒗()。当𝑟𝑑𝑡协议想要向较高层交付数据时，将通过调用𝒅𝒆𝒍𝒊𝒗𝒆𝒓_𝒅𝒂𝒕𝒂()来完成。</p><p id="8a441b1a-e94b-43af-8edd-17b5498a95d7" class="">我们的协议也需要在发送端和接收端两个方向上传输分组，除了交换含有待传送的数据的分组之外，<strong>𝑟𝑑𝑡</strong>的发送端和接收端还需往返交换控制分组。𝑟𝑑𝑡的发送端和接收端都要通过调用𝒖𝒅𝒕_𝒔𝒆𝒏𝒅()发送分组给对方（其中<strong>𝑢𝑑𝑡</strong>表示不可靠数据传输）。</p><h2 id="d57970f6-0666-4ee3-acb9-0a3b5fb4d0e4" class="">rdt1.0：经完全可靠信道的可靠数据传输</h2><ul id="780ae181-7b04-4f9e-b182-edec1482f9d3" class="toggle"><li><details open=""><summary>假设</summary><p id="a87e6cb5-c8af-469d-8402-b190f003ddd7" class="">假设数据是单向传输的，并且底层信道是完全可靠的。</p></details></li></ul><ul id="1b0de0da-4ce0-4dac-a2ce-1a99843728f7" class="toggle"><li><details open=""><summary>定义</summary><p id="8a0c4808-5493-4973-b02a-ea9d3192b86b" class="">使用各自的 FSM(有限状态机)描述发送方和接收方的状态及状态转换。由右图可知，此时的发送方和接收方双方的 FSM 都只有一个状态，因此变迁必定是从一个状态返回到自身。<div class="indented"><figure id="649b2a35-bd18-44af-ba89-c57674510f48" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image9.jpeg"><img style="width:336px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image9.jpeg"/></a></figure></div></p><ul id="3be5cee8-5342-4996-9e35-74e007f54919" class="bulleted-list"><li>𝒓𝒅𝒕<strong>的发送端</strong>只通过𝑟𝑑𝑡_𝑠𝑒𝑛𝑑(𝑑𝑎𝑡𝑎)事件接受来自较高层的数据，产生一个包含该数据的分组（ 经由𝑚𝑎𝑘𝑒_𝑝𝑘𝑡(𝑑𝑎𝑡𝑎)动作），并将分组发送到信道中；</li></ul><ul id="d9ab5224-19e6-4cdc-8400-93aada21feae" class="bulleted-list"><li><strong>在接收端，</strong>𝑟𝑑𝑡 通 过𝑟𝑑𝑡_𝑟𝑐𝑣(𝑝𝑎𝑐𝑘𝑒𝑡)事件从底层信道接收一个分组，从分组中取出数据（经由𝑒𝑥𝑡𝑟𝑎𝑐𝑡(𝑝𝑎𝑐𝑘𝑒𝑡, 𝑑𝑎𝑡𝑎) 动作），并将数据上传给较高层（通过𝑑𝑒𝑙𝑖𝑣𝑒𝑟_𝑑𝑎𝑡𝑎(𝑑𝑎𝑡𝑎) 动作）。</li></ul></details></li></ul><h2 id="fff0f9a5-c4e9-4f72-9911-3c76e41b6cf5" class="">rdt2.0：经具有比特差错信道的可靠数据传输</h2><ul id="49a9f6b8-4535-4ca4-afc2-e404a2bcbde1" class="toggle"><li><details open=""><summary>假设</summary><p id="3b4ec0ca-a2a3-40c5-9304-afb6131d94a6" class="">假设数据是单向传输的，底层信道更为实际的模型是分组中的比特可能受损。因此，继续假定所有发送的分组将按其发送的顺序被接收，但是分组中的比特可能受损。</p></details></li></ul><ul id="91e171f9-d9e9-471d-b417-599a1c8ff0a6" class="toggle"><li><details open=""><summary>定义</summary><p id="8c07837c-e82a-4b5d-9142-15d25c7e424e" class="">使用控制报文使得接收方可以让发送方知道哪些内容被正确接收，哪些内容接收有误并因此需要重复。在计算机网络环境中，基于这样重传机制的可靠数据传输协议称为自动重传请求（Automatic Repeat reQuest，ARQ）协议。ARQ 协议还有以下功能：</p><ul id="5dfd0610-dff7-4373-acbd-ce919cbd1025" class="bulleted-list"><li>差错检测<p id="8643b3c7-2115-4e0a-b195-1b16c6020a51" class="">需要一种机制以使接收方检测到何时出现了比特差错，改技术要求有额外的比特（除了待发送的初始数据比特之外的比特），这些比特将被汇集在 rdt2.0 数据分组的分组检验和字段中。</p></li></ul><ul id="ba293290-ed43-44ed-a608-34ef2d1e5045" class="bulleted-list"><li>接收方反馈<p id="2cd36d35-9fcd-46e9-9181-d0128d45358a" class="">发送方要了解接收方情况（此时为分组是否被正确接收）的唯一途径就是让接收方提供明确的反馈信息给发送方。rdt2.0 协议将从接收方向发送方回送 ACK(确认肯定)与 NAK(否定确认)分组。理论上，这些分组只需要一个比特长：如用 0 表示 NAK，用 1 表示 ACK。</p></li></ul><ul id="8891eb99-1d79-4679-9d71-09a4979ca7eb" class="bulleted-list"><li>重传<p id="aefa9148-aea9-4c58-be92-dc3f7844a3f0" class="">接收方收到有差错的分组时，发送方将重传该分组文。因此发送方有发出数据包的缓存机制。</p></li></ul></details></li></ul><ul id="f88b7c13-12ad-4c71-afbd-86d208054f47" class="toggle"><li><details open=""><summary>Rdt2.0 FSM</summary><figure id="27dff4d9-9408-433b-bebd-d6d9d85202fb" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/Untitled%201.png"><img style="width:981px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/Untitled%201.png"/></a></figure><ul id="88678b04-5fb0-4640-b27a-5b4b9edae0e5" class="toggle"><li><details open=""><summary>Rdt2.0 发送方</summary><p id="d9d23d30-a589-4100-b3cd-552913bb6960" class="">rdt2.0 的发送端有两个状态。</p><ol id="a8a017ed-8e12-450a-b52c-eaf0f5f1a35d" class="numbered-list" start="1"><li>在最左边的状态中，<strong>发送端协议正等待来自上层传下来的数据</strong>。当产生𝑟𝑑𝑡_𝑠𝑒𝑛𝑑(𝑑𝑎𝑡𝑎)事件时，发送方将使用𝑚𝑎𝑘𝑒_𝑝𝑘𝑡()函数产生一个包含待发送数据的分组(𝑠𝑛𝑑𝑝𝑘𝑡)，带有检验和（然后经由𝑢𝑑𝑡_𝑠𝑒𝑛𝑑(𝑠𝑛𝑑𝑝𝑘𝑡)操作发送该分组。</li></ol><ol id="da1eaa1d-eb3c-4d70-be30-afaa32d038c8" class="numbered-list" start="2"><li>在最右边的状态中，<strong>发送方协议等待来自接收方的 ACK 或 NAK 分组</strong>:<p id="48cad462-7eed-4b81-8e84-0824b5efb1d8" class="">如果收到一个ACK分组（ 𝑟𝑑𝑡_𝑟c𝑣(𝑟c𝑣𝑝𝑘𝑡)&amp;&amp;𝑖𝑠𝐴𝐶𝐾(𝑟c𝑣𝑝𝑘𝑡) 对应该事件），则发送方知道最近发送的分组已被正确接收，因此协议返回到等待来自上层的数据的状态。如果收到一个 NAK 分组，该协议重传最后一个分组并等待接收方为响应重传分组而回送的ACK 和NAK。<mark class="highlight-red">注意到下列事实很重要：当发送方处于等待 ACK 或 NAK 的状态时，它不能从上层获得更多的数据；这就是说，𝑟𝑑𝑡_𝑠𝑒𝑛𝑑(𝑑𝑎𝑡𝑎)事件不可能出现；仅当接收到 ACK 并离开该状态时才能发生这样的事件。因此，发送方将不会发送一块新数据，除非发送方确信接收方已正确接收当前分组。由于这种行为，rdt2.0 这样的协议被称为停等（stop- and-wait）协议。</mark></p></li></ol></details></li></ul><ul id="298d7554-e825-4231-8668-048bfb0a06a5" class="toggle"><li><details open=""><summary>Rdt2.0 接收方</summary><p id="bdce62fa-4074-4bc3-a0e1-2723d896ffe0" class="">rdt2.0 接收方的 FSM 仍然只有一个状态。当分组到达时， 接收方要么回答一个 ACK，要么回答一个 NAK，这取决于收到的分组是否受损</p></details></li></ul></details></li></ul><h2 id="e55ba5ea-b859-41e1-b675-3ba47852fa8b" class="">rdt2.1：考虑到 ACK/NAK 的破损</h2><ul id="c9210da7-022a-455c-aa66-26c0890c550f" class="toggle"><li><details open=""><summary>Rdt2.0 的缺陷</summary><p id="87ed8788-ea51-4f4c-968a-4f18e66c8818" class="">Rdt2.0 没有考虑到 ACK 或 NAK 分组受损的可能性！考虑处理受损 ACK 和 NAK 时的 3 种可能性：</p><ul id="ac32a7ea-11ec-488a-9d61-e19408e64c42" class="bulleted-list"><li>对于第一种可能性，考虑在口述报文情况下人可能的做法。如果说话者不理解来自接收方回答的“OK”或“请重复一遍”， 说话者将可能问“你说什么？”（因此在我们的协议中引入了 一种新型发送方到接收方的分组）。接收方则将复述其回答。但是如果说话者的“你说什么？”产生了差错，情况又会怎样 呢？接收者不明白那句混淆的话是口述内容的一部分还是一 个要求重复上次回答的请求，很可能回一句“你说什么？”。于是，该回答可能含糊不清了。显然，我们走上了一条困难重重之路。</li></ul><ul id="58db50e4-6bab-4c9d-b00f-d7e62d22ae94" class="bulleted-list"><li>第二种可能性是增加足够的检验和比特，使发送方不仅可以检测差错，还可恢复差错。对于会产生差错但不丢失分组的信道，这就可以直接解决问题。</li></ul><ul id="f458a327-f837-413c-b5b7-4ef606774395" class="bulleted-list"><li>第三种方法是，当发送方收到含糊不清的 ACK 或 NAK 分组时，只需重传当前数据分组即可。这种方法除了引入了冗余分组（ duplicate packet），而且接收方无法确认其回复的 ACK/NAK 是否被接收方正确接收，从而接收方无法区分开发送方回传的是重传的旧包还是新包。</li></ul></details></li></ul><ul id="8051b160-e41c-4530-a175-6ef2231ed8a8" class="toggle"><li><details open=""><summary>解决方案</summary><p id="0367d5cc-a0b5-4531-9a4f-dfc8ca37f92e" class="">在数据分组中添加一新字段，即将发送数据分组的<mark class="highlight-red">序号</mark>（sequence number） 放在该字段。于是，接收方只需要检查序号即可确定收到的数据包是上次的重传还是新包。对于采用停等协议的情况下，采用 1bit 的 0/1 即可区分，因为信道中的数据包只可能是重传的旧包和新包两种情况。</p></details></li></ul><ul id="9709a69a-317e-464c-afa4-c2752bdd025f" class="toggle"><li><details open=""><summary>假设</summary><p id="1031f5e9-cc6b-402d-86f6-b9017285e81b" class="">假定信道不丢分组，则 ACK 和 NAK 分组本身不需要指明它们要确认的分组序号。发送方默认所接收到的 ACK 和 NAK 分组（无论是否是含糊不清的）是为响应其最近发送的数据分组而生成的。</p></details></li></ul><ul id="c4bc9938-2474-438f-a7d1-e1b6db071d88" class="toggle"><li><details open=""><summary>Rdt2.1 FSM</summary><figure id="2d6e7afb-aa83-4324-affa-8d990830b284" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/Untitled%202.png"><img style="width:528px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/Untitled%202.png"/></a></figure><figure id="e0e7dea9-d1b8-492a-a6c5-9328782a9ca1" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/Untitled%203.png"><img style="width:672px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/Untitled%203.png"/></a></figure><ul id="d37b8a72-db84-4d9b-ab31-d90d7c0bc3ef" class="bulleted-list"><li>Rdt2.0 发送方会把包序号 0/1 和校验和封装在数据包中，用于接收方的数据包校验；</li></ul><ul id="5db8b559-0203-445a-b3b8-841db994eb88" class="bulleted-list"><li>发送方的停等待：<ul id="53a4f0ed-db81-417c-a8f3-e78dd86e2348" class="bulleted-list"><li>在<strong>接收到 NCK</strong> 或者<strong>一个模糊不清的“坏包”时</strong>都会停等待，并且重发最近发出的数据包；</li></ul></li></ul><ul id="f6e52260-5c3e-44ac-be97-204f7e0abaf4" class="bulleted-list"><li>接收方的停等待：<ul id="e6a13b38-ce71-4f98-bc46-3cd73d0b7c5e" class="bulleted-list"><li>当接收方<strong>接收到的是一个坏包</strong>，则进入停等待并且回复 NCK 数据包；</li></ul><ul id="3b720881-c797-44df-b92e-a72887f2f56b" class="bulleted-list"><li>当接收方<strong>接收到的包是一个正确的包，但是通过序号得知该包是发送方重发的旧包</strong>，此时接收方回复一个 ACK 数据包同时丢弃掉这个旧包。出现这个情况的原因是接收方之前回复的 ACK 数据包没有被发送方正确的接收，导致发送方重发数据包；</li></ul></li></ul></details></li></ul><h2 id="f6f149b4-85f8-4a06-9547-e99ef1ab80c6" class="">rdt2.2：取消接收方的 NCK 回复</h2><ul id="376f4a27-e60e-4c44-b06b-a052dcd847ae" class="toggle"><li><details open=""><summary>引入</summary><p id="e7bed98d-2bc6-43d5-b4ca-5e843ff2a589" class="">如果不发送 NAK，而是针对上次正确接收的分组再发送一个 ACK，则发送方会接收到对同一个分组的两个 ACK（即接收冗余 ACK（duplicate ACK））后，就知道接收方没有正确接收到跟在被确认两次的分组后面的分组。</p></details></li></ul><ul id="49b2a895-4e33-4b2e-af49-c3a0dd7274a8" class="toggle"><li><details open=""><summary>定义</summary><p id="6bc2c730-a3b0-4576-b147-2b5e12ffeeee" class="">rdt2.2 是在有比特差错信道上实现的一个无NAK 的可靠数据传输协议，rdt2.1和 rd2.2 之间的细微变化在于：接收方此时必须包括由一个 ACK 报文所确认的分组序号（这可以通过在接收方 FSM 中，在𝑚𝑎𝑘𝑒_𝑝𝑘𝑡()中包括参数 ACK0 或 ACK1 来实现），发送方此时必须检查接收到的 ACK 报文中被确认的分组序号（这可通过在发送方 FSM 中，在𝑖𝑠𝐴𝐶𝐾()中包括参数 0 或 1 来实现）。</p></details></li></ul><ul id="6c4ae0d7-1014-4544-934a-9c184860e754" class="toggle"><li><details open=""><summary><strong>Rdt2.2 FSM</strong></summary><figure id="f3a2151b-973e-42cc-a981-06aa803288b9" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image17.png"><img style="width:528px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image17.png"/></a></figure><figure id="2dacc683-6654-4620-85d7-725a05e9bc8b" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image18.png"><img style="width:672px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image18.png"/></a></figure><p id="b6402874-2c5e-4e2e-9877-1158a6f48828" class="">rdt2.2 与 2.1 的区别就在于去掉了 NAK，而是在 ACK 消息中显示的加入被确认分组的序列号，接收方通过 ACK 告知最后一个被正确接收的分组，发送方收到重复 ACK 或坏包后，采取重传当前分组：</p><ul id="0ab2f5a3-d102-4fd7-ad3e-9442b2597120" class="bulleted-list"><li>正常流程是 A 发数据包 0，B 正确收到回发 ACK0，A 继续发数据包 1，B 正确收到回发 ACK1……；</li></ul><ul id="63d01085-a14b-4d8b-a2eb-8f0dc302efdc" class="bulleted-list"><li><strong>若 A 发出的数据包 0 后 B 没有正确收到即坏包</strong>，则 B 应该回发 ACK1， 说明最后一次正确收到的包是上一个的数据包 1，仍在等待本次的数据包 0；</li></ul><ul id="b05c0a67-95b8-4003-8a79-d2b9c19485e5" class="bulleted-list"><li><strong>若 A 发出数据包 0 收到的回复却是 ACK1 或者坏包</strong>，说明 A 之前发出的数据包 0 损坏或者 B 的回应数据包 ACK 损坏，此时 A 重传数据包 0；</li></ul><ul id="d2fe9b28-4bbc-4174-a394-a706014345c0" class="bulleted-list"><li><strong>若 B 正确接收数据包 0 后回发 ACK0，本应等待接收数据包 1，但却接收到数据包 0</strong>，说明 B 之前发出的 ACK0 损坏，导致 A 重发了冗余的数据包 0，此时 B 应当再次回应 ACK0（最后一次的正确包），并等待 ACK1；</li></ul></details></li></ul><h2 id="563c9e7c-0117-4834-9a87-2c61d15f290a" class="">rdt3.0：经具有比特差错的丢包信道的可靠数据传输</h2><ul id="5362e2eb-16a8-4ca1-aa95-915a27e86c34" class="toggle"><li><details open=""><summary>引入</summary><p id="33fb5729-e7ab-4138-b028-940be04ff718" class="">采取让发送方负责检测和恢复丢包工作：假定发送方传输一个数据分组，该分组或者接收方对该分组的 ACK 发生了丢失，在这两种情况下，发送方都不可能收到应当到来的接收方的响应。此时， 当超过确定的时间长度 T 发送方仍未收到回复时，发送方自动进行重传操作。</p></details></li></ul><ul id="4211c3e9-2f55-47b4-be67-b94b6aa709b1" class="toggle"><li><details open=""><summary>问题</summary><p id="1aca4485-3ad1-4c8c-9cef-cafabeaa1b24" class="">超时时间长度的确定至关重要，发送方至少需要等待这样长的时间：即发送方与接收方之间的一个往返时延（可能会包括在中间路由器的缓冲时延）加上接收方处理一个分组所需的时间。发送方明智地选择一个时间值，以判定可能发生了丢包（尽管不能确保）。如果在这个时间内没有收到 ACK，则重传该分组。</p></details></li></ul><ul id="289cae13-4daa-42c9-9b55-c4cce3876597" class="toggle"><li><details open=""><summary><strong>Rdt3.0 FSM</strong></summary><figure id="8c67dd33-71f7-4d0c-8bd2-eaf34edf24fc" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image19.png"><img style="width:480px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image19.png"/></a></figure><ul id="e0eb1295-a2e5-4096-8fa9-3452e4f4dcbe" class="bulleted-list"><li>发送方发出一个分组时，计时器开始计时，当接收到的回应不是想要的回应时，发送方不立即做处理，而是等待计时器超时的时候自动重发并重置计时器；</li></ul><ul id="387b159a-7087-4c0c-a738-a2f53260c59f" class="bulleted-list"><li>当发送方得到想要的回应时，停止计时，等待下一次的上层调用；</li></ul><ul id="5f555adc-717b-46fa-b659-56875072e06b" class="block-color-orange bulleted-list"><li>当在等待上层调用时，即左上角和右下角的状态，此时不应该收到数据包，若收到数据包，说明是上一个数据包发送过程中出现的大延时 ACK 分组，直接接收后丢弃即可；</li></ul><ul id="1aa72f05-5b49-4289-91f9-1f28e059c5c1" class="bulleted-list"><li>注意，优秀的超时时间选择，不应该出现上一轮的 ACK0 回应数据包在本轮的数据包 0 的发送期间接收到，<strong>即位于右上三角的 ACK 应答包不能在越过左下三角的时间区间后再次出现在右上三角区的时间区间内，本轮的数据包不可用超过其所在的上下三角区</strong>；</li></ul><p id="a3f1b390-9cf8-4ca9-8108-08be1a0be124" class=""><mark class="highlight-red">rdt3.0的接收方和rdt2.2的接收方一样，在此就直接搬运了。</mark></p><figure id="29fd427d-6aff-4e53-984a-d7cc4c6c206c" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image18.png"><img style="width:528px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image18.png"/></a></figure></details></li></ul><ul id="49084659-9673-45eb-a3c6-b7688f2ab05f" class="toggle"><li><details open=""><summary><strong>Rdt3.0 的运行时序图</strong></summary><figure id="b3087159-1305-4afb-88a4-09a0b9e217a9" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/Untitled%204.png"><img style="width:1099px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/Untitled%204.png"/></a></figure><figure id="5f69c055-bbdd-4156-a034-f96eb7b86868" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/Untitled%205.png"><img style="width:1068px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/Untitled%205.png"/></a></figure></details></li></ul><h2 id="bb74ecb9-6c22-4c48-a3ad-004f81e980b3" class=""><strong>流水线可靠数据传输协议</strong></h2><ul id="4fa2f5de-61e8-445c-8576-2833fa5ad565" class="toggle"><li><details open=""><summary><strong>Rdt3.0 的性能瓶颈</strong></summary><p id="3028e997-d1b5-4cde-895d-16acaa47d6d3" class="">为了评价停等行为对性能的影响，可考虑一种具有两台主机的理想化场合， 一台主机位于美国西海岸，另一台位于美国东海岸，在这两个端系统之间的光速往返传播时延 RTT 大约为 30 毫秒。假定彼此通过一条发送速率 R 为 1Gbps（每秒 1e9 比特）的信道相连。包括首部字段和数据的分组长 L 为 1000 字节（8000 比特），发送一个分组进入 1Gbps 链路实际所需时间是：</p><figure id="ab6022c9-e190-4de2-b085-f7a164e02790" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/Untitled%206.png"><img style="width:351px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/Untitled%206.png"/></a></figure><p id="b691fd0d-bfbd-4770-b73d-5fbdb902ad7d" class="">如果发送方在 t=0 时刻开始发送分组，则在𝑡 = 𝐿/𝑅 = 8𝜇𝑠后，最后 1 比特数据进入了发送端信道。该分组经过 15ms 的穿越国家的旅途后到达接收端，该分组的最后 1 比特在时刻𝑡 = 𝑅𝑇𝑇/2 + 𝐿/𝑅 = 15.008𝑚𝑠时到达接收方。为了简化起见，假设 ACK 分组很小（以便我们可以忽略其发送时间），接收方一旦收到一个数据分组的最后 1 比特后立即发送 ACK，ACK 在时刻𝑡 = 𝑅𝑇𝑇 +𝐿/𝑅 = 30.008𝑚𝑠时在发送方出现。此时，发送方可以发送下一个报文。</p><p id="2a7b3407-f699-48c1-874c-52bb30b4f3ed" class="">因此，在 30.008ms 内，发送方的发送只用了 0.008ms。如果我们定义发送方（或信道）的利用率（utilization）为：发送方实际忙于将发送比特送进信道的那部分时间与发送时间之比，分析表明了停等协议有着非常低的发送方利用率𝑈𝑠𝑒𝑛𝑑𝑒𝑟：</p><figure id="a83763ae-4f5d-4c06-8dcb-1252c3651cf7" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/Untitled%207.png"><img style="width:424px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/Untitled%207.png"/></a></figure><figure id="edcd11ab-404a-4e91-8348-646d195065b5" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image21.jpeg"><img style="width:576px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image21.jpeg"/></a></figure><p id="559c2e9e-5e2e-4051-a445-89a7c96e9ee1" class="">这就是说，发送方只有万分之 2.7 时间是忙的。从其他角度来看，发送方在 30.008ms 内只能发送 1000 字节，即使有1Gbps 的链路可用，有效的吞吐量仅为 267kbps。</p></details></li></ul><ul id="ff459867-2624-41de-9054-bd9f8d601877" class="toggle"><li><details open=""><summary>解决方案</summary><figure id="62518e2a-4d6f-4dcc-a84c-b49125a220fd" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image22.jpeg"><img style="width:576px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image22.jpeg"/></a></figure><p id="26cea1ff-8769-44ed-bd46-be9bf898ad41" class="">不使用停等方式运行，允许发送方发送多个分组而无需等待确认，如右图显示了如果发送方可以在等待确认之前发送 3 个报文，其利用率也基本上提高 3 倍。因为许多从发送方向接收方输送的分组可以被看成是填充到一条流水线中，故这种技术被称为流水线（pipelining）。流水线技术对可靠数据传输协议可带来如下影响：</p><ul id="6ff74b4e-c850-4837-88d1-7333d8654c14" class="bulleted-list"><li>必须增加数据包的序号范围，一次传输中的数据包不止 rdt3.0 中的 0/1两种；</li></ul><ul id="285f610f-d6d5-4e85-b33f-651c7ee5724a" class="bulleted-list"><li>采用流水线协议：发送方需要缓存已发送但是未确认接收的分组 或者接收方缓存已经正确接收的分组；</li></ul></details></li></ul><h2 id="9fbeea1c-86f0-4195-8ddf-cf00736a38dd" class="">流水线的差错恢复方法 1 出错全部重传(Go Back N,GBN)</h2><ul id="a69471e4-9d04-4c6d-ab1b-85df0f7a6e62" class="toggle"><li><details open=""><summary>定义</summary><p id="86553ec5-f7ca-497d-b0f2-2a7ba9b2f3e8" class="">在出错全部重传（GBN）协议中，允许发送方发送多个分组（当有多个分组可用时）而不需等待确认，但它也受限于在流水线中未确认的分组数不能超过某个最大允许数 N。采用累计应答。</p><figure id="8fe1ac4f-4b35-446a-9e7e-fbea08539457" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image23.png"><img style="width:700px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image23.png"/></a></figure></details></li></ul><ul id="e0e29b33-2c49-40fb-926a-6c2a4f12ec8c" class="toggle"><li><details open=""><summary>GBN 发送方</summary><ul id="d98328f7-7376-4108-b3fb-ff0ed293af98" class="bulleted-list"><li>𝑺𝒆𝒏𝒅_𝑩𝒂𝒔𝒆<strong>：</strong>基序号，定义为最早的未被确认接收的分组；</li></ul><ul id="bf6ddf95-718a-4fc0-b026-8261b6d61c2a" class="bulleted-list"><li>𝒏𝒆𝒙𝒕𝒔𝒆𝒒𝒏𝒖𝒎<strong>：</strong>下一个序号，定义为最小的未使用分组的序号，即下一个待发出分组的序号；</li></ul><ul id="479a0aca-7b24-4596-ae23-9c81ba2e06ba" class="bulleted-list"><li>𝑾𝒊𝒏𝒅𝒐𝒘𝒔 𝑺𝒊𝒛𝒆<strong>：</strong>窗口长度，协议允许的最大的未被确认接收的分组数量；𝑆𝑒𝑛𝑑_𝐵𝑎𝑠𝑒和𝑛𝑒𝑥𝑡𝑠𝑒𝑞𝑛𝑢𝑚把区间分成了四个部分：</li></ul><ul id="59cbf516-8efe-4b64-93f8-4f85164e081e" class="bulleted-list"><li>[𝟎, 𝑺𝒆𝒏𝒅 𝑩𝒂𝒔𝒆 − 𝟏]<strong>：</strong>已经发生并且已经确认接收的分组；</li></ul><ul id="6bc733cf-92cd-4685-952f-8efb75ea1285" class="bulleted-list"><li>[𝑺𝒆𝒏𝒅 𝑩𝒂𝒔𝒆, 𝒏𝒆𝒙𝒕𝒔𝒆𝒒𝒏𝒖𝒎 − 𝟏]<strong>：</strong>已经发送但是未被确认的分组；</li></ul><ul id="7172f5ff-272e-45ed-b31b-adb2aded0e1d" class="bulleted-list"><li>[𝒏𝒆𝒙𝒕𝒔𝒆𝒒𝒏𝒖𝒎, 𝑺𝒆𝒏𝒅 𝒃𝒂𝒔𝒆 + 𝑵 − 𝟏]<strong>：</strong>即将要发送的分组，下层递交数据后即可发送；</li></ul><ul id="4e164983-faf5-48b1-9225-3f40ba4f6c9c" class="bulleted-list"><li>尾部剩下的，只有当窗口滑动到其范围内才可以发送；</li></ul></details></li></ul><ul id="827d2a0b-75d4-4ddb-a463-75f600bc1555" class="toggle"><li><details open=""><summary>GBN 发送方扩展 FSM 描述</summary><figure id="34ea30d0-59ae-45e1-9a4f-4d7c7b8a84c3" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image24.jpeg"><img style="width:576px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image24.jpeg"/></a></figure><ul id="60711618-2571-4414-8a0b-ed77f9c8f501" class="bulleted-list"><li>初始化，定义 base 和𝑛𝑒𝑥𝑡𝑠𝑒𝑞𝑛𝑢𝑚为 1；</li></ul><ul id="f4716a37-45e9-4896-8099-160f5e7c8e39" class="bulleted-list"><li>上层的调用：<p id="3b2ff008-ac0c-460a-b836-a2fcf8721380" class="">当上层调用𝑟𝑑𝑡_𝑠𝑒𝑛𝑑()时，发送方首先检查发送窗口是否已满，即是否有N 个已发送但未被确认的分组。如果窗口未满，则产生一个分组封装序号、数据和校验和，并将其发送，然后将𝑛𝑒𝑥𝑡𝑠𝑒𝑞𝑛𝑢𝑚后移 1 位。<mark class="highlight-orange">另外，还需要判断此时的𝑛𝑒𝑥𝑡𝑠𝑒𝑞𝑛𝑢𝑚前面是否还有未确认的分组，若无应当重置计时器，计时新的窗口起点。（base==nextseqnum）</mark>如果窗口已满，发送方只需将数据返回给上层，隐式地指示上层该窗口已满。然后上层可能会过一会儿再试。</p></li></ul><ul id="41d7fd71-9211-4748-9b2f-781c6e3fa52c" class="bulleted-list"><li>接收到 ACK：<p id="c6bd842b-cd79-41ba-b240-0f61c8bb1344" class="">在 GBN 协议中，对序号为 n 的分组的确认采取累积应答的方式，表明接收方已正确接收到序号为 n 的以前且包括 n 在内的所有分组。接收到正确 ACK 后，提取其序号，将 base 指针移动到该序号的后一个序号位置上，<mark class="highlight-red">若 base 和 next 重合，说明已经没有待确认的分组，</mark>停止计时器，否则此时在等待一个新的窗口起始分组，应重启计时器。（未在图中体现）当接收到的 ACK 小于当前的 base 指针指向的分组时（说明该 ACK 是经过大时延到达发送方的 ACK），直接丢弃该分组即可，因为 base 指针之前的分组一定是已经正确接收的。（未在图中体现）当接收到的 ACK 是重复的 ACK 时，说明之前的包没有正确接收到，应当重传所有已发送但是未确认的包，而不是重启计时器后等待超时，这个操作应该的继承的 rdt3.0 即什么也不做等待计时器超时。</p></li></ul><ul id="95190730-18c0-4b6a-be20-6d4881bdabd5" class="bulleted-list"><li>超时事件：如果出现超时，发送方重传所有已发送但还未被确认过的分组。发送方仅使用一个定时器，它可被当作是最早的已发送但未被确认的分组所使用的定时器。</li></ul></details></li></ul><ul id="e48d084b-35bf-4857-a17d-d0b44c02f428" class="toggle"><li><details open=""><summary>GBN 接收方扩展 FSM 描述</summary><figure id="6fb992be-c135-423f-b379-69d3c5824848" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image25.jpeg"><img style="width:700px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image25.jpeg"/></a></figure><ul id="6f4f53b4-4612-4399-8285-cb0fe123b6b5" class="bulleted-list"><li>初始化：<p id="2a772990-9db0-46f4-aa88-69d019e98b40" class="">初始化下一个按序接收的分组序号为 1，封装好初始应答 ACK 包即 ACK 0（上图有误）</p></li></ul><ul id="35c35d43-28e5-4c97-9478-436e87b4486b" class="bulleted-list"><li>正确接收：<p id="cf16a0af-66b8-433e-bd2a-1f72344afe9b" class="">如果一个序号为 n 的分组被正确接收到，并且是按序的（即上次交付给上层的数据是序号为 n-1 的分组），则接收方为分组 n 发送一个 ACK n，并将该分组中的数据部分交付到上层。</p></li></ul><ul id="979c8a33-f973-46f2-a79c-2a2f053c57c1" class="bulleted-list"><li>错误接收：<p id="fb91685b-58b4-4b4c-a03f-ecd9f4a49964" class="">在所有其他情况下，接收方丢弃该分组，并为最近按序接收的分组重新发送 ACK，告诉发送方，目前接收方已经正确接收的分组的最大序号。</p></li></ul></details></li></ul><ul id="672b51c3-c5c2-4cf8-800e-eacfc0c68b73" class="toggle"><li><details open=""><summary>GBN 协议的特点</summary><ul id="ae6dd5d3-fb4d-4224-a72a-fc488d4a7e78" class="bulleted-list"><li>造成了大量的 ACK 包冗余，从而存在数据包冗余的情况；</li></ul><ul id="81bc1242-e1d3-4dc7-b33f-49d44cf2f37e" class="bulleted-list"><li>接收方不需要缓存任何数据包，只需要维护一个变量，记录下一个按序接收的包是几号；</li></ul></details></li></ul><ul id="bcfeae24-40f7-47a1-9c96-b983cb7702f9" class="toggle"><li><details open=""><summary>GBN 协议示例</summary><figure id="0bbdbc61-a272-401b-93f4-d43aed6880da" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image26.jpeg"><img style="width:480px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image26.jpeg"/></a></figure><p id="5c6a892d-981d-4034-92e0-cdae263677af" class="">窗口长度为 4 个分组的 GBN 协议的运行情况。因为该窗口长度的限制，发送方发送分组 0~3，然后在继续发送之前，必须等待直到一个或多个分组被确认。当接收到每一个连续的 ACK（例如 ACK0 和 ACK1）时，该窗口便向前滑动，发送方便可以发送新的分组（分别是分组 4 和分组 5）。在接收方，分组 2 丢失，因此分组 3、4 和 5 被发现是失序分组并被丢弃。</p></details></li></ul><h2 id="e777d6ad-a542-4a07-90b3-a03efaeeac99" class="">流水线的差错恢复方法 2 选择重传(Selective Repeat，SR)</h2><ul id="baf00d43-ce9d-41a6-a69d-0d70a9d27083" class="toggle"><li><details open=""><summary>SR 协议的引入</summary><p id="9b3af3c0-dc09-4833-960b-0419e6d7b8be" class="">GBN 本身也有一些情况存在着性能问题，尤其是当窗口长度和带宽时延积都很大时，单个分组的差错就能够引起 GBN 重传大量分组，然而许多分组根本没有必要重传。随着信道差错率的增加，流水线可能会被这些不必要重传的分组所充斥。</p></details></li></ul><ul id="f54e5e13-6ca1-464e-9511-60fe2acda3d2" class="toggle"><li><details open=""><summary>SR 协议的定义</summary><p id="fb0057af-d568-4437-9487-f0c7597a4710" class="">选择重传（SR）协议通过让发送方仅重传那些它怀疑在接收方出错（即丢失或受损）的分组而避免了不必要的重传。这种个别的、按需的重传要求接收方逐个地确认正确接收的分组。再次用窗口长度 N 来限制流水线中未完成、未被确认的分组数。<div class="indented"><figure id="c43882d5-34f8-48ec-9b80-445bc1ed05fb" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image27.png"><img style="width:576px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image27.png"/></a></figure></div></p></details></li></ul><ul id="05b20000-0258-4d73-b994-91974f4f8d8a" class="toggle"><li><details open=""><summary>SR 协议的发送方动作：</summary><ul id="a73529cb-4d04-4f37-92cf-e689446935e7" class="bulleted-list"><li>从上层收到数据：<p id="e7369c19-1839-4e4f-800d-dde8d58dee87" class="">当从上层接收到数据后，SR 发送方检查下一个可用于该分组的序号。如果序号位于发送方的窗口内，则将数据打包并发送；否则就像在 GBN 中一样，要么将数据缓存，要么将其返回给上层以便以后传输。</p></li></ul><ul id="637e09e0-37a4-4606-9c52-0f00155c328b" class="bulleted-list"><li>超时：<p id="3cf197cd-2216-4a4e-a978-ceee0a4bbcb9" class="">定时器再次被用来防止丢失分组。然而，现在每个分组必须拥有其自己的逻辑定时器，因为超时发生后只能发送一个分组。</p></li></ul><ul id="7973617d-95e9-460a-a1d0-8cbe5776a15d" class="bulleted-list"><li>收到 ACK：<p id="3de1146d-bb66-4c94-8723-de8f17494232" class="">如果收到 ACK，倘若该分组序号在窗口内，则 SR 发送方将那个被确认的分组标记为已接收。如果该分组的序号等于𝑠𝑒𝑛𝑑_𝑏𝑎𝑠𝑒，则窗口基序号向后移动到具有最小序号的未确认分组处。如果窗口移动了并且有序号落在窗口内的未发送分组， 则发送这些分组。</p></li></ul></details></li></ul><ul id="fb177c4d-8ea6-482e-9f6b-d22bf56c4c03" class="toggle"><li><details open=""><summary>SR 协议的接收方动作：</summary><ul id="b3d7e9fb-176f-401f-940c-bfaf1ecb358c" class="bulleted-list"><li><strong>正确接收：</strong><p id="1afb94c1-0caa-456c-854b-ef81cc18f3da" class="">序号在[𝑟c𝑣_𝑏𝑎𝑠𝑒，𝑟c𝑣_𝑏𝑎𝑠𝑒 + 𝑁 − 1]内的分组被正确接收。在此情况下， 收到的分组落在接收方的窗口内，一个选择 ACK 被回送给发送方。如果该分组以前没收到过，则缓存该分组。如果该分组的序号等于接收窗口的基序号， 则该分组以及以前缓存的序号连续的（起始于𝑟𝑐𝑣_𝑏𝑎𝑠𝑒的）分组交付给上层。然后，接收窗口按向前移动分组的编号向上交付这些分组。举例子来说，当收到一个序号为𝑟c𝑣_𝑏𝑎𝑠𝑒 = 2的分组时，该分组及已经接收并缓存分组 3、4、5 可被交付给上层。</p></li></ul><ul id="3affd2ec-85ce-431d-8d0e-08a0fa214412" class="bulleted-list"><li>“善意的谎言”：<p id="1acb9ed1-2e9a-4d9e-b676-4fd36d09f64b" class="">序号在[𝑟c𝑣_𝑏𝑎𝑠𝑒 − 𝑁，𝑟c𝑣_𝑏𝑎𝑠𝑒 − 1]内的分组被正确收到。在此情况下， 必须产生一个 ACK，即使该分组是接收方以前已确认过的分组。即对已经正确接收的分组再次进行 ACK 确认应答。</p></li></ul><ul id="94a3bbf2-aeec-4ebe-86b5-c1e3fb8b76f8" class="bulleted-list"><li>其他情况：<p id="1100d468-88f4-413d-9ac4-0e48b3152c04" class="">忽略该分组，即坏包</p><figure id="3480c55c-f82a-4d09-bf82-863ffaa9f5d4" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image28.jpeg"><img style="width:672px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image28.jpeg"/></a></figure><p id="51906aaa-d6f5-4080-ba2d-3132e3596d9e" class="">当分组 2 丢失时，由于发送方接收不到 ACK2，导致分组 2 的计时器超时，从而促成了分组 2 的重发。<mark class="highlight-orange">当分组 2 被正确接收后，与已经正确接收并缓存的分组 3、4、5 组成了连续分组，一起递交上层，同时发送方的窗体滑动至 6 号分组处。</mark></p></li></ul></details></li></ul><ul id="c70f2259-4ae7-49fb-a6da-df41f786b722" class="toggle"><li><details open=""><summary>SR 协议的异步性及造成的问题：</summary><figure id="42dca73d-88b5-4ccc-a769-7459b09a81ab" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image29.jpeg"><img style="width:384px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image29.jpeg"/></a></figure><p id="6ca8a5aa-6099-4cbc-90f1-c379a74cfa1b" class="">由于 ACK 分组的发送时延问题， 可能接收方的窗口已经向后滑动了， 而发送方的ACK 因为还在路上没被接收到，因此发送方的窗口序号会小于接收方；如右图 b 情况所示，当接收方正确接收到包 0、1、2 后，接收方的窗口向后滑动到第 3、4、5 个分组，序号为 3 0 1。若接收方返回的 ACK 全部丢失，<mark class="highlight-orange">则重传回的标号为 0 的第一个分组会被误认为是标号为 0 的第五个分组被正确接收，导致数据错误。</mark></p><p id="d5279c4f-6cb4-4192-bfce-0fe575f4f4eb" class="">根据一些数论中的推导，窗口的长度必须小于或者等于序号空间大小的一半：若序号空间是 0/1/2/3，则窗口大小为 2 或者小于 2 才不会发生混乱。</p></details></li></ul><h2 id="55e15734-8968-415a-9fa6-c7242234ceef" class="">总结</h2><figure id="198a7635-cee7-4318-b66c-0e6c8d5d3f54" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image30.jpeg"><img style="width:672px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image30.jpeg"/></a></figure><p id="0832f3ac-1e88-4a9d-898b-41787bee642e" class="">
</p><h1 id="286c0fbe-3c55-4159-afcd-6e44bdad0514" class="">五、面向连接传输：TCP</h1><h2 id="4ad78eaf-9f4c-4c2d-8850-b047d1a77d83" class=""><strong>TCP 连接</strong></h2><ul id="f2e14352-d977-4dd1-9ce7-25dec2516f33" class="toggle"><li><details open=""><summary>TCP 的概览</summary><ul id="3de6bc89-9752-4849-95aa-b6e28fe39f65" class="bulleted-list"><li>TCP 被称为是面向连接的（connection-oriented），这是因为在一个应用进程可以开始向另一个应用进程发送数据之前，这两个进程必须先相互“握手”，即它们必须相互发送某些预备报文段，以建立确保数据传输的参数。</li></ul><ul id="e1769632-0a72-4da3-9e56-cbfbac3a34da" class="bulleted-list"><li>完全运行在端系统的协议<p id="a852a429-95d6-4111-8e9d-77249c2c1468" class="">TCP 的连接状态完全保留在两个端系统中。由于 TCP 协议只在端系统中运行，而不在中间的网络元素（路由器和链路层交换机）中运行，所以中间的网络元素不会维持 TCP 连接状态。事实上，中间路由器对 TCP 连接完全视而不见，它们看到的是数据报，而不是连接。</p></li></ul><ul id="12787c68-0c64-411c-b618-e423b79842b5" class="bulleted-list"><li>全双工服务<p id="014037ef-614f-4829-a7d4-eeb5617f104b" class="">如果一台主机上的进程 A 与另一台主机上的进程 B 存在一条 TCP 连接， 那么应用层数据就可在从进程 B 流向进程 A 的同时，也从进程 A 流向进程B。</p></li></ul><ul id="804a4a4a-be01-49ed-9949-b24b9422ab3f" class="bulleted-list"><li>点对点通信<p id="f3fc430f-6245-4800-8153-4d6cc85abc34" class="">TCP 通信是在单个发送方与单个接收方之间的连接。所谓“多播”，即在一次发送操作中，从一个发送方将数据传送给多个接收方，对 TCP 来说这是不可能的。</p></li></ul></details></li></ul><ul id="c6e86518-a0cc-438d-a394-e51b56be35ea" class="toggle"><li><details open=""><summary>TCP 的三次握手</summary><p id="541ba670-86f5-4e7a-b084-207ba9357c36" class="">客户首先发送一个特殊的 TCP 报文段，服务器用另一个特殊的 TCP 报文段来响应，最后，客户再用第三个特殊报文段作为响应。前两个报文段不承载“有效载荷”，也就是不包含应用层数据；而第三个报文 段可以承载有效载荷。由于在这两台主机之间发送了 3 个报文段，所以这种连接建立过程常被称为三次握手</p><figure id="2eedcac8-b0cc-4980-bd90-c133dd880b48" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image31.jpeg"><img style="width:571px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image31.jpeg"/></a></figure></details></li></ul><ul id="76b6221e-5692-4dde-a399-669d16de5abf" class="toggle"><li><details open=""><summary><strong>TCP 的发送过程</strong></summary><ul id="7e0d3c12-e24f-4c38-a8b3-ffe536ca6639" class="bulleted-list"><li>客户端应用进程通过套接字这道门向外传递数据流；</li></ul><ul id="470fda45-f1e6-4173-968a-761179798869" class="bulleted-list"><li>经过套接字这道门， 数据就由 TCP 协议控制；</li></ul><ul id="9218b542-b829-4534-b563-c7c22b9d742c" class="bulleted-list"><li>TCP 首先将这些数据引导到该连接的<strong>发送缓存（send buffer）</strong>里，发送缓存是在三次握手初期设置的缓存之一；</li></ul><ul id="747f13a2-9d1b-44f7-9215-37ed0849154a" class="bulleted-list"><li>接下来 TCP 就会不时从发送缓存里取出一块数据；<ul id="440be1e0-ae46-4f2b-b4c9-c524f364ea4f" class="bulleted-list"><li>TCP 从发送缓存中取出的数据数量受限于 <strong>最大报文段长度</strong>（Maximum Segment Size，MSS），即在报文段里应用层数据的最大长度，不包括 TCP 头部；</li></ul><ul id="fe2af2ff-6072-4b7d-9500-2d498f36b551" class="bulleted-list"><li>MSS 通常根据最初确定的由本地发送主机发送的最大链路层帧长度（即所谓的最大传输单元（Maximum Transmission Unit，MTU））来设置，即 MSS 受限于下层的链路层封装的包最大长度；</li></ul><ul id="cda04f8e-9c2a-40ae-bc56-235d209a7f9d" class="bulleted-list"><li>设置该 MSS 要保证一个 TCP 报文段（当封装在一个 IP 数据报中） 加上 <strong>TCP/IP 首部长度（通常 40 字节）</strong>将适合单个链路层帧。以太网和 PPP 链路层协议都具有 1500 字节的MTU，因此 <strong>MSS 的典型值为 1460 字节</strong>；</li></ul></li></ul><ul id="87bdd738-8e9a-48b9-a9b3-db5dac583e05" class="bulleted-list"><li>TCP 为每块客户数据配上一个TCP 首部，从而形成多个 <strong>TCP 报文段</strong>（TCP<strong> </strong>segment），这些报文段被下传给网络层，网络层将其分别封装在网络层IP 数据报中。然后这些 IP 数据报被发送到网络中；</li></ul><ul id="9443fef4-8ba5-4eda-af6b-6a5c1480bfdf" class="bulleted-list"><li>TCP 接收端接收到一个报文段后，该报文段的数据就被放入该 TCP 连接的接收缓存中，应用程序从此缓存中读取数据流；<ul id="b291cc47-b0f1-49d0-ad5e-8a4f2f91a590" class="bulleted-list"><li>主机 A 可以作为 TCP 发送端和接收端，并且可以同时存在多个 TCP链接，每个 TCP 链接都有其各自独立发送/接收缓存；</li></ul></li></ul></details></li></ul><h2 id="60040e90-aacf-4010-b3c8-31ed2f51b422" class="">TCP 报文段结构</h2><ul id="a701696b-f698-4a8b-bd24-508c0f6493fb" class="toggle"><li><details open=""><summary>TCP 报文段的具体字段及其含义</summary><figure id="fd9d7c7f-66f8-45be-b66c-17047c212a98" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image32.jpeg"><img style="width:576px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image32.jpeg"/></a></figure><figure id="2361195c-45db-4b26-8b73-0b9c19ac1b62" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image33.jpeg"><img style="width:432px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image33.jpeg"/></a></figure><ul id="54a207c3-21bd-4ea3-8d1a-5ca23305d758" class="bulleted-list"><li><strong>源端口号和目的端口号: </strong>指明该 TCP 连接的源/目的进程；</li></ul><ul id="e4e2ba41-22de-495c-97c2-fff5c8c6dd1b" class="bulleted-list"><li><strong>检验和</strong>：和 UDP 协议一样的校验和；</li></ul><ul id="272f734a-fd05-4d84-8676-4f08ee4e8c16" class="bulleted-list"><li>32 比特的<strong>序号字段</strong>和 32比特的<strong>确认号字段</strong>。这些字段被 TCP 发送方和接收方用来实现可靠数据传输服务；</li></ul><ul id="01eb43c1-5c13-489e-a023-3211e0d6c524" class="bulleted-list"><li>16 比特的<strong>接收窗口字段，</strong>该字段用于<mark class="highlight-red">流量控制</mark>，该字段用于指示接收方愿意接受的字节数量。</li></ul><ul id="8ca67027-bbfd-4273-8530-1b8386059533" class="bulleted-list"><li>可选与变长的选项字段（options field），该字段用于发送方与接收方协商最大报文段长度（MSS）时，或在高速网络环境下用作窗口调节因子时使用， 该字段中还定义了一个时间戳选项；</li></ul><ul id="11c840a4-01e1-4100-9b81-8b20bc774875" class="bulleted-list"><li>6 比特的标志字段（flag field）：<ul id="d13b1e8a-24fb-49e7-8d13-39124c9f3b75" class="bulleted-list"><li>ACK 字段用于指示确认字段中的值是有效的，即该报文段包括一个对已被成功接收报文段的确认；</li></ul><ul id="828fde15-a98c-420d-b71b-35e7299df9cf" class="bulleted-list"><li>RST、SYN 和 FIN 字段用于 TCP 连接建立和拆除，<mark class="highlight-red">SYN=1 表示客户端意图和服务器建立 TCP 连接，FIN=1 表示拆除当前的 TCP 连接；</mark></li></ul><ul id="72f631f7-f797-48a2-9fec-83668cc911e0" class="bulleted-list"><li>当 PSH 比特被设置的时候，就指示接收方应立即将数据交给上层；</li></ul><ul id="74edac87-8808-4e3b-8cb7-699c6b2b597a" class="bulleted-list"><li>最后，URG 比特用来指示报文段里存在着被发送端的上层实体置为“紧急”的数据。紧急数据的最后一个字节由 16 比特的紧急数据指针字段指出。当紧急数据存在并给出指向紧急数据尾的指针的时候，TCP 必须通知接收端的上层实体；在实践中，PSH、URG 和紧急数据指针并没有使用。为了完整性起见，我们才提到这些字段）；</li></ul></li></ul></details></li></ul><ul id="008e9fce-7720-44ae-a2ba-98f64bb26cf8" class="toggle"><li><details open=""><summary>序号（sequence number）和确认号（acknowledgment number）</summary><p id="a7f044e9-5bcb-4a02-80d3-accde862582d" class="">TCP 把数据看成一个无结构的、有序的字节流，序号是建立在<strong>传送的字节流</strong>之上，而不是建立在传送的报文段的序列先后顺序之上。</p><ul id="c20b42b2-92a6-459e-a35b-397bcddb0e1a" class="bulleted-list"><li>序号<p id="78ee754e-0f77-487f-870a-c48418bfc68a" class="">序号指示当前 TCP 报文段中应用数据<mark class="highlight-red">在整个文件数据字节流中的次序</mark>。</p><ul id="ddf13e14-59b0-4370-ab6b-0c5101aa8a8f" class="bulleted-list"><li>例如:<p id="c5b8017e-7914-4c40-9dd5-5ad315faae87" class="">假设主机 A 上的一个进程想通过一条 TCP 连接向主机 B 上的一个进程发送一个数据流。主机 A 中的 TCP 将隐式地对数据流中的每一个字节编号。假定数据流由一个包含 500000 字节的文件组成，其 MSS 为 1000 字节，数据流的首字节编号是 0，该 TCP 将为该数据流构建 500 个报文段：给第一个报文段分配序号 0，第二个报文段分配序号 1000，第三个报文段分配序号 2000，以此类推。每一个序号被填入到相应 TCP 报文段首部的序号字段中。</p><figure id="a55b9f1f-f4ca-4e77-b41e-11cc32dd1978" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image34.jpeg"><img style="width:637px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image34.jpeg"/></a></figure></li></ul></li></ul><ul id="7587ab07-322d-443d-9dfd-d1e2d99ed06f" class="bulleted-list"><li>确认号<p id="db8e7e31-6595-4e6d-837d-03303496213d" class="">TCP 是全双工的，因此主机 A 在向主机 B 发送数据的同时，也许也接收来自主机 B 的数据：从主机 B 到达的每个报文段中都有一个序号用于标识 B 流向 A 的数据次序；主机 A 填充进报文段的确认号是主机 A 期望从主机 B 收到的下一字节的序号。</p><p id="bbbbc7fc-61cc-458a-a93d-d02e53518868" class="">例如：假设主机 A 已收到了来自主机 B 的编号为 0~535 的所有字节，正在等待主机 B 的数据流中字节 536 及之后的所有字节。所以主机 A 就会在它发往主机 B 的报文段的确认号字段中填上 536，A 在向 B 发送数据的同时也在向 B 发送了ACK 确认信息一箭双雕~</p><figure id="b9568711-73d2-415e-8a0a-d8f542278f55" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image35.png"><img style="width:576px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image35.png"/></a></figure><p id="6bc64b5a-5903-4f59-9b3f-313c42cc97e9" class="">再如：假设主机 A 已收到一个来自主机 B 的包含字节 0~535 的报文段，以及另一个包含字节900~1000 的报文段。由于某种原因，主机A 还没有收到字节536~899 的报文段。主机 A 为了重新构建主机 B 的数据流，仍在等待字节 536（和其后的字节）。因此，A 到 B 的下一个报文段将在确认号字段中包含 536。因为 TCP 只确认该流中正确接收的最后一个字节，即确认号为 X 表明 X 号之前的包全部被正确接收， 所以 TCP 被称为提供<strong>累积确认</strong></p></li></ul></details></li></ul><ul id="42566ece-9469-4969-85c7-5e811b07cded" class="toggle"><li><details open=""><summary>失序包的处理</summary><p id="4c277803-5e0a-45f3-9d4f-7c5516375cdd" class="">TCP 协议并没有为此明确规定任何规则，而是把这一问题留给实现 TCP 的编程人员去处理，在实践中采用：接收方保留失序的字节，并等待缺少的字节以填补该间隔</p></details></li></ul><ul id="12e7fea4-55cb-4dfa-a756-a97ed713cb1a" class="toggle"><li><details open=""><summary>首次发送初始的 seq 选择</summary><p id="e035eaaf-18eb-4f72-bd19-d7c485dc1342" class="">上例中假设初始序号为 0。事实上，一条 TCP 连接的双方均可随机地选择初始序号。这样做可以减少将那些仍在网络中存在的来自两台主机之间先前已终止的连接的报文段，误认为是后来这两台主机之间新建连接所产生的有效报文段的可能性。</p></details></li></ul><ul id="6c855226-45ff-4b4d-838f-027a7b464ee0" class="toggle"><li><details open=""><summary>Telnet 案例</summary><figure id="878f38c4-79ff-4b26-8a41-40e9c0dc8e3e" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image36.png"><img style="width:384px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image36.png"/></a></figure><p id="11094a96-6344-491e-97b9-6338effcaae1" class="">如图所示，假设客户和服务器的起始序号分别是 42 和 79。因此，客户发送的第一个报文段的序号为 42，服务器发送的第一个报文段的序号为79。</p><ul id="35a7e951-55ad-42bf-81c5-9b7ec2bf089d" class="bulleted-list"><li>第一个报文段是由客户发往服务器：<ul id="923dd9ab-1f98-45dc-9c3c-41d79a7a3c1c" class="bulleted-list"><li>Seq=42，因为这是客户端的第一个数据包；</li></ul><ul id="b0c69459-f98b-43da-bd84-ef50a07d1ca4" class="bulleted-list"><li>Ack=79，因为客户端还没有接收过数据包，在等待服务器的第一个数据包；</li></ul><ul id="374bf0f6-30a0-4749-bc29-35fcca5eabf5" class="bulleted-list"><li>应用数据为字符‘C’；</li></ul></li></ul><ul id="9bfa74df-2655-4489-8dcf-fdd3e91576dd" class="bulleted-list"><li>第二个报文段是由服务器发往客户：<ul id="d096ecfd-f0ab-4a55-8e6e-c21f38745d47" class="bulleted-list"><li>用 Ack=43 确认上一个seq=42 的数据包已经正确接收，并且在等待seq=43；</li></ul><ul id="23cf63ae-b815-4842-a279-655f26137a0c" class="bulleted-list"><li>用 seq=79 指明本数据包的序号；</li></ul></li></ul><ul id="e2f08df5-25b5-43ee-ae7f-8c0bb66fb554" class="bulleted-list"><li>第三个报文段是从客户发往服务器的：<ul id="1754a556-8a95-4b24-a268-b8ffc47672a3" class="bulleted-list"><li>用 ack=80 表明 seq=79 的数据包已经成功接收，并且等待 seq=80；</li></ul><ul id="f48611d1-49fc-44fb-9f60-19925a5c3d00" class="bulleted-list"><li>用 seq=43 指明本数据包的序号；</li></ul></li></ul></details></li></ul><h2 id="f3b202be-4e7d-4e00-ba4d-15c6d6788708" class="">往返时间 RTT 估计与超时处理</h2><ul id="92a2f496-f498-46bc-bf0b-71bd26e610b0" class="toggle"><li><details open=""><summary>基本前提</summary><p id="335a6f08-7083-4688-9ca4-1612d7e21b80" class="">超时间隔必须大于该连接的往返时间（RTT），即从一个报文段发出到它被确认的时间，否则会造成不必要的重传。</p></details></li></ul><ul id="b721ab39-e305-4177-8005-cc8be840822d" class="toggle"><li><details open=""><summary>估计往返时间</summary><p id="6df7d065-d647-4711-8a4c-50d4b4f03dd7" class="">使用选取报文段测量其 RTT 作为𝑆𝑎𝑚𝑝𝑙𝑒𝑅𝑇𝑇样本 RTT 的方法进行往返时间的近似估算。</p><ul id="1ff17ba3-bfbb-4d01-b30c-77e1692fb28e" class="bulleted-list"><li><strong>样本 RTT：</strong>𝑺𝒂𝒎𝒑𝒍𝒆𝑹𝑻𝑻<strong>：</strong>报文段的样本 RTT 就是从某报文段被发出（即交给下层的 IP 协议）到对该报文段的确认（ACK）被收到之间的时间量。<p id="0ad6b24e-f053-457b-a64a-aa47db35b884" class="">大多数 TCP 的实现仅在某个时刻做一次𝑺𝒂𝒎𝒑𝒍𝒆𝑹𝑻𝑻测量，而不是为每个发送的报文段测量一个𝑺𝒂𝒎𝒑𝒍𝒆𝑹𝑻𝑻。这就是说，在任意时刻，仅为一个已发送的但目前尚未被确认的报文段估计𝑆𝑎𝑚𝑝𝑙𝑒𝑅𝑇𝑇，从而产生一个接近每个 RTT 的新𝑆𝑎𝑚𝑝𝑙𝑒𝑅𝑇𝑇值。不关心这个报文是发送到哪，只是这个数据包恰好在𝑆𝑎𝑚𝑝𝑙𝑒𝑅𝑇𝑇取样的时候发出，因此将它作为样本进行测量。</p><p id="a48e7acb-cc11-4111-9626-407795f2d446" class="">另外，TCP 决不为已被重传的报文段计算𝑺𝒂𝒎𝒑𝒍𝒆𝑹𝑻𝑻，它仅为传输一次的报文段测量𝑺𝒂𝒎𝒑𝒍𝒆𝑹𝑻𝑻。</p></li></ul></details></li></ul><ul id="ee39464b-cd23-4286-8004-cf03bcf99e1f" class="toggle"><li><details open=""><summary>估计往返时间的科学估算公式</summary><ul id="1c61a50f-4d22-4eca-a6f1-8f5108332753" class="toggle"><li><details open=""><summary><strong>使用</strong>𝑺𝒂𝒎𝒑𝒍𝒆𝑹𝑻𝑻<strong>计算</strong>𝑬𝒔𝒕𝒊𝒎𝒂𝒕𝒆𝒅𝑹𝑻𝑻</summary><p id="2ff679e5-de69-4e25-9a52-fb448a1968f0" class="">显然，由于路由器的拥塞和端系统负载的变化，不同时刻测得的𝑆𝑎𝑚𝑝𝑙𝑒𝑅𝑇𝑇 值会随之波动。 因此，任何给定的𝑆𝑎𝑚𝑝𝑙𝑒𝑅𝑇𝑇值也许都是非典型的。为了估计一个典型的 RTT，要对不同时刻取得的𝑆𝑎𝑚𝑝𝑙𝑒𝑅𝑇𝑇 进行处理——TCP 维持一个𝑺𝒂𝒎𝒑𝒍𝒆𝑹𝑻𝑻均值（称为𝑬𝒔𝒕𝒊𝒎𝒂𝒕𝒆𝒅𝑹𝑻𝑻）。</p><figure id="90e502aa-bc83-46ec-8b1e-3358df4b8ca9" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image37.jpeg"><img style="width:700px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image37.jpeg"/></a></figure><p id="61da534e-2910-4821-8f69-27b5331448a4" class="">每当获得一个新𝑺𝒂𝒎𝒑𝒍𝒆𝑹𝑻𝑻 时，TCP 就会根据下列公式来更新修正𝑬𝒔𝒕𝒊𝒎𝒂𝒕𝒆𝒅𝑹𝑻𝑻使估算的 RTT 更加贴合此时的网络情况：</p><p id="2f254cdd-cde4-4bc4-88de-a07d42e4b482" class="">𝐸𝑠𝑡𝑖𝑚𝑎𝑡𝑒𝑑𝑅𝑇𝑇 = (1 − 𝛼) ∙ 𝐸𝑠𝑡𝑖𝑚𝑎𝑡𝑒𝑑𝑅𝑇𝑇 + 𝛼 ∙ 𝑆𝑎𝑚𝑝𝑙𝑒𝑅𝑇𝑇在[RFC6298]中给出的𝛼参考值是𝜶 =0.125（即 1/8），</p><p id="a9f35623-bacb-4e3f-ae7a-24ddf4eb21da" class="">这时上面的公式变为：𝐸𝑠𝑡𝑖𝑚𝑎𝑡𝑒𝑑𝑅𝑇𝑇 = 0.875 ∙ 𝐸𝑠𝑡𝑖𝑚𝑎𝑡𝑒𝑑𝑅𝑇𝑇 + 0.125 ∙ 𝑆𝑎𝑚𝑝𝑙𝑒𝑅𝑇𝑇</p><p id="d8d8a4a8-52d6-4562-9a83-31117a301e0d" class="">值得注意的是，𝐸𝑠𝑡𝑖𝑚𝑎𝑡𝑒𝑑𝑅𝑇𝑇是一个𝑆𝑎𝑚𝑝𝑙𝑒𝑅𝑇𝑇值的加权平均值，这个加权平均对最近的样本赋予的权值要大于对老样本赋予的权值。这是很自然的，因为越近的样本越能更好地反映网络的当前拥塞情况。从统计学观点讲，这种平均被称为指数加权移动平均</p></details></li></ul><ul id="f4ce2ff6-01b2-4ef0-9fa8-df0e415a39e5" class="toggle"><li><details open=""><summary><strong>计算</strong>𝑫𝒆𝒗𝑹𝑻𝑻</summary><p id="2c63cbbd-2523-48da-9028-c69351c86aa3" class="">除了估算 RTT 外，测量 RTT 的变化也是有价值的。[RFC6298]定义了 RTT 偏差𝐷𝑒𝑣𝑅𝑇𝑇，用于估算𝑆𝑎𝑚𝑝𝑙𝑒𝑅𝑇𝑇一般会偏离𝐸𝑠𝑡𝑖𝑚𝑎𝑡𝑒𝑑𝑅𝑇𝑇的程度：𝐷𝑒𝑣𝑅𝑇𝑇 = (1 − 𝛽) ∙ 𝐷𝑒𝑣𝑅𝑇𝑇 + 𝛽 ∙ |𝑆𝑎𝑚𝑝𝑙𝑒𝑅𝑇𝑇 − 𝐸𝑠𝑡𝑖𝑚𝑎𝑡𝑒𝑑𝑅𝑇𝑇|注意到𝐷𝑒𝑣𝑅𝑇𝑇是一个𝑆𝑎𝑚𝑝𝑙𝑒𝑅𝑇𝑇与𝐸𝑠𝑡𝑖𝑚𝑎𝑡𝑒𝑑𝑅𝑇𝑇之间差值的指数加权移动平均（EWMA）。如果𝑆𝑎𝑚𝑝𝑙𝑒𝑅𝑇𝑇值波动较小，那么𝐷𝑒𝑣𝑅𝑇𝑇的值就会很小；另一方面，如果波动很大，那么𝐷𝑒𝑣𝑅𝑇𝑇的值就会很大。𝛽的推荐值为 0.25。</p></details></li></ul></details></li></ul><ul id="7c42bb86-7a53-4bb6-8133-d5b5bd7ed967" class="toggle"><li><details open=""><summary>设置和管理重传超时间隔</summary><p id="9a42f243-0c1b-45f3-8e44-50538eb48b09" class="">首先，超时间隔应该大于等于𝐸𝑠𝑡𝑖𝑚𝑎𝑡𝑒𝑑𝑅𝑇𝑇，否则，将造成不必要的重传。但是超时间隔也不应该比𝐸𝑠𝑡𝑖𝑚𝑎𝑡𝑒𝑑𝑅𝑇𝑇大太多，否则当报文段丢失时，TCP 不能很快地重传该报文段，导致数据传输时延大。因此要求将超时间隔设为𝐸𝑠𝑡𝑖𝑚𝑎𝑡𝑒𝑑𝑅𝑇𝑇加上一定余量：</p><ul id="cf1d1309-06f0-4198-9a04-1eadc82910d9" class="bulleted-list"><li>当𝑆𝑎𝑚𝑝𝑙𝑒𝑅𝑇𝑇值波动较大时，即𝐷𝑒𝑣𝑅𝑇𝑇较大，这个余量应该大些；</li></ul><ul id="3e103788-e99e-4fb7-b4d5-12a4d7acd033" class="bulleted-list"><li>当波动较小时，即𝐷𝑒𝑣𝑅𝑇𝑇较小时，这个余量应该小些； 因此采用如下公式计算超时时间：𝑇𝑖𝑚𝑒𝐼𝑛𝑡𝑒𝑟𝑣𝑎𝑙 = 𝐸𝑠𝑡𝑖𝑚𝑎𝑡𝑒𝑑𝑅𝑇𝑇 + 4 ∙ 𝐷𝑒𝑣𝑅𝑇𝑇</li></ul></details></li></ul><h2 id="43443f55-bbf9-4514-a9e5-d8f9fd81fa46" class="">可靠数据传输</h2><ul id="8c6fac0d-d4be-4d39-a79d-98ad7bc55ffa" class="toggle"><li><details open=""><summary>TCP 可靠数据传输的概述</summary><ul id="2484c6b5-0e6e-48b6-8c8b-1fd62f9bea44" class="bulleted-list"><li>建立在不可靠的 IP 协议基础上<p id="a43f8efe-dc1e-4ffa-918e-3dbd59a0e7f3" class="">TCP 在 IP 不可靠的尽力而为服务之上创建了一种可靠数据传输服务（reliable data transfer service）。TCP 的可靠数据传输服务确保一个进程从其接收缓存中读出的数据流是无损坏、无间隔、非冗余和按序的数据流；即该字节流与连接的另一方端系统发送出的字节流是完全相同。</p></li></ul><ul id="145bba7f-dc11-40ec-8743-d431745dd5cd" class="bulleted-list"><li>使用单一重传计时器<p id="fb6ac8d1-3225-413f-8a57-d2a900495d61" class="">仅使用单一的重传定时器，即使有多个已发送但还未被确认的报文段。</p></li></ul><ul id="cd3c8c30-b445-44da-b6c8-277bd2574f5c" class="bulleted-list"><li>使用累计确认和流水线可靠数据传输方式</li></ul><ul id="a39dcb6c-7486-44a9-9fd2-31f5543cc556" class="bulleted-list"><li>重传的触发条件：计时器超时和接收到大量重复的 ACK</li></ul></details></li></ul><ul id="06cb6152-0ae8-4ec9-bd9d-8a937134fc60" class="toggle"><li><details open=""><summary>TCP 发送方的简化描述—忽略重复的 ACK、忽略流量控制/拥塞控制</summary><ul id="127e0c7e-aab4-450a-8e65-90a324c9bb90" class="bulleted-list"><li>TCP 发送方处理事件 1——从上层应用程序接收数据：<ul id="34b9bd69-0815-4b43-8b78-8b93670a83f5" class="bulleted-list"><li>创建带有 seq 值的数据报，其中 seq 值为该数据报数据的首字节的文件字节流编号；</li></ul><ul id="14124c0f-0a4d-4515-81c7-86f67010981f" class="bulleted-list"><li>如果定时器还没有为某些其他报文段而运行，则当报文段被传给 IP 时，TCP 就启动该定时器，如果有计时器正在运行，则继续沿用此计时器；<p id="22d77713-5357-4a22-8d68-fd3c7975d5ee" class="">该定时器的过期间隔是𝑇𝑖𝑚𝑒𝑜𝑢𝑡𝑙𝑛𝑡𝑒𝑟𝑣𝑎𝑙，它是由𝐸𝑠𝑡𝑖𝑚𝑎𝑡𝑒𝑑𝑅𝑇𝑇和𝐷𝑒𝑣𝑅𝑇𝑇计算得出的；</p></li></ul></li></ul><ul id="cd630caf-5b7a-4db3-b78b-b8d0df34e316" class="bulleted-list"><li>TCP 发送方处理事件 2——定时器超时：<ul id="73416081-995a-43c2-8f63-92dc0e716fd8" class="bulleted-list"><li>TCP 通过“重传引起超时的报文段”来响应超时事件，随后 TCP 重启计时器；</li></ul></li></ul><ul id="08aabbb5-c97c-4f6e-ae39-12023df50c3f" class="bulleted-list"><li>TCP 发送方处理事件 3——收到 ACK：<ul id="b96cd2af-8541-4efe-834a-784c64b85711" class="bulleted-list"><li>当该事件发生时，TCP 将 ACK 的值 y 与它的变量𝑆𝑒𝑛𝑑𝐵𝑎𝑠𝑒进行比较：</li></ul><ul id="a7604f66-c319-4b71-8bc3-82cb8092482f" class="bulleted-list"><li>TCP 状态变量𝑆𝑒𝑛𝑑𝐵𝑎𝑠𝑒 是最早未被确认的字节的序号， 同理𝑆𝑒𝑛𝑑𝐵𝑎𝑠𝑒 − 1是指接收方已经正确按序接收的最后一个字节的序号；</li></ul><ul id="0bd651b8-de15-4cfb-888d-be6d3071daf4" class="bulleted-list"><li>TCP 采用累积确认，所以 y 确认了字节编号在 y 之前的所有字节都已经收到：<ol id="091d0976-e107-455b-9d48-3aee562dbe97" class="numbered-list" start="1"><li>即如果 y&gt;𝑆𝑒𝑛𝑑𝐵𝑎𝑠𝑒，则该 ACK 是在确认一个或多个先前未被确认的报文段，因此发送方更新它的𝑆𝑒𝑛𝑑𝐵𝑎𝑠𝑒变量；</li></ol><ol id="b20e3e14-1dd0-4b16-a002-b9741c391a3e" class="numbered-list" start="2"><li>如果当前有未被确认的报文段，TCP 还要重新启动定时器。<figure id="b969e7ac-c476-4768-ba62-88820302bfaf" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image38.jpeg"><img style="width:697px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image38.jpeg"/></a></figure></li></ol></li></ul></li></ul></details></li></ul><ul id="90eea250-afa8-4192-8217-9dc5d84e6561" class="toggle"><li><details open=""><summary>TCP 发送方超时事件的应对</summary><ul id="b573610d-1786-42fe-960b-dcc5cb5afae4" class="bulleted-list"><li>情况 1——ACK 应答丢失<p id="4996b1f3-a146-4aa1-b69e-531f96d31378" class="">主机 A 向主机 B 发送一个报文段。Seq=92，data length=8 字节。在发出该报文段之后，主机 A 等待一个来自主机 B 的确认号为 100 的报文段，但该确认报文丢失。此时报文段 92 的超时事件发生，主机 A 会重传相同的报文段，当主机 B 收到该重传的报文段时，通过序号发现该报文段包含了早已收到的数据。因此，主机 B 中的 TCP 将丢弃该报文段。</p></li></ul><ul id="9520ae67-7199-4ea0-8891-5111f9786306" class="bulleted-list"><li>情况 2——过早超时（超时时间过短）<p id="69bbd499-9d6e-400e-9512-7607e37e7936" class="">主机 A 发送两个报文段：seq=92 和 seq=100 的两个数据包。由于网络时延过大/超时时长过短，在 ACK100 和 ACK120 正确接收之前 seq=92 的计时器已经超时，从而导致了 seq=92 的重传并且重启计时器。当然，若在超时之前 ACK120 被正确接收，则 seq=100 不会被重传。</p><figure id="408ab7fc-d442-4881-975f-7e7896870373" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image39.jpeg"><img style="width:624px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image39.jpeg"/></a></figure></li></ul><ul id="d229cff7-b29e-4aa0-a086-5f6b918f6a51" class="bulleted-list"><li>情况 3——累计应答 ACK<p id="febe0954-d472-40e7-a0d2-7bba035bc22c" class="">假设主机 A 与在第二种情况中完全一样，发送两个报文段。第一个报文段的确认报文在网络丢失，但在超时事件发生之前主机 A 收到一个确认号为 120 的确认报文。主机 A 因而知道主机 A 主机 B 已经收到了序号为 119 及之前的所有字节；所以主机 A 不会重传这两个报文段中的任何一个。</p><figure id="9d570145-c1d3-4adf-b22d-e359afd4ab21" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image40.jpeg"><img style="width:240px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image40.jpeg"/></a></figure></li></ul></details></li></ul><ul id="f33bc384-1158-4e70-afa0-65172220671b" class="toggle"><li><details open=""><summary>超时间隔加倍</summary><p id="53dccfff-039d-46e6-af45-a771c3a3cd0b" class="">每当超时事件发生时，TCP 重传具有最小序号的还未被确认的报文段。只是每次 TCP 重传时都会将下一次的超时间隔设为先前值的两倍，而不是用从𝐸𝑠𝑡𝑖𝑚𝑎𝑡𝑒𝑑𝑅𝑇𝑇和𝐷𝑒𝑣𝑅𝑇𝑇推算出的值。</p><p id="c2a0e4eb-dc0a-4e69-b599-92556a097b65" class="">注意，超时间隔加倍仅发生在发送方重传数据包时，而当发送方因为上层正常调用而启动计时器或者接收到ACK 更新计时器时，计时器的𝑻𝒊𝒎𝒆𝒐𝒖𝒕𝒍𝒏𝒕𝒆𝒓𝒗𝒂𝒍是由最近的𝑬𝒔𝒕𝒊𝒎𝒂𝒕𝒆𝒅𝑹𝑻𝑻 值与𝑫𝒆𝒗𝑹𝑻𝑻值推算得到。</p><p id="3d73a9d1-855f-4031-b726-391f7cf2feeb" class="">假设：</p><p id="28cf03f5-587b-4c12-808b-9b5415a082e6" class="">当定时器第一次过期时， 与最早的未被确认的报文段相关联的𝑇𝑖𝑚𝑒𝑜𝑢𝑡𝑙𝑛𝑡𝑒𝑟𝑣𝑎𝑙是 0.75 秒。TCP 就会重传该报文段，并把新的过期时间设置为1.5 秒。如果 1.5 秒后定时器又过期了，则 TCP 将再次重传该报文段，并把过期时间设置为 3.0 秒。因此，超时间隔在每次重传后会呈指数型增长。</p></details></li></ul><ul id="7f0d5448-0df6-4ede-a652-5068f7ad0bc4" class="toggle"><li><details open=""><summary>快速重传</summary><ul id="7b5a2d56-3123-42d9-94ff-d08528c12947" class="bulleted-list"><li><strong>超时重传中的问题</strong><p id="e701d589-15a9-435c-a257-66a75096669c" class="">超时触发重传存在的问题之一是超时周期可能相对较长。当一个报文段丢失时，这种长超时周期迫使发送方延迟重传丢失的分组，因而增加了端到端时延。</p></li></ul><ul id="af88ec0e-d20b-4f70-83a3-113180d4fefa" class="bulleted-list"><li>冗余 ACK 的产生<p id="459a2e45-d84d-45fd-88cf-4df6cf1b6259" class="">下表是接收方产生 ACK 的策略：</p><p id="3d760cf2-0a36-4358-ba3b-7fc5608c620a" class="">当按序接收报文段时，接收方会延时（500ms）给出 ACK，等待下一个按序到达的包，这样可以节省应答的 ACK 数据包；当 TCP 接收方收到一个序号大于下一个所期望的、按序的报文段，即它检测到了数据流中的一个间隔，这就是说有报文段丢失。这个间隔可能是由于在网络中报文段丢失或重新排序造成的。因为 TCP 不使用否定确认，所以接收方不能向发送方发回一个显式的否定确认。相反，它只是对已经接收到的最后一个按序字节数据进行重复确认（即产生一个冗余 ACK）即可。</p><figure id="024e9d8b-b1cb-497a-a153-153070dd5b9d" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image41.jpeg"><img style="width:700px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image41.jpeg"/></a></figure></li></ul></details></li></ul><ul id="90f627a3-48fc-4016-b415-0d34bdeaa9ec" class="toggle"><li><details open=""><summary>冗余 ACK 解决超时重传的弊端</summary><figure id="80455312-4cd2-48b1-98d3-c65efd7afaef" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image42.png"><img style="width:700px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image42.png"/></a></figure><p id="4d2b6d1e-cac1-451c-9bad-99c0fe6a8d49" class="">因为发送方经常一个接一个地发送大量的报文段，如果一个报文段丢失，就很可能引起许多一个接一个的冗余 ACK。如果 TCP 发送方接收到对相同数据的 3 个冗余 ACK，发送方则认为：跟在这个已被确认过 3 次的报文段之后的报文段已经丢失。此时，TCP 就执行快速重传（fast retransmit），即在该报文段的定时器过期之前重传丢失的报文段。</p></details></li></ul><ul id="2ffda730-076e-4a23-b1dd-16ad0dda8344" class="toggle"><li><details open=""><summary>TCP 协议的错误恢复机制是 GBN 和 SR 混合体</summary><ul id="581dfd40-1258-4e5c-a999-437bd1d173c5" class="bulleted-list"><li><strong>GBN 方法风格的一面</strong><p id="8125ae20-2533-401d-ac00-a4c86b23a776" class="">TCP 的确认是累计确认，TCP 接收方对于正确接收但失序的报文段是不会发送 ACK 应答一一确认的，因此发送方只需要像 GBN 协议一样维护 sendbase 和 next sequence number 两个字段。</p></li></ul><ul id="23e483cf-0542-4e39-90cc-d307e82b5599" class="bulleted-list"><li>与 GBN 的不同<p id="8048a724-f693-4990-a623-7aa721fb02e0" class="">TCP 接收方会缓存正确接收但是失序的报文段。</p><p id="e13412d6-c31a-471f-a9be-cffaab29bf84" class="">TCP 有选择确认机制：允许 TCP 接收方有选择的确认失序报文段，而不是必须等待后确认累计的最后一个报文段。</p></li></ul></details></li></ul><h2 id="7825f6c1-f534-424e-85ac-868c9b5b75c4" class="">流量控制</h2><ul id="8a65c4d9-0cf8-4762-a155-4057a94531d1" class="toggle"><li><details open=""><summary>引入</summary><p id="c0860a1b-f3a5-4643-a11f-54f56b25caa2" class="">当 TCP 连接收到正确、按序的字节后，它就将数据放入接收缓存。相关联的应用进程会从该缓存中读取数据。但不必是数据刚一到达就立即读取。如果某应用程序读取数据时相对缓慢， 而发送方发送得太多、太快，发送的数据就会很容易地使该连接的接收缓存溢出。</p></details></li></ul><ul id="7fa72743-8e03-497c-b104-d53f2f801174" class="toggle"><li><details open=""><summary>流量控制</summary><p id="44715d3b-569d-450b-82bc-999e5b49fd55" class="">TCP 为它的应用程序提供了流量控制服务（flow-control service）以消除发送方使接收方缓存溢出的可能性。流量控制因此是一个速度匹配服务，即发送方的发送速率与接收方应用程序的读取速率相匹配。注意区分于拥塞控制，<mark class="highlight-red">拥塞控制是因为网络拥塞而遏制发送方的发送速率， 流量控制的因为接收方的缓存溢出而遏制发送方的发送速率。</mark></p></details></li></ul><ul id="b7a27b85-8b23-4f5d-87c2-002a979091aa" class="toggle"><li><details open=""><summary>流量控制的原理</summary><figure id="197b446d-26b1-4233-bc24-5ea21881472e" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image43.jpeg"><img style="width:400px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image43.jpeg"/></a></figure><p id="5d4359d2-324f-4b14-9212-5cfb8ff622ef" class="">TCP 通过让发送方维护一个称为接收窗口（receive window）的变量来提供流量控制。通俗地说，接收窗口用于给发送方一个指示——该接收方还有多少可用的缓存空间。因为 TCP 是全双工通信，在连接两端的发送方都各自维护一个接收窗口。假设主机A 通过一条TCP 连接向主机B 发送一个大文件。主机 B 为该连接分配了一个接收缓存，并用𝑅𝑐𝑣𝐵𝑢𝑓𝑓𝑒𝑟来表示其大小。主机 B 上的应用进程不时地从该缓存中读取数据。TCP 不允许接收缓存溢出，必须满足：𝐿𝑎𝑠𝑡𝐵𝑦𝑡𝑒𝑅𝑐𝑣𝑑 − 𝐿𝑎𝑠𝑡𝐵𝑦𝑡𝑒𝑅𝑒𝑎𝑑 ≤ 𝑅𝑐𝑣𝐵𝑢𝑓𝑓𝑒𝑟</p><p id="d851ba03-048e-44b2-9136-80f43f903c2d" class="">其中：<div class="indented"><ul id="32fe5b86-bcb8-4b52-a7c9-57c95554e796" class="bulleted-list"><li>𝐿𝑎𝑠𝑡𝐵𝑦𝑡𝑒𝑅𝑐𝑣𝑑:   主机 B 上的应用进程从缓存读出的数据流的最后一个字节的编号</li></ul><ul id="a18641e4-f67a-4ec3-b459-feffee0c8c10" class="bulleted-list"><li>𝐿𝑎𝑠𝑡𝐵𝑦𝑡𝑒𝑅𝑒𝑎𝑑：从网络中到达的并且已放入主机 B 接收缓存中的数据流的最后一个字节的编号；</li></ul><ul id="3d5d9450-50b9-44b2-ba93-d3f5ee1df22f" class="bulleted-list"><li>则接收窗口𝑟𝑤𝑛𝑑表示为：𝑟𝑤𝑛𝑑 = 𝑅𝑐𝑣𝐵𝑢𝑓𝑓𝑒𝑟 − [𝐿𝑎𝑠𝑡𝐵𝑦𝑡𝑒𝑅𝑐𝑣𝑑 − 𝐿𝑎𝑠𝑡𝐵𝑦𝑡𝑒𝑅𝑒𝑎𝑑]</li></ul><ul id="b5c4d533-a69a-4077-b66d-c6c75a175cd2" class="bulleted-list"><li>由于该空间是随着时间变化，所以𝑟𝑤𝑛𝑑是动态的。</li></ul></div></p></details></li></ul><ul id="aaa66149-16ee-419a-adb8-0be9c82dce12" class="toggle"><li><details open=""><summary>流量控制的工作流程</summary><ul id="2d29da30-d1a3-45fb-9a67-c929fd120171" class="bulleted-list"><li>主机 B 通过把当前的𝑟𝑤𝑛𝑑值放入它发给主机 A 的报文段接收窗口字段中，通知主机 A 它在该连接的缓存中还有多少可用空间。开始时，主机B 设定𝑟𝑤𝑛𝑑 = 𝑅𝑐𝑣𝐵𝑢𝑓𝑓𝑒𝑟；</li></ul><ul id="39eb2a11-32ac-4489-8012-0e96a55aa154" class="bulleted-list"><li>主机 A 轮流跟踪两个变量，𝐿𝑎𝑠𝑡𝐵𝑦𝑡𝑒𝑆𝑒𝑛𝑡和𝐿𝑎𝑠𝑡𝐵𝑦𝑡𝑒𝐴𝑐𝑘𝑒𝑑，这两个变量之间的差𝐿𝑎𝑠𝑡𝐵𝑦𝑡𝑒𝑆𝑒𝑛𝑡 − 𝐿𝑎𝑠𝑡𝐵𝑦𝑡𝑒𝐴𝑐𝑘𝑒𝑑，就是主机 A 发送到连接中但未被确认的数据量，因此发送方 A 必须保证：<p id="7fc6147f-eec7-4baa-8d94-334f3f7ff26c" class="">𝐿𝑎𝑠𝑡𝐵𝑦𝑡𝑒𝑆𝑒𝑛𝑡 − 𝐿𝑎𝑠𝑡𝐵𝑦𝑡𝑒𝐴𝑐𝑘𝑒𝑑 ≤ 𝑟𝑤𝑛𝑑</p></li></ul><ul id="70f2bd56-abd1-4cec-a2aa-79958100867f" class="bulleted-list"><li>注意，流量控制导致了不可能使用完整的物理带宽传输数据；</li></ul><ul id="2068bf6f-6558-4a7e-8b4d-d59b30e0deba" class="bulleted-list"><li>接收缓存是和 TCP 连接一一对应的，不可能把接收方主机的接收缓存区合成一个大的进行接收数据，而且将其切分；</li></ul></details></li></ul><ul id="254967d0-e872-46a8-a0e0-e43bf9a9983d" class="toggle"><li><details open=""><summary>流量控制𝒓𝒘𝒏𝒅方法的问题</summary><p id="625fa630-ada9-41dd-a10a-93bdc510c71b" class="">假设主机 B 的接收缓存已经存满，使得𝑟𝑤𝑛𝑑 = 0。在将𝑟𝑤𝑛𝑑 = 0通告给主机 A 之后，还要假设主机 B 没有任何数据要发给主机 A。如果主机B没有要发给A的数据，那么主机A就永远不可能发数据给B了（它一直以为主机B接收缓存没有空间）</p><p id="6ab2037f-731b-408b-9921-1188987ec5a3" class=""><mark class="highlight-red">TCP 仅当在它有数据或有确认要发时才会发送报文段给主机 A</mark></p><ul id="2a5e826d-5576-4a14-846c-8310e1895564" class="bulleted-list"><li>解决方案<p id="8b19d635-6a4c-4ce5-96a7-1435a5b2dbc5" class="">当主机 B 的接收窗口为 0 时，主机 A 继续发送只有一个字节数据的报文段。这些报文段将会被接收方确认。最终缓存将开始清空，并且确认报文里将包含一个非 0 的𝑟𝑤𝑛𝑑值。</p></li></ul></details></li></ul><h2 id="c9d23b8f-3fb0-498f-acbd-e02f0fc3bf75" class="">TCP 连接管理</h2><ul id="b20eccd4-7405-4d5a-a90b-7e7490607bfc" class="toggle"><li><details open=""><summary>三次握手</summary><ul id="2ad0abd5-cd15-42f3-ad41-a7d34352c9d6" class="toggle"><li><details open=""><summary><strong>第一次握手：</strong></summary><p id="b8b0713b-3d63-4977-b023-eb1cb78a6043" class="">客户端的 TCP 首先向服务器端的 TCP 发送一个特殊的 TCP 报文段。该报文段中不包含应用层数据。<mark class="highlight-red">但是在报文段的首部中的 SYN 标志位被置为 1。因此， 这个特殊报文段被称为 SYN 报文段。</mark></p><p id="5bad5af6-78b2-4e90-9f34-405011a75874" class="">另外，客户会随机地选择一个初始序号(𝒄𝒍𝒊𝒆𝒏𝒕_𝒊𝒔𝒏)，并将此编号放置于该起始的 TCP SYN 报文段的序号字段中。该报文段会被封装在一个 IP 数据报中， 并发送给服务器。</p></details></li></ul><ul id="a3319136-9103-456f-a2d6-0eef9477df94" class="toggle"><li><details open=""><summary>第二次握手：</summary><p id="2badc053-bcac-499e-8f98-04afa9c48952" class="">一旦包含 TCP SYN 报文段的 IP 数据报到达服务器主机，服务器会从该数据报中提取出 TCP SYN 报文段，为该 TCP 连接分配 TCP 缓存和变量，并向该客户TCP 发送允许连接的报文段。</p><p id="b0898aec-3597-4306-a4f0-931803c4d108" class="">这个允许连接的报文段也不包含应用层数据。但是，在报文段的首部却包含3 个重要的信息：</p><ul id="7111c3ef-eeb3-4b92-83ce-5e24ab1ca47b" class="bulleted-list"><li>SYN 比特被置为 1；</li></ul><ul id="4ce63d5d-2759-4f8e-99b4-11c78a105e0d" class="bulleted-list"><li>其次，该 TCP 报文段首部的<strong>确认号字段被置为 client_isn+1</strong>，表明接收端已经接收到了 TCP SYN 报文段，等待序号为 client_isn+1 的报文段；</li></ul><ul id="1cc717d7-04a6-4e30-aad9-fe07bf1bae3e" class="bulleted-list"><li>最后，服务器随机选择自己的初始序号（𝒔𝒆𝒓𝒗𝒆𝒓_𝒊𝒔𝒏），并将其放置到 TCP 报文段首部的序号字段中；这个允许连接的报文段实际上表明了：“我收到了你发起建立连接的 SYN 分组，该分组带有初始序号𝑐𝑙𝑖𝑒𝑛𝑡_𝑖𝑠𝑛。我同意建立该连接。我自己的初始序号是𝑠𝑒𝑟𝑣𝑒𝑟_𝑖𝑠𝑛。”该允许连接的报文段有时被称为 SYN ACK 报文段（SYNACK segment）。</li></ul></details></li></ul><ul id="3a9d2162-13eb-479f-8e93-09b372ea1163" class="toggle"><li><details open=""><summary><strong>第三次握手：</strong></summary><p id="3d961816-e270-4273-adf8-2728f6c28f3e" class="">在收到 SYN ACK 报文段后，客户也要给该连接分配缓存和变量。客户主机则向服务器发送另外一个报文段：</p><p id="ace07e15-35bf-4182-81c8-1edc3660c424" class="">这最后一个报文段对服务器的允许连接的报文段进行了确认（该客户通过将值 server_isn+1 放置到 TCP 报文段首部的确认字段中来完成此项工作）。因为连接已经建立了，所以该 SYN 比特被置为 0。该三次握手的第三个阶段可以在报文段负载中携带客户到服务器的数据。</p><figure id="ba8f9eb7-c84f-4d11-ab03-4a92a4410399" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image44.png"><img style="width:700px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image44.png"/></a></figure></details></li></ul></details></li></ul><ul id="6b0844be-1804-44fa-be5d-c199875788d0" class="toggle"><li><details open=""><summary>四次挥手</summary><figure id="c24c8676-b751-4e07-b274-743e9c4fbd03" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image45.png"><img style="width:480px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image45.png"/></a></figure><ul id="5794c5fc-a261-4f05-ad40-6df120a86dfa" class="bulleted-list"><li>客户应用进程发出一个关闭连接命令。这会引起客户 TCP 向服务器进程发送一个特殊的 TCP 报文段。这个特殊的报文段让其首部中的一个标志位即 FIN 比特被设置为 1；</li></ul><ul id="74bd60d8-062c-4ac8-8699-afb3e56dd580" class="bulleted-list"><li>当服务器接收到该报文段后，就向发送方回送一个确认报文段；</li></ul><ul id="4b98f81c-5df8-49d0-ae9e-9f8ad07c0a05" class="bulleted-list"><li>然后，服务器发送它自己的终止报文段，其 FIN 比特被置为 1；</li></ul><ul id="aa3f6fb1-2598-4644-8e5a-c26da0d3dc2c" class="bulleted-list"><li>最后，该客户对这个服务器的终止报文段进行确认。此时，在两台主机上用于该连接的所有资源都被释放了。</li></ul></details></li></ul><h1 id="eecebb05-3564-46ad-8934-0372e73d905e" class="">六、拥塞控制原理</h1><ul id="f11091d1-065b-4cbf-97cd-2b8cfa26b37e" class="toggle"><li><details open=""><summary>引入</summary><p id="e77a3caa-56bd-41c7-a054-eeb6a5371fff" class="">在实践中，丢包一般是当网络变得拥塞时由于路由器缓存溢出引起的。分组重传因此作为网络拥塞的征兆来对待，但是却无法处理导致网络拥塞的原因，因为有太多的源想以过高的速率发送数据。为了处理网络拥塞原因，需要一些机制以在面临网络拥塞时遏制发送方。</p></details></li></ul><ul id="6745107a-4416-4208-9f90-c8fc6f1b95b8" class="toggle"><li><details open=""><summary>拥塞控制的方法</summary><p id="d9d156e6-194b-4b24-876e-46e8243c40c5" class="">在最为宽泛的级别上，我们可根据网络层是否为运输层拥塞控制提供了显式帮助，来区分拥塞控制方法。</p><ul id="2c639d7f-59c0-4c38-a30d-8ecd7e95c47d" class="toggle"><li><details open=""><summary>端到端拥塞控制（TCP 拥塞控制）</summary><ul id="b59570c7-4572-456c-a871-36c329e67a6e" class="bulleted-list"><li>在端到端拥塞控制方法中，<strong>网络层没有为运输层拥塞控制提供显式支持</strong>；</li></ul><ul id="700d9e43-ed98-4dc4-884b-eeefd2f0416d" class="bulleted-list"><li>即使网络中存在拥塞，<strong>端系统也必须通过对网络行为的观察（如分组丢失与时延）来推断之</strong>；</li></ul><ul id="e428821b-6b07-4cbd-8f77-b633baf04b9e" class="bulleted-list"><li>TCP 报文段的丢失（通过超时或 3 次冗余确认而得知）被认为是网络拥塞的一个迹象，TCP 会相应地减小其窗口长度；</li></ul><p id="1d2f52f1-1b4f-4be4-bfbf-03df9910efc9" class="">即端到端的拥塞控制方法是端系统仅仅依靠其获取到的传输层数据包进行拥塞判断。</p></details></li></ul><ul id="75456830-7ad4-4b1c-82fe-8faa93555750" class="toggle"><li><details open=""><summary>网络辅助的拥塞控制</summary><ul id="2c137422-9dac-45e8-b306-cbe89d8735fe" class="bulleted-list"><li>在网络辅助的拥塞控制中，<strong>网络层构件（即路由器）向发送方提供关于网络中拥塞状态的显式反馈信息</strong>；</li></ul><ul id="a31088e8-2a17-4cd2-9f85-631f045ba38b" class="bulleted-list"><li>这种反馈可以简单地用一个比特来指示链路中的拥塞情况；</li></ul><ul id="b78cb43a-89bb-4261-9d15-14379022a0f4" class="toggle"><li><details open=""><summary>拥塞信息的反馈方式</summary><figure id="083ad32e-36e7-438c-93f7-319cc3efe8ad" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image46.jpeg"><img style="width:336px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image46.jpeg"/></a></figure><p id="ad719494-322d-4a37-a386-4cb6e370cfa3" class="">对于网络辅助的拥塞控制，拥塞信息从网络反馈到发送方通常有两种方式：</p><ul id="7a844eda-b924-455c-81bc-0051542a2456" class="bulleted-list"><li>对方收到了你的答复并且亲了你的小嘴唇可以由网络路由器发给发送方。这种方式的通知通常采用了一种<strong>阻塞分组（choke packet）</strong>的形式（主要是说：“我拥塞了！”）。</li></ul><ul id="d3541d1f-9164-4887-adce-272d10c1aee0" class="bulleted-list"><li>第二种形式的通知是，<strong>路由器标记或更新从发送方流向接收方的分组中的某个字段来指示拥塞的产生</strong>。一旦收到一个标记的分组后，接收方就会向发送方通知该网络拥塞指示。注意到后一种形式的通知至少要经过一个完整的往返时间。</li></ul></details></li></ul><ul id="15f25829-fa8f-4a79-b33c-d9632ef02ab2" class="toggle"><li><details open=""><summary>网络辅助的拥塞控制例子：ATM ABR 拥塞控制</summary><ul id="4bf8a57d-27c5-45d3-aae8-b9ef86ed28ee" class="toggle"><li><details open=""><summary>ABR：available bit rate</summary><p id="dbc4e368-6e61-4d1f-824e-5d79a2fdc39c" class="">ABR 已被设计成一种弹性数据传输服务，不要求最小数据链路带宽。</p><ul id="87a8afad-9b21-4fa7-a925-5f10ed72b040" class="bulleted-list"><li>当网络轻载时，ABR 服务会充分利用空闲的可用带宽；</li></ul><ul id="02c2065f-10e8-40a9-b040-1b2a0b4f5de3" class="bulleted-list"><li>当网络拥塞时，ABR 服务会将其传输速率抑制为某些预先确定的最小传输速率；</li></ul><ul id="37087b3f-b3ff-4a8c-91e2-70b9709a9da1" class="toggle"><li><details open=""><summary>资源管理信元 RM：resource management cell</summary><p id="6f14a5c6-ac42-4d67-b3f2-c0bb9e32e4c1" class="">交换机即为路由器，信元即分组，分为<strong>数据信元</strong>和<strong>资源管理信元</strong> RM。</p><figure id="24dcbc5b-faa4-4bbf-b36e-b5194adf5c00" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image47.jpeg"><img style="width:700px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image47.jpeg"/></a></figure><ul id="15db33d7-8316-4b9e-a685-b12f735e768e" class="bulleted-list"><li>对于 ATM ABR 服务，数据信元从源经过一系列中间交换机传输到目的地。<strong>在数据信元中夹杂着所谓的资源管理信元</strong></li></ul><ul id="204815be-9587-4723-a422-9b667de6e953" class="bulleted-list"><li>这些 RM 信元可被用来在主机和交换机之间传递与拥塞相关的信息；</li></ul><ul id="9d3327a1-01e3-44e3-a07f-f633cf7b0e1c" class="bulleted-list"><li>当一个 RM 信元到达目的地时（数据信元留下），它将被掉转方向并向发送方发送（很可能是在目的地修改了该 RM 信元的内容之后）；</li></ul><ul id="3aabe50a-21fe-4f39-aa49-05500ed5dce2" class="bulleted-list"><li>交换机也有可能自己产生一个RM 信元，并将该 RM 信元直接发送给源。因此，RM 信元可用来提供直接网络反馈和经由接收方的网络反馈；</li></ul></details></li></ul></details></li></ul><ul id="4f71b909-ec78-4dc2-a5d0-fcf5e07a3768" class="toggle"><li><details open=""><summary>ABR 提供的拥塞信息传递机制</summary><ul id="fddf483d-4466-4a1c-b73a-39eaeee6b4dd" class="toggle"><li><details open=""><summary>CI EI bit</summary><p id="c721c3f1-57b4-46c1-9344-2bb7e5baeb94" class="">发送方到接收方的 RM 信元是夹杂在数据单元当中的。RM 信元的夹杂比率是一个可调参数，默认值是每 32 个数据信元中有一个 RM 信元。这些 RM 信元中有一个拥塞指示（Congestion Indication，CI）比特和无增长（No Increase，NI）比特，这两个比特可被一台拥塞的交换机设置：</p><ul id="27e17e00-90fa-4ce8-9e6a-eba104504155" class="bulleted-list"><li>交换机可以在轻微拥塞时将经过的 RM 信元中的 NI 比特置为 1；</li></ul><ul id="d89686e3-5c09-4433-bd5a-0dbd8b060883" class="bulleted-list"><li>在严重拥塞时，把 CI 比特置为 1；</li></ul><p id="8154f36f-c724-471a-b26f-2fd2624d6fa5" class="">当目的主机收到一个 RM 信元时，它将把该 RM 信元发回给发送方，而保持CI 与 NI 比特不变（除了 CI 比特也许会因为EFCI 机制而由目的端置为 1 之外）。<mark class="highlight-red">简单说，一旦 RM 信元被一个拥塞交换机设置后，不论接下来的传递多么顺畅，其 CI 和 EI 值不会再修改回去。类似于短板效应，反应的是通信链路中的痛点。</mark></p></details></li></ul><ul id="2108d9cc-b080-45d7-a9e9-0bea6da6936b" class="toggle"><li><details open=""><summary><strong>ER 显示速率</strong></summary><p id="695a2516-710f-4181-b317-673bb3a6743a" class="">每一个 RM 信元还包含一个两字节的显式速率（Explicit Rate，ER）字段。一个拥塞的交换机也许会降低经过的 RM 信元中 ER 字段所包含的值。以这种方式，ER 字段将被设置为在源至目的地的路径上的所有交换机中的最小可支持速率。<mark class="highlight-red">只往小的改，不向大的改。</mark></p></details></li></ul><ul id="4c2206f0-ebed-4b36-bde7-16fda6bb1c95" class="toggle"><li><details open=""><summary><strong>EFCI bit（在数据信元中）</strong></summary><p id="ccfe53f7-ea4f-4ca7-9abb-7d5fbb34341e" class="">每个<strong>数据信元</strong>都包含 1 比特的显式转发拥塞指示（ Explicit Forward Congestion Indication，EFCI）比特。某拥塞的网络交换机可把一个数据信元中的 EFCI 比特设置为 1 来向目的主机发送网络已经拥塞的信令。其目的地必须检查所有收到的数据信元中的 EFCI比特。</p><p id="72009ce5-3893-422a-8a0d-124e3031caf1" class="">当一个 RM 信元到达目的地时，如果多数近来收到的数据信元的 EFCI 比特都被置为 1，则目的地就会将 RM 信元的拥塞指示比特（CI 比特）置为 1，并将该RM 信元发送回发送方。使用数据信元中的 EFCI 比特和 RM 信元中的 CI 比特， 发送方因而能在网络交换机拥塞时得到通知。</p></details></li></ul></details></li></ul></details></li></ul></details></li></ul></details></li></ul><h1 id="94cc02bb-16bf-443f-903d-9f9330ddc85b" class="">七、TCP 拥塞控制——端到端的拥塞控制</h1><p id="703b913a-21d9-40d5-80e1-5256c402668a" class=""><mark class="highlight-red">拥塞控制主要是因为网络核心没有办法处理，流量控制主要是接收端没有办法处理。</mark></p><ul id="df9f15f3-8bf2-48a7-90fb-cc65db091278" class="toggle"><li><details open=""><summary>TCP 拥塞控制概述</summary><ul id="f24e0089-c6ab-4ec4-9c0b-6dd964cb5c82" class="bulleted-list"><li>TCP 拥塞控制的目的<p id="7dd82247-7f79-44a1-a2d5-c1fd3de696dd" class="">TCP 所采用的方法是让每一个发送方根据所感知到的网络拥塞程度来限制其能向连接发送流量的速率：（不是物理发送速率）</p></li></ul><ul id="6dd26859-3d5b-4371-9e9f-7e064b6e0922" class="bulleted-list"><li>如果一个 TCP 发送方感知从它到目的地之间的路径上没什么拥塞，则TCP 发送方增加其发送速率；</li></ul><ul id="e2d5eb1c-6b2a-497b-8345-621dc7e32e07" class="bulleted-list"><li>如果发送方感知沿着该路径有拥塞，则发送方就会降低其发送速率；</li></ul></details></li></ul><ul id="9d667a6d-6d50-459b-90f7-c7a192d6a3ba" class="toggle"><li><details open=""><summary>TCP 发送方的发送流量速率限制:</summary><p id="188df1ab-0f6c-412a-a85c-bc8263f6ff49" class="">TCP 连接的每一端都是由一个接收缓存、一个发送缓存和几个变量（𝐿𝑎𝑠𝑡𝐵𝑦𝑡𝑒𝑅𝑒𝑎𝑑、𝑟𝑤𝑛𝑑等）组成。运行在发送方的 TCP 拥塞控制机制跟踪一个额外的变量，即拥塞窗口（congestion window），表示为𝒄𝒘𝒏𝒅，它对一个 TCP发送方能向网络中发送流量的速率进行了限制。特别是，在一个发送方中未被确认的数据量不会超过𝑐𝑤𝑛𝑑与𝑟𝑤𝑛𝑑中的最小值，即</p><p id="4dc2191b-5a3c-4393-90d0-f571180c1153" class="">𝐿𝑎𝑠𝑡𝐵𝑦𝑡𝑒𝑆𝑒𝑛𝑡 − 𝐿𝑎𝑠𝑡𝐵𝑦𝑡𝑒𝐴𝑐𝑘𝑒𝑑 ≤ {𝑟𝑤𝑛𝑑, 𝑐𝑤𝑛𝑑}</p><p id="efafa983-1a4d-4f0b-80fb-3c925e059f2f" class="">若不考虑接收窗口限制，在每个往返时间（RTT）的起始点，上面的限制条件允许发送方向该连接发送𝑤𝑛𝑑个字节的数据，在该 RTT 结束时发送方接收对数据的确认报文。因此，该发送方的发送速率大概是𝑐𝑤𝑛𝑑/𝑅𝑇𝑇字节/秒。通过调节𝒄𝒘𝒏𝒅的值，发送方因此能调整它向连接发送数据的速率。</p></details></li></ul><ul id="3ba14b45-212f-4ccf-ab04-f8049ab7b30e" class="toggle"><li><details open=""><summary>TCP 发送方对网络拥塞的感知——带宽探测</summary><ul id="fedfe792-53e6-4385-ab6d-669b6e5e0ac3" class="bulleted-list"><li><strong>一个丢失的报文段表意味着拥塞：</strong><p id="de1844d2-ce3b-4b3b-bd54-6f394fc608bd" class="">因此当丢失报文段时应当降低 TCP 发送方的速率。对于给定报文段，一个超时事件或四个确认（一个初始 ACK 和其后的三个冗余 ACK）被解释为 “丢包事件”的一种隐含的指示。从拥塞控制的观点看，TCP 发送方应当减小它的拥塞窗口长度，即减小其发送速率，以应对这种推测的丢包事件。</p></li></ul><ul id="a593a650-13f8-4cda-a9f2-42cbe584f155" class="bulleted-list"><li>一个确认报文段指示该网络正在顺利的向接收方交付发送方的报文段：<p id="e1ddfa2b-52d3-4a3f-b440-05a0c64f81e4" class="">因此，当对先前未确认报文段的确认到达时，能够增加发送方的速率。确认到达被认为是一切顺利的隐含指示，即报文段正从发送方成功地交付给接收方， 因此该网络不拥塞。拥塞窗口长度因此能够增加。</p></li></ul><ul id="95613027-3073-44c2-b55e-987dc2060818" class="bulleted-list"><li><strong>带宽探测：</strong><mark class="highlight-red"><strong>加法增乘性减</strong></mark><p id="7efd4236-b4ad-414c-8712-0af9dd0701f7" class="">给定 ACK 指示源到目的地路径无拥塞，而丢包事件指示路径拥塞，TCP 调节其传输速率的策略是增加其速率以响应到达的 ACK，除非出现丢包事件时才减小传输速率。</p><p id="0f542b3a-11a6-48a9-bcab-355e77602450" class="">因此，为探测拥塞开始出现的速率，TCP 发送方接收到 ACK 便增加它的传输速率，到发生丢包时，传输速率降低，当降低到原来的拥塞窗口的一半时（8→4），再次开始根据 ACK 提升发送速率，进而再次开始探测，看看拥塞开始速率是否发生了变化。</p><figure id="d54199fa-d8dc-456e-8eb1-0ed73b835b29" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image48.jpeg"><img style="width:624px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image48.jpeg"/></a></figure><p id="67f66ef8-e334-4689-9716-ac4215dce103" class="">注意到网络中没有明确的拥塞状态信令，即 ACK 和丢包事件充当了隐式信号，并且每个 TCP 发送方根据异步于其他 TCP 发送方的本地信息而行动。</p></li></ul></details></li></ul><ul id="0a861329-b252-4114-8f57-79b63699e32c" class="toggle"><li><details open=""><summary>TCP 拥塞控制算法的细节</summary><p id="1302f502-2dad-41a1-8f03-49ef378b6ce6" class="">该算法包括 3 个主要部分：①慢启动；②拥塞避免；③快速恢复。慢启动和拥塞避免是 TCP 的强制部分，两者的差异在于对收到的 ACK 做出反应时增加𝑐𝑤𝑛𝑑长度的方式，慢启动比拥塞避免能更快地增加𝒄𝒘𝒏𝒅的长度。快速恢复是推荐部分，对 TCP 发送方并非是必需的。</p><ul id="455ced25-937b-49f1-9251-5f27b0c1b4cb" class="toggle"><li><details open=""><summary>缓/慢启动</summary><figure id="1f67a114-1290-4e9d-8d3f-a65eb1f04b67" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image49.jpeg"><img style="width:240px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image49.jpeg"/></a></figure><ul id="73449d52-3b43-4b98-b10c-6dcb039087ff" class="bulleted-list"><li><strong>缓启动的定义</strong><p id="fca98c58-25b5-4a75-98ac-a44f54abfa4e" class="">在慢启动（slow-start）状态，𝑐𝑤𝑛𝑑的值以 1 个 MSS 开始，并且每当传输的报文段首次被确认就增加 1 个 MSS。TCP 向网络发送第一个报文段并等待一个确认。当该确认到达时，TCP 发送方将拥塞窗口增加一个 MSS，并发送出两个最大长度的报文段。这两个报文段被确认，则发送方对每个确认报文段将拥塞窗口增加一个 MSS，使得拥塞窗口变为 4 个 MSS，并这样下去。这一过程每过一个 RTT，发送速率就翻番。因此，TCP 发送速率起始慢，但在慢启动阶段以指数增长。</p></li></ul><ul id="97663eed-d7ee-4514-8a36-a3a121595b6f" class="bulleted-list"><li><strong>缓启动结束的情况</strong><ol id="81d925ff-8623-49c9-9ad3-728afa633432" class="numbered-list" start="1"><li>首先，如果存在一个由超时指示的丢包事件（即拥塞），TCP 发送方将𝒄𝒘𝒏𝒅设置为 1 并重新开始慢启动过程。它还将第二个状态变量的值𝑠𝑠𝑡ℎ𝑟𝑒𝑠ℎ（“慢启动阀值”的速记）设置为𝑐𝑤𝑛𝑑/2，即当检测到拥塞时将𝑠𝑠𝑡ℎ𝑟𝑒𝑠ℎ置为拥塞窗口值的一半；</li></ol><ol id="70b4fb1f-bfa7-44f4-94d1-fb1c483c069e" class="numbered-list" start="2"><li>因为当检测到拥塞时𝑠𝑡ℎ𝑟𝑒𝑠ℎ 设为𝑐𝑤𝑛𝑑的值一半，当到达或超过𝑠𝑠𝑡ℎ𝑟𝑒𝑠ℎ的值时，继续使𝑐𝑤𝑛𝑑翻番可能有些鲁莽，因此当𝒄𝒘𝒏𝒅的值等于𝒔𝒔𝒕𝒉𝒓𝒆𝒔𝒉时，结束慢启动并且 TCP 转移到拥塞避免模式；</li></ol><ol id="5295bf4d-afb6-48c8-9548-9211027ed867" class="numbered-list" start="3"><li>最后一种结束慢启动的方式是，如果检测到 3 个冗余 ACK，这时 TCP结束慢启动，执行一种快速重传并进入快速恢复状态；</li></ol></li></ul></details></li></ul><ul id="3da0d903-5e9e-4012-af1c-55c101a131b5" class="toggle"><li><details open=""><summary>拥塞避免</summary><p id="618a9b28-7edb-4990-b33d-e7783ad8ffae" class="">一旦进入拥塞避免状态，𝑐𝑤𝑛𝑑的值大约是上次遇到拥塞时的值的一半，即距离拥塞可能并不遥远。因此，TCP 无法每过一个 RTT 再将𝒄𝒘𝒏𝒅的值翻番，而是采用了一种较为保守的方法，每个 RTT 只将𝒄𝒘𝒏𝒅的值增加一个 MSS，进入线性增长探测模式。</p><ul id="dc7ea812-a722-48f9-9da5-f9370541c88d" class="bulleted-list"><li>拥塞避免结束的情况同缓启动结束的情况<figure id="a524f6f5-6357-4ed7-9d89-f53435199833" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/Untitled%208.png"><img style="width:552px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/Untitled%208.png"/></a></figure></li></ul></details></li></ul><ul id="921611e4-a56d-4bce-8ebf-7f9df2f3118a" class="toggle"><li><details open=""><summary>快速恢复</summary><ul id="3ef2de99-9b45-4612-90a1-26c891df511b" class="bulleted-list"><li><strong>TCP Tahoe 版本</strong><p id="0919c51c-029b-4b3d-bd41-220e62594f5a" class="">发生3 个冗余ACK 指示的丢包事件，都无条件地将其拥塞窗口减至l 个MSS， 并进入慢启动阶段。</p></li></ul><ul id="4c3467c6-422f-440d-a4e7-137cf23e1049" class="bulleted-list"><li>TCP Reno 版本<p id="5c95ed0a-56be-4e88-9a06-7f76a540b928" class="">当遇到接收到冗余 ACK 触发的拥塞窗口降低时，TCP Reno 将𝑟𝑤𝑛𝑑降低到原来窗口值的一半后再进行拥塞避免的线性增长阶段。否则和Tahoe一样减到1个MSS。</p><figure id="ffc237d0-13ea-4aa8-b67d-b0d4287e758d" class="image"><a href="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image50.png"><img style="width:700px" src="Untitled%204cfc002757ed49dd99b858e3b8ad5251/image50.png"/></a></figure><p id="c8bfe33b-9f0f-479c-8227-57ac3e8d21d2" class="">
</p></li></ul></details></li></ul></details></li></ul></div></article></body></html>